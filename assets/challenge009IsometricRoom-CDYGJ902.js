import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as N,aP as ei,n as Mc,j as Bc,m as _c,a4 as fe,_ as Yo,aQ as Ye,X as bi,U as Zo,Q as ds,aR as Cc,a0 as Ko,a3 as Ai,M as $,P as Pc,W as zc,aS as Ic,O as Lc,S as Nc,c as Fc,J as ni,V as We,aT as fo,aU as Ft,aV as gt,ar as Rc,v as ee,aq as Ut,aW as Vc,Y as po,ak as Jo,aX as la,aY as Ge,aZ as qc,s as Ie,z as An,t as Un,R as W,a as vt,a_ as kc,a$ as Qt,b as Qo,d as jc,b0 as Oc,q as Wc,b1 as Gc,b2 as Sn,p as Dc,b3 as Hc,o as si,b4 as ii,A as $c,G as Uc,l as Xc}from"./index-ACiF8Mur.js";const Pn=new N;function _t(u,t,e,n,s,i){const o=2*Math.PI*s/4,r=Math.max(i-2*s,0),a=Math.PI/4;Pn.copy(t),Pn[n]=0,Pn.normalize();const c=.5*o/(o+r),l=1-Pn.angleTo(u)/a;return Math.sign(Pn[e])===1?l*c:r/(o+r)+c+c*(1-l)}class O extends ei{constructor(t=1,e=1,n=1,s=2,i=.1){if(s=s*2+1,i=Math.min(t/2,e/2,n/2,i),super(1,1,1,s,s,s),s===1)return;const o=this.toNonIndexed();this.index=null,this.attributes.position=o.attributes.position,this.attributes.normal=o.attributes.normal,this.attributes.uv=o.attributes.uv;const r=new N,a=new N,c=new N(t,e,n).divideScalar(2).subScalar(i),l=this.attributes.position.array,d=this.attributes.normal.array,h=this.attributes.uv.array,f=l.length/6,p=new N,x=.5/s;for(let g=0,y=0;g<l.length;g+=3,y+=2)switch(r.fromArray(l,g),a.copy(r),a.x-=Math.sign(a.x)*x,a.y-=Math.sign(a.y)*x,a.z-=Math.sign(a.z)*x,a.normalize(),l[g+0]=c.x*Math.sign(r.x)+a.x*i,l[g+1]=c.y*Math.sign(r.y)+a.y*i,l[g+2]=c.z*Math.sign(r.z)+a.z*i,d[g+0]=a.x,d[g+1]=a.y,d[g+2]=a.z,Math.floor(g/f)){case 0:p.set(1,0,0),h[y+0]=_t(p,a,"z","y",i,n),h[y+1]=1-_t(p,a,"y","z",i,e);break;case 1:p.set(-1,0,0),h[y+0]=1-_t(p,a,"z","y",i,n),h[y+1]=1-_t(p,a,"y","z",i,e);break;case 2:p.set(0,1,0),h[y+0]=1-_t(p,a,"x","z",i,t),h[y+1]=_t(p,a,"z","x",i,n);break;case 3:p.set(0,-1,0),h[y+0]=1-_t(p,a,"x","z",i,t),h[y+1]=1-_t(p,a,"z","x",i,n);break;case 4:p.set(0,0,1),h[y+0]=1-_t(p,a,"x","y",i,t),h[y+1]=1-_t(p,a,"y","x",i,e);break;case 5:p.set(0,0,-1),h[y+0]=_t(p,a,"x","y",i,t),h[y+1]=1-_t(p,a,"y","x",i,e);break}}}const Yc=/^[og]\s*(.+)?/,Zc=/^mtllib /,Kc=/^usemtl /,Jc=/^usemap /,tr=/\s+/,er=new N,Si=new N,nr=new N,sr=new N,Ct=new N,fs=new Mc;function Qc(){const u={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(s,i){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const r={index:this.materials.length,name:s||"",mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(a){const c={index:typeof a=="number"?a:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(r),r},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(s){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),s&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return s&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}},n&&n.name&&typeof n.clone=="function"){const s=n.clone(0);s.inherited=!0,this.object.materials.push(s)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseNormalIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseUVIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/2)*2},addVertex:function(t,e,n){const s=this.vertices,i=this.object.geometry.vertices;i.push(s[t+0],s[t+1],s[t+2]),i.push(s[e+0],s[e+1],s[e+2]),i.push(s[n+0],s[n+1],s[n+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,n){const s=this.normals,i=this.object.geometry.normals;i.push(s[t+0],s[t+1],s[t+2]),i.push(s[e+0],s[e+1],s[e+2]),i.push(s[n+0],s[n+1],s[n+2])},addFaceNormal:function(t,e,n){const s=this.vertices,i=this.object.geometry.normals;er.fromArray(s,t),Si.fromArray(s,e),nr.fromArray(s,n),Ct.subVectors(nr,Si),sr.subVectors(er,Si),Ct.cross(sr),Ct.normalize(),i.push(Ct.x,Ct.y,Ct.z),i.push(Ct.x,Ct.y,Ct.z),i.push(Ct.x,Ct.y,Ct.z)},addColor:function(t,e,n){const s=this.colors,i=this.object.geometry.colors;s[t]!==void 0&&i.push(s[t+0],s[t+1],s[t+2]),s[e]!==void 0&&i.push(s[e+0],s[e+1],s[e+2]),s[n]!==void 0&&i.push(s[n+0],s[n+1],s[n+2])},addUV:function(t,e,n){const s=this.uvs,i=this.object.geometry.uvs;i.push(s[t+0],s[t+1]),i.push(s[e+0],s[e+1]),i.push(s[n+0],s[n+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,n,s,i,o,r,a,c){const l=this.vertices.length;let d=this.parseVertexIndex(t,l),h=this.parseVertexIndex(e,l),f=this.parseVertexIndex(n,l);if(this.addVertex(d,h,f),this.addColor(d,h,f),r!==void 0&&r!==""){const p=this.normals.length;d=this.parseNormalIndex(r,p),h=this.parseNormalIndex(a,p),f=this.parseNormalIndex(c,p),this.addNormal(d,h,f)}else this.addFaceNormal(d,h,f);if(s!==void 0&&s!==""){const p=this.uvs.length;d=this.parseUVIndex(s,p),h=this.parseUVIndex(i,p),f=this.parseUVIndex(o,p),this.addUV(d,h,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let n=0,s=t.length;n<s;n++){const i=this.parseVertexIndex(t[n],e);this.addVertexPoint(i),this.addColor(i)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const n=this.vertices.length,s=this.uvs.length;for(let i=0,o=t.length;i<o;i++)this.addVertexLine(this.parseVertexIndex(t[i],n));for(let i=0,o=e.length;i<o;i++)this.addUVLine(this.parseUVIndex(e[i],s))}};return u.startObject("",!1),u}class ua extends Bc{constructor(t){super(t),this.materials=null}load(t,e,n,s){const i=this,o=new _c(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(r){try{e(i.parse(r))}catch(a){s?s(a):console.error(a),i.manager.itemError(t)}},n,s)}setMaterials(t){return this.materials=t,this}parse(t){const e=new Qc;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const n=t.split(`
`);let s=[];for(let r=0,a=n.length;r<a;r++){const c=n[r].trimStart();if(c.length===0)continue;const l=c.charAt(0);if(l!=="#")if(l==="v"){const d=c.split(tr);switch(d[0]){case"v":e.vertices.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3])),d.length>=7?(fs.setRGB(parseFloat(d[4]),parseFloat(d[5]),parseFloat(d[6])).convertSRGBToLinear(),e.colors.push(fs.r,fs.g,fs.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3]));break;case"vt":e.uvs.push(parseFloat(d[1]),parseFloat(d[2]));break}}else if(l==="f"){const h=c.slice(1).trim().split(tr),f=[];for(let x=0,g=h.length;x<g;x++){const y=h[x];if(y.length>0){const m=y.split("/");f.push(m)}}const p=f[0];for(let x=1,g=f.length-1;x<g;x++){const y=f[x],m=f[x+1];e.addFace(p[0],y[0],m[0],p[1],y[1],m[1],p[2],y[2],m[2])}}else if(l==="l"){const d=c.substring(1).trim().split(" ");let h=[];const f=[];if(c.indexOf("/")===-1)h=d;else for(let p=0,x=d.length;p<x;p++){const g=d[p].split("/");g[0]!==""&&h.push(g[0]),g[1]!==""&&f.push(g[1])}e.addLineGeometry(h,f)}else if(l==="p"){const h=c.slice(1).trim().split(" ");e.addPointGeometry(h)}else if((s=Yc.exec(c))!==null){const d=(" "+s[0].slice(1).trim()).slice(1);e.startObject(d)}else if(Kc.test(c))e.object.startMaterial(c.substring(7).trim(),e.materialLibraries);else if(Zc.test(c))e.materialLibraries.push(c.substring(7).trim());else if(Jc.test(c))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(l==="s"){if(s=c.split(" "),s.length>1){const h=s[1].trim().toLowerCase();e.object.smooth=h!=="0"&&h!=="off"}else e.object.smooth=!0;const d=e.object.currentMaterial();d&&(d.smooth=e.object.smooth)}else{if(c==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+c+'"')}}e.finalize();const i=new fe;if(i.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let r=0,a=e.objects.length;r<a;r++){const c=e.objects[r],l=c.geometry,d=c.materials,h=l.type==="Line",f=l.type==="Points";let p=!1;if(l.vertices.length===0)continue;const x=new Yo;x.setAttribute("position",new Ye(l.vertices,3)),l.normals.length>0&&x.setAttribute("normal",new Ye(l.normals,3)),l.colors.length>0&&(p=!0,x.setAttribute("color",new Ye(l.colors,3))),l.hasUVIndices===!0&&x.setAttribute("uv",new Ye(l.uvs,2));const g=[];for(let m=0,v=d.length;m<v;m++){const b=d[m],A=b.name+"_"+b.smooth+"_"+p;let S=e.materials[A];if(this.materials!==null){if(S=this.materials.create(b.name),h&&S&&!(S instanceof bi)){const T=new bi;Zo.prototype.copy.call(T,S),T.color.copy(S.color),S=T}else if(f&&S&&!(S instanceof ds)){const T=new ds({size:10,sizeAttenuation:!1});Zo.prototype.copy.call(T,S),T.color.copy(S.color),T.map=S.map,S=T}}S===void 0&&(h?S=new bi:f?S=new ds({size:1,sizeAttenuation:!1}):S=new Cc,S.name=b.name,S.flatShading=!b.smooth,S.vertexColors=p,e.materials[A]=S),g.push(S)}let y;if(g.length>1){for(let m=0,v=d.length;m<v;m++){const b=d[m];x.addGroup(b.groupStart,b.groupCount,m)}h?y=new Ko(x,g):f?y=new Ai(x,g):y=new $(x,g)}else h?y=new Ko(x,g[0]):f?y=new Ai(x,g[0]):y=new $(x,g[0]);y.name=c.name,i.add(y)}else if(e.vertices.length>0){const r=new ds({size:1,sizeAttenuation:!1}),a=new Yo;a.setAttribute("position",new Ye(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(a.setAttribute("color",new Ye(e.colors,3)),r.vertexColors=!0);const c=new Ai(a,r);i.add(c)}return i}}const un={width:window.innerWidth,height:window.innerHeight},hn=new Pc(20,un.width/un.height,25,800);un.width<768?hn.position.set(200,175,200):hn.position.set(120,100,120);const ha=document.querySelector("canvas.webgl");if(ha===null)throw new Error("Cannot find the canvas element");const $t=new zc({canvas:ha,antialias:!0});$t.setSize(un.width,un.height);$t.setPixelRatio(Math.min(window.devicePixelRatio,2));$t.autoClear=!1;$t.shadowMap.enabled=!0;$t.shadowMap.type=Ic;const Tn=new Lc(hn,$t.domElement);Tn.enableDamping=!0;Tn.minDistance=30;Tn.maxDistance=400;Tn.maxPolarAngle=Math.PI/1.98;const H=new Nc,Ti=Fc(hn,$t.domElement),da=0,tl=1,el=2,ir=2,Ei=1.25,or=1,Gn=6*4+4+4,oi=65535,nl=Math.pow(2,-24),Mi=Symbol("SKIP_GENERATION");function sl(u){return u.index?u.index.count:u.attributes.position.count}function En(u){return sl(u)/3}function il(u,t=ArrayBuffer){return u>65535?new Uint32Array(new t(4*u)):new Uint16Array(new t(2*u))}function ol(u,t){if(!u.index){const e=u.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=il(e,n);u.setIndex(new ni(s,1));for(let i=0;i<e;i++)s[i]=i}}function fa(u){const t=En(u),e=u.drawRange,n=e.start/3,s=(e.start+e.count)/3,i=Math.max(0,n),o=Math.min(t,s)-i;return[{offset:Math.floor(i),count:Math.floor(o)}]}function pa(u){if(!u.groups||!u.groups.length)return fa(u);const t=[],e=new Set,n=u.drawRange,s=n.start/3,i=(n.start+n.count)/3;for(const r of u.groups){const a=r.start/3,c=(r.start+r.count)/3;e.add(Math.max(s,a)),e.add(Math.min(i,c))}const o=Array.from(e.values()).sort((r,a)=>r-a);for(let r=0;r<o.length-1;r++){const a=o[r],c=o[r+1];t.push({offset:Math.floor(a),count:Math.floor(c-a)})}return t}function rl(u){if(u.groups.length===0)return!1;const t=En(u),e=pa(u).sort((i,o)=>i.offset-o.offset),n=e[e.length-1];n.count=Math.min(t-n.offset,n.count);let s=0;return e.forEach(({count:i})=>s+=i),t!==s}function Bi(u,t,e,n,s){let i=1/0,o=1/0,r=1/0,a=-1/0,c=-1/0,l=-1/0,d=1/0,h=1/0,f=1/0,p=-1/0,x=-1/0,g=-1/0;for(let y=t*6,m=(t+e)*6;y<m;y+=6){const v=u[y+0],b=u[y+1],A=v-b,S=v+b;A<i&&(i=A),S>a&&(a=S),v<d&&(d=v),v>p&&(p=v);const T=u[y+2],M=u[y+3],B=T-M,_=T+M;B<o&&(o=B),_>c&&(c=_),T<h&&(h=T),T>x&&(x=T);const z=u[y+4],C=u[y+5],E=z-C,P=z+C;E<r&&(r=E),P>l&&(l=P),z<f&&(f=z),z>g&&(g=z)}n[0]=i,n[1]=o,n[2]=r,n[3]=a,n[4]=c,n[5]=l,s[0]=d,s[1]=h,s[2]=f,s[3]=p,s[4]=x,s[5]=g}function al(u,t=null,e=null,n=null){const s=u.attributes.position,i=u.index?u.index.array:null,o=En(u),r=s.normalized;let a;t===null?(a=new Float32Array(o*6*4),e=0,n=o):(a=t,e=e||0,n=n||o);const c=s.array,l=s.offset||0;let d=3;s.isInterleavedBufferAttribute&&(d=s.data.stride);const h=["getX","getY","getZ"];for(let f=e;f<e+n;f++){const p=f*3,x=f*6;let g=p+0,y=p+1,m=p+2;i&&(g=i[g],y=i[y],m=i[m]),r||(g=g*d+l,y=y*d+l,m=m*d+l);for(let v=0;v<3;v++){let b,A,S;r?(b=s[h[v]](g),A=s[h[v]](y),S=s[h[v]](m)):(b=c[g+v],A=c[y+v],S=c[m+v]);let T=b;A<T&&(T=A),S<T&&(T=S);let M=b;A>M&&(M=A),S>M&&(M=S);const B=(M-T)/2,_=v*2;a[x+_+0]=T+B,a[x+_+1]=B+(Math.abs(T)+B)*nl}}return a}function K(u,t,e){return e.min.x=t[u],e.min.y=t[u+1],e.min.z=t[u+2],e.max.x=t[u+3],e.max.y=t[u+4],e.max.z=t[u+5],e}function rr(u){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=u[n+3]-u[n];s>e&&(e=s,t=n)}return t}function ar(u,t){t.set(u)}function cr(u,t,e){let n,s;for(let i=0;i<3;i++){const o=i+3;n=u[i],s=t[i],e[i]=n<s?n:s,n=u[o],s=t[o],e[o]=n>s?n:s}}function ps(u,t,e){for(let n=0;n<3;n++){const s=t[u+2*n],i=t[u+2*n+1],o=s-i,r=s+i;o<e[n]&&(e[n]=o),r>e[n+3]&&(e[n+3]=r)}}function zn(u){const t=u[3]-u[0],e=u[4]-u[1],n=u[5]-u[2];return 2*(t*e+e*n+n*t)}const he=32,cl=(u,t)=>u.candidate-t.candidate,Te=new Array(he).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),ms=new Float32Array(6);function ll(u,t,e,n,s,i){let o=-1,r=0;if(i===da)o=rr(t),o!==-1&&(r=(t[o]+t[o+3])/2);else if(i===tl)o=rr(u),o!==-1&&(r=ul(e,n,s,o));else if(i===el){const a=zn(u);let c=Ei*s;const l=n*6,d=(n+s)*6;for(let h=0;h<3;h++){const f=t[h],g=(t[h+3]-f)/he;if(s<he/4){const y=[...Te];y.length=s;let m=0;for(let b=l;b<d;b+=6,m++){const A=y[m];A.candidate=e[b+2*h],A.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:M}=A;for(let B=0;B<3;B++)M[B]=1/0,M[B+3]=-1/0,T[B]=1/0,T[B+3]=-1/0,S[B]=1/0,S[B+3]=-1/0;ps(b,e,S)}y.sort(cl);let v=s;for(let b=0;b<v;b++){const A=y[b];for(;b+1<v&&y[b+1].candidate===A.candidate;)y.splice(b+1,1),v--}for(let b=l;b<d;b+=6){const A=e[b+2*h];for(let S=0;S<v;S++){const T=y[S];A>=T.candidate?ps(b,e,T.rightCacheBounds):(ps(b,e,T.leftCacheBounds),T.count++)}}for(let b=0;b<v;b++){const A=y[b],S=A.count,T=s-A.count,M=A.leftCacheBounds,B=A.rightCacheBounds;let _=0;S!==0&&(_=zn(M)/a);let z=0;T!==0&&(z=zn(B)/a);const C=or+Ei*(_*S+z*T);C<c&&(o=h,c=C,r=A.candidate)}}else{for(let v=0;v<he;v++){const b=Te[v];b.count=0,b.candidate=f+g+v*g;const A=b.bounds;for(let S=0;S<3;S++)A[S]=1/0,A[S+3]=-1/0}for(let v=l;v<d;v+=6){let S=~~((e[v+2*h]-f)/g);S>=he&&(S=he-1);const T=Te[S];T.count++,ps(v,e,T.bounds)}const y=Te[he-1];ar(y.bounds,y.rightCacheBounds);for(let v=he-2;v>=0;v--){const b=Te[v],A=Te[v+1];cr(b.bounds,A.rightCacheBounds,b.rightCacheBounds)}let m=0;for(let v=0;v<he-1;v++){const b=Te[v],A=b.count,S=b.bounds,M=Te[v+1].rightCacheBounds;A!==0&&(m===0?ar(S,ms):cr(S,ms,ms)),m+=A;let B=0,_=0;m!==0&&(B=zn(ms)/a);const z=s-m;z!==0&&(_=zn(M)/a);const C=or+Ei*(B*m+_*z);C<c&&(o=h,c=C,r=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:o,pos:r}}function ul(u,t,e,n){let s=0;for(let i=t,o=t+e;i<o;i++)s+=u[i*6+n*2];return s/e}class _i{constructor(){this.boundingData=new Float32Array(6)}}function hl(u,t,e,n,s,i){let o=n,r=n+s-1;const a=i.pos,c=i.axis*2;for(;;){for(;o<=r&&e[o*6+c]<a;)o++;for(;o<=r&&e[r*6+c]>=a;)r--;if(o<r){for(let l=0;l<3;l++){let d=t[o*3+l];t[o*3+l]=t[r*3+l],t[r*3+l]=d}for(let l=0;l<6;l++){let d=e[o*6+l];e[o*6+l]=e[r*6+l],e[r*6+l]=d}o++,r--}else return o}}function dl(u,t,e,n,s,i){let o=n,r=n+s-1;const a=i.pos,c=i.axis*2;for(;;){for(;o<=r&&e[o*6+c]<a;)o++;for(;o<=r&&e[r*6+c]>=a;)r--;if(o<r){let l=u[o];u[o]=u[r],u[r]=l;for(let d=0;d<6;d++){let h=e[o*6+d];e[o*6+d]=e[r*6+d],e[r*6+d]=h}o++,r--}else return o}}function mt(u,t){return t[u+15]===65535}function xt(u,t){return t[u+6]}function zt(u,t){return t[u+14]}function It(u){return u+8}function Lt(u,t){return t[u+6]}function ma(u,t){return t[u+7]}let ya,Wn,Os,wa;const fl=Math.pow(2,32);function eo(u){return"count"in u?1:1+eo(u.left)+eo(u.right)}function pl(u,t,e){return ya=new Float32Array(e),Wn=new Uint32Array(e),Os=new Uint16Array(e),wa=new Uint8Array(e),no(u,t)}function no(u,t){const e=u/4,n=u/2,s="count"in t,i=t.boundingData;for(let o=0;o<6;o++)ya[e+o]=i[o];if(s)if(t.buffer){const o=t.buffer;wa.set(new Uint8Array(o),u);for(let r=u,a=u+o.byteLength;r<a;r+=Gn){const c=r/2;mt(c,Os)||(Wn[r/4+6]+=e)}return u+o.byteLength}else{const o=t.offset,r=t.count;return Wn[e+6]=o,Os[n+14]=r,Os[n+15]=oi,u+Gn}else{const o=t.left,r=t.right,a=t.splitAxis;let c;if(c=no(u+Gn,o),c/4>fl)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Wn[e+6]=c/4,c=no(c,r),Wn[e+7]=a,c}}function ml(u,t){const e=(u.index?u.index.count:u.attributes.position.count)/3,n=e>2**16,s=n?4:2,i=t?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),o=n?new Uint32Array(i):new Uint16Array(i);for(let r=0,a=o.length;r<a;r++)o[r]=r;return o}function yl(u,t,e,n,s){const{maxDepth:i,verbose:o,maxLeafTris:r,strategy:a,onProgress:c,indirect:l}=s,d=u._indirectBuffer,h=u.geometry,f=h.index?h.index.array:null,p=l?dl:hl,x=En(h),g=new Float32Array(6);let y=!1;const m=new _i;return Bi(t,e,n,m.boundingData,g),b(m,e,n,g),m;function v(A){c&&c(A/x)}function b(A,S,T,M=null,B=0){if(!y&&B>=i&&(y=!0,o&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(h))),T<=r||B>=i)return v(S+T),A.offset=S,A.count=T,A;const _=ll(A.boundingData,M,t,S,T,a);if(_.axis===-1)return v(S+T),A.offset=S,A.count=T,A;const z=p(d,f,t,S,T,_);if(z===S||z===S+T)v(S+T),A.offset=S,A.count=T;else{A.splitAxis=_.axis;const C=new _i,E=S,P=z-S;A.left=C,Bi(t,E,P,C.boundingData,g),b(C,E,P,g,B+1);const I=new _i,L=z,j=T-P;A.right=I,Bi(t,L,j,I.boundingData,g),b(I,L,j,g,B+1)}return A}}function wl(u,t){const e=u.geometry;t.indirect&&(u._indirectBuffer=ml(e,t.useSharedArrayBuffer),rl(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),u._indirectBuffer||ol(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=al(e),i=t.indirect?fa(e):pa(e);u._roots=i.map(o=>{const r=yl(u,s,o.offset,o.count,t),a=eo(r),c=new n(Gn*a);return pl(0,r,c),c})}class de{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let i=0,o=t.length;i<o;i++){const a=t[i][e];n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let i=0,o=e.length;i<o;i++){const r=e[i],a=t.dot(r);n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}de.prototype.setFromBox=function(){const u=new N;return function(e,n){const s=n.min,i=n.max;let o=1/0,r=-1/0;for(let a=0;a<=1;a++)for(let c=0;c<=1;c++)for(let l=0;l<=1;l++){u.x=s.x*a+i.x*(1-a),u.y=s.y*c+i.y*(1-c),u.z=s.z*l+i.z*(1-l);const d=e.dot(u);o=Math.min(d,o),r=Math.max(d,r)}this.min=o,this.max=r}}();const gl=function(){const u=new N,t=new N,e=new N;return function(s,i,o){const r=s.start,a=u,c=i.start,l=t;e.subVectors(r,c),u.subVectors(s.end,s.start),t.subVectors(i.end,i.start);const d=e.dot(l),h=l.dot(a),f=l.dot(l),p=e.dot(a),g=a.dot(a)*f-h*h;let y,m;g!==0?y=(d*h-p*f)/g:y=0,m=(d+y*h)/f,o.x=y,o.y=m}}(),mo=function(){const u=new We,t=new N,e=new N;return function(s,i,o,r){gl(s,i,u);let a=u.x,c=u.y;if(a>=0&&a<=1&&c>=0&&c<=1){s.at(a,o),i.at(c,r);return}else if(a>=0&&a<=1){c<0?i.at(0,r):i.at(1,r),s.closestPointToPoint(r,!0,o);return}else if(c>=0&&c<=1){a<0?s.at(0,o):s.at(1,o),i.closestPointToPoint(o,!0,r);return}else{let l;a<0?l=s.start:l=s.end;let d;c<0?d=i.start:d=i.end;const h=t,f=e;if(s.closestPointToPoint(d,!0,t),i.closestPointToPoint(l,!0,e),h.distanceToSquared(d)<=f.distanceToSquared(l)){o.copy(h),r.copy(d);return}else{o.copy(l),r.copy(f);return}}}}(),xl=function(){const u=new N,t=new N,e=new fo,n=new Ft;return function(i,o){const{radius:r,center:a}=i,{a:c,b:l,c:d}=o;if(n.start=c,n.end=l,n.closestPointToPoint(a,!0,u).distanceTo(a)<=r||(n.start=c,n.end=d,n.closestPointToPoint(a,!0,u).distanceTo(a)<=r)||(n.start=l,n.end=d,n.closestPointToPoint(a,!0,u).distanceTo(a)<=r))return!0;const x=o.getPlane(e);if(Math.abs(x.distanceToPoint(a))<=r){const y=x.projectPoint(a,t);if(o.containsPoint(y))return!0}return!1}}(),vl=1e-15;function Ci(u){return Math.abs(u)<vl}class Rt extends gt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new N),this.satBounds=new Array(4).fill().map(()=>new de),this.points=[this.a,this.b,this.c],this.sphere=new Rc,this.plane=new fo,this.needsUpdate=!0}intersectsSphere(t){return xl(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,i=this.satAxes,o=this.satBounds,r=i[0],a=o[0];this.getNormal(r),a.setFromPoints(r,s);const c=i[1],l=o[1];c.subVectors(t,e),l.setFromPoints(c,s);const d=i[2],h=o[2];d.subVectors(e,n),h.setFromPoints(d,s);const f=i[3],p=o[3];f.subVectors(n,t),p.setFromPoints(f,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,t),this.needsUpdate=!1}}Rt.prototype.closestPointToSegment=function(){const u=new N,t=new N,e=new Ft;return function(s,i=null,o=null){const{start:r,end:a}=s,c=this.points;let l,d=1/0;for(let h=0;h<3;h++){const f=(h+1)%3;e.start.copy(c[h]),e.end.copy(c[f]),mo(e,s,u,t),l=u.distanceToSquared(t),l<d&&(d=l,i&&i.copy(u),o&&o.copy(t))}return this.closestPointToPoint(r,u),l=r.distanceToSquared(u),l<d&&(d=l,i&&i.copy(u),o&&o.copy(r)),this.closestPointToPoint(a,u),l=a.distanceToSquared(u),l<d&&(d=l,i&&i.copy(u),o&&o.copy(a)),Math.sqrt(d)}}();Rt.prototype.intersectsTriangle=function(){const u=new Rt,t=new Array(3),e=new Array(3),n=new de,s=new de,i=new N,o=new N,r=new N,a=new N,c=new N,l=new Ft,d=new Ft,h=new Ft,f=new N;function p(x,g,y){const m=x.points;let v=0,b=-1;for(let A=0;A<3;A++){const{start:S,end:T}=l;S.copy(m[A]),T.copy(m[(A+1)%3]),l.delta(o);const M=Ci(g.distanceToPoint(S));if(Ci(g.normal.dot(o))&&M){y.copy(l),v=2;break}const B=g.intersectLine(l,f);if(!B&&M&&f.copy(S),(B||M)&&!Ci(f.distanceTo(T))){if(v<=1)(v===1?y.start:y.end).copy(f),M&&(b=v);else if(v>=2){(b===1?y.start:y.end).copy(f),v=2;break}if(v++,v===2&&b===-1)break}}return v}return function(g,y=null,m=!1){this.needsUpdate&&this.update(),g.isExtendedTriangle?g.needsUpdate&&g.update():(u.copy(g),u.update(),g=u);const v=this.plane,b=g.plane;if(Math.abs(v.normal.dot(b.normal))>1-1e-10){const A=this.satBounds,S=this.satAxes;e[0]=g.a,e[1]=g.b,e[2]=g.c;for(let B=0;B<4;B++){const _=A[B],z=S[B];if(n.setFromPoints(z,e),_.isSeparated(n))return!1}const T=g.satBounds,M=g.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let B=0;B<4;B++){const _=T[B],z=M[B];if(n.setFromPoints(z,t),_.isSeparated(n))return!1}for(let B=0;B<4;B++){const _=S[B];for(let z=0;z<4;z++){const C=M[z];if(i.crossVectors(_,C),n.setFromPoints(i,t),s.setFromPoints(i,e),n.isSeparated(s))return!1}}return y&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const A=p(this,b,d);if(A===1&&g.containsPoint(d.end))return y&&(y.start.copy(d.end),y.end.copy(d.end)),!0;if(A!==2)return!1;const S=p(g,v,h);if(S===1&&this.containsPoint(h.end))return y&&(y.start.copy(h.end),y.end.copy(h.end)),!0;if(S!==2)return!1;if(d.delta(r),h.delta(a),r.dot(a)<0){let E=h.start;h.start=h.end,h.end=E}const T=d.start.dot(r),M=d.end.dot(r),B=h.start.dot(r),_=h.end.dot(r),z=M<B,C=T<_;return T!==_&&B!==M&&z===C?!1:(y&&(c.subVectors(d.start,h.start),c.dot(r)>0?y.start.copy(d.start):y.start.copy(h.start),c.subVectors(d.end,h.end),c.dot(r)<0?y.end.copy(d.end):y.end.copy(h.end)),!0)}}}();Rt.prototype.distanceToPoint=function(){const u=new N;return function(e){return this.closestPointToPoint(e,u),e.distanceTo(u)}}();Rt.prototype.distanceToTriangle=function(){const u=new N,t=new N,e=["a","b","c"],n=new Ft,s=new Ft;return function(o,r=null,a=null){const c=r||a?n:null;if(this.intersectsTriangle(o,c))return(r||a)&&(r&&c.getCenter(r),a&&c.getCenter(a)),0;let l=1/0;for(let d=0;d<3;d++){let h;const f=e[d],p=o[f];this.closestPointToPoint(p,u),h=p.distanceToSquared(u),h<l&&(l=h,r&&r.copy(u),a&&a.copy(p));const x=this[f];o.closestPointToPoint(x,u),h=x.distanceToSquared(u),h<l&&(l=h,r&&r.copy(x),a&&a.copy(u))}for(let d=0;d<3;d++){const h=e[d],f=e[(d+1)%3];n.set(this[h],this[f]);for(let p=0;p<3;p++){const x=e[p],g=e[(p+1)%3];s.set(o[x],o[g]),mo(n,s,u,t);const y=u.distanceToSquared(t);y<l&&(l=y,r&&r.copy(u),a&&a.copy(t))}}return Math.sqrt(l)}}();class ut{constructor(t,e,n){this.isOrientedBox=!0,this.min=new N,this.max=new N,this.matrix=new ee,this.invMatrix=new ee,this.points=new Array(8).fill().map(()=>new N),this.satAxes=new Array(3).fill().map(()=>new N),this.satBounds=new Array(3).fill().map(()=>new de),this.alignedSatBounds=new Array(3).fill().map(()=>new de),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}ut.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let c=0;c<=1;c++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const h=1*c|2*l|4*d,f=s[h];f.x=c?n.x:e.x,f.y=l?n.y:e.y,f.z=d?n.z:e.z,f.applyMatrix4(t)}const i=this.satBounds,o=this.satAxes,r=s[0];for(let c=0;c<3;c++){const l=o[c],d=i[c],h=1<<c,f=s[h];l.subVectors(r,f),d.setFromPoints(l,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();ut.prototype.intersectsBox=function(){const u=new de;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,i=this.satBounds,o=this.satAxes,r=this.alignedSatBounds;if(u.min=n.x,u.max=s.x,r[0].isSeparated(u)||(u.min=n.y,u.max=s.y,r[1].isSeparated(u))||(u.min=n.z,u.max=s.z,r[2].isSeparated(u)))return!1;for(let a=0;a<3;a++){const c=o[a],l=i[a];if(u.setFromBox(c,e),l.isSeparated(u))return!1}return!0}}();ut.prototype.intersectsTriangle=function(){const u=new Rt,t=new Array(3),e=new de,n=new de,s=new N;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(u.copy(o),u.update(),o=u);const r=this.satBounds,a=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let h=0;h<3;h++){const f=r[h],p=a[h];if(e.setFromPoints(p,t),f.isSeparated(e))return!1}const c=o.satBounds,l=o.satAxes,d=this.points;for(let h=0;h<3;h++){const f=c[h],p=l[h];if(e.setFromPoints(p,d),f.isSeparated(e))return!1}for(let h=0;h<3;h++){const f=a[h];for(let p=0;p<4;p++){const x=l[p];if(s.crossVectors(f,x),e.setFromPoints(s,t),n.setFromPoints(s,d),e.isSeparated(n))return!1}}return!0}}();ut.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();ut.prototype.distanceToPoint=function(){const u=new N;return function(e){return this.closestPointToPoint(e,u),e.distanceTo(u)}}();ut.prototype.distanceToBox=function(){const u=["x","y","z"],t=new Array(12).fill().map(()=>new Ft),e=new Array(12).fill().map(()=>new Ft),n=new N,s=new N;return function(o,r=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(s),this.closestPointToPoint(s,n),o.closestPointToPoint(n,s),a&&a.copy(n),c&&c.copy(s)),0;const l=r*r,d=o.min,h=o.max,f=this.points;let p=1/0;for(let g=0;g<8;g++){const y=f[g];s.copy(y).clamp(d,h);const m=y.distanceToSquared(s);if(m<p&&(p=m,a&&a.copy(y),c&&c.copy(s),m<l))return Math.sqrt(m)}let x=0;for(let g=0;g<3;g++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){const v=(g+1)%3,b=(g+2)%3,A=y<<v|m<<b,S=1<<g|y<<v|m<<b,T=f[A],M=f[S];t[x].set(T,M);const _=u[g],z=u[v],C=u[b],E=e[x],P=E.start,I=E.end;P[_]=d[_],P[z]=y?d[z]:h[z],P[C]=m?d[C]:h[z],I[_]=h[_],I[z]=y?d[z]:h[z],I[C]=m?d[C]:h[z],x++}for(let g=0;g<=1;g++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){s.x=g?h.x:d.x,s.y=y?h.y:d.y,s.z=m?h.z:d.z,this.closestPointToPoint(s,n);const v=s.distanceToSquared(n);if(v<p&&(p=v,a&&a.copy(n),c&&c.copy(s),v<l))return Math.sqrt(v)}for(let g=0;g<12;g++){const y=t[g];for(let m=0;m<12;m++){const v=e[m];mo(y,v,n,s);const b=n.distanceToSquared(s);if(b<p&&(p=b,a&&a.copy(n),c&&c.copy(s),b<l))return Math.sqrt(b)}}return Math.sqrt(p)}}();class yo{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class bl extends yo{constructor(){super(()=>new Rt)}}const Nt=new bl;class Al{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const Y=new Al;let Ce,ln;const Ze=[],ys=new yo(()=>new Ut);function Sl(u,t,e,n,s,i){Ce=ys.getPrimitive(),ln=ys.getPrimitive(),Ze.push(Ce,ln),Y.setBuffer(u._roots[t]);const o=so(0,u.geometry,e,n,s,i);Y.clearBuffer(),ys.releasePrimitive(Ce),ys.releasePrimitive(ln),Ze.pop(),Ze.pop();const r=Ze.length;return r>0&&(ln=Ze[r-1],Ce=Ze[r-2]),o}function so(u,t,e,n,s=null,i=0,o=0){const{float32Array:r,uint16Array:a,uint32Array:c}=Y;let l=u*2;if(mt(l,a)){const h=xt(u,c),f=zt(l,a);return K(u,r,Ce),n(h,f,!1,o,i+u,Ce)}else{let _=function(C){const{uint16Array:E,uint32Array:P}=Y;let I=C*2;for(;!mt(I,E);)C=It(C),I=C*2;return xt(C,P)},z=function(C){const{uint16Array:E,uint32Array:P}=Y;let I=C*2;for(;!mt(I,E);)C=Lt(C,P),I=C*2;return xt(C,P)+zt(I,E)};const h=It(u),f=Lt(u,c);let p=h,x=f,g,y,m,v;if(s&&(m=Ce,v=ln,K(p,r,m),K(x,r,v),g=s(m),y=s(v),y<g)){p=f,x=h;const C=g;g=y,y=C,m=v}m||(m=Ce,K(p,r,m));const b=mt(p*2,a),A=e(m,b,g,o+1,i+p);let S;if(A===ir){const C=_(p),P=z(p)-C;S=n(C,P,!0,o+1,i+p,m)}else S=A&&so(p,t,e,n,s,i,o+1);if(S)return!0;v=ln,K(x,r,v);const T=mt(x*2,a),M=e(v,T,y,o+1,i+x);let B;if(M===ir){const C=_(x),P=z(x)-C;B=n(C,P,!0,o+1,i+x,v)}else B=M&&so(x,t,e,n,s,i,o+1);return!!B}}const In=new N,Pi=new N;function Tl(u,t,e={},n=0,s=1/0){const i=n*n,o=s*s;let r=1/0,a=null;if(u.shapecast({boundsTraverseOrder:l=>(In.copy(t).clamp(l.min,l.max),In.distanceToSquared(t)),intersectsBounds:(l,d,h)=>h<r&&h<o,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,In);const h=t.distanceToSquared(In);return h<r&&(Pi.copy(In),r=h,a=d),h<i}}),r===1/0)return null;const c=Math.sqrt(r);return e.point?e.point.copy(Pi):e.point=Pi.clone(),e.distance=c,e.faceIndex=a,e}const Ke=new N,Je=new N,Qe=new N,ws=new We,gs=new We,xs=new We,lr=new N,ur=new N,hr=new N,vs=new N;function El(u,t,e,n,s,i){let o;return i===Vc?o=u.intersectTriangle(n,e,t,!0,s):o=u.intersectTriangle(t,e,n,i!==po,s),o===null?null:{distance:u.origin.distanceTo(s),point:s.clone()}}function Ml(u,t,e,n,s,i,o,r,a){Ke.fromBufferAttribute(t,i),Je.fromBufferAttribute(t,o),Qe.fromBufferAttribute(t,r);const c=El(u,Ke,Je,Qe,vs,a);if(c){n&&(ws.fromBufferAttribute(n,i),gs.fromBufferAttribute(n,o),xs.fromBufferAttribute(n,r),c.uv=gt.getInterpolation(vs,Ke,Je,Qe,ws,gs,xs,new We)),s&&(ws.fromBufferAttribute(s,i),gs.fromBufferAttribute(s,o),xs.fromBufferAttribute(s,r),c.uv1=gt.getInterpolation(vs,Ke,Je,Qe,ws,gs,xs,new We)),e&&(lr.fromBufferAttribute(e,i),ur.fromBufferAttribute(e,o),hr.fromBufferAttribute(e,r),c.normal=gt.getInterpolation(vs,Ke,Je,Qe,lr,ur,hr,new N),c.normal.dot(u.direction)>0&&c.normal.multiplyScalar(-1));const l={a:i,b:o,c:r,normal:new N,materialIndex:0};gt.getNormal(Ke,Je,Qe,l.normal),c.face=l,c.faceIndex=i}return c}function ri(u,t,e,n,s){const i=n*3;let o=i+0,r=i+1,a=i+2;const c=u.index;u.index&&(o=c.getX(o),r=c.getX(r),a=c.getX(a));const{position:l,normal:d,uv:h,uv1:f}=u.attributes,p=Ml(e,l,d,h,f,o,r,a,t);return p?(p.faceIndex=n,s&&s.push(p),p):null}function et(u,t,e,n){const s=u.a,i=u.b,o=u.c;let r=t,a=t+1,c=t+2;e&&(r=e.getX(r),a=e.getX(a),c=e.getX(c)),s.x=n.getX(r),s.y=n.getY(r),s.z=n.getZ(r),i.x=n.getX(a),i.y=n.getY(a),i.z=n.getZ(a),o.x=n.getX(c),o.y=n.getY(c),o.z=n.getZ(c)}function Bl(u,t,e,n,s,i){const{geometry:o,_indirectBuffer:r}=u;for(let a=n,c=n+s;a<c;a++)ri(o,t,e,a,i)}function _l(u,t,e,n,s){const{geometry:i,_indirectBuffer:o}=u;let r=1/0,a=null;for(let c=n,l=n+s;c<l;c++){let d;d=ri(i,t,e,c),d&&d.distance<r&&(a=d,r=d.distance)}return a}function Cl(u,t,e,n,s,i,o){const{geometry:r}=e,{index:a}=r,c=r.attributes.position;for(let l=u,d=t+u;l<d;l++){let h;if(h=l,et(o,h*3,a,c),o.needsUpdate=!0,n(o,h,s,i))return!0}return!1}function Pl(u,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=u.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let i,o,r,a,c=0;const l=u._roots;for(let h=0,f=l.length;h<f;h++)i=l[h],o=new Uint32Array(i),r=new Uint16Array(i),a=new Float32Array(i),d(0,c),c+=i.byteLength;function d(h,f,p=!1){const x=h*2;if(r[x+15]===oi){const y=o[h+6],m=r[x+14];let v=1/0,b=1/0,A=1/0,S=-1/0,T=-1/0,M=-1/0;for(let B=3*y,_=3*(y+m);B<_;B++){let z=n[B];const C=s.getX(z),E=s.getY(z),P=s.getZ(z);C<v&&(v=C),C>S&&(S=C),E<b&&(b=E),E>T&&(T=E),P<A&&(A=P),P>M&&(M=P)}return a[h+0]!==v||a[h+1]!==b||a[h+2]!==A||a[h+3]!==S||a[h+4]!==T||a[h+5]!==M?(a[h+0]=v,a[h+1]=b,a[h+2]=A,a[h+3]=S,a[h+4]=T,a[h+5]=M,!0):!1}else{const y=h+8,m=o[h+6],v=y+f,b=m+f;let A=p,S=!1,T=!1;t?A||(S=t.has(v),T=t.has(b),A=!S&&!T):(S=!0,T=!0);const M=A||S,B=A||T;let _=!1;M&&(_=d(y,f,A));let z=!1;B&&(z=d(m,f,A));const C=_||z;if(C)for(let E=0;E<3;E++){const P=y+E,I=m+E,L=a[P],j=a[P+3],V=a[I],k=a[I+3];a[h+E]=L<V?L:V,a[h+E+3]=j>k?j:k}return C}}}const dr=new Ut;function ze(u,t,e,n){return K(u,t,dr),e.intersectBox(dr,n)}function zl(u,t,e,n,s,i){const{geometry:o,_indirectBuffer:r}=u;for(let a=n,c=n+s;a<c;a++){let l=r?r[a]:a;ri(o,t,e,l,i)}}function Il(u,t,e,n,s){const{geometry:i,_indirectBuffer:o}=u;let r=1/0,a=null;for(let c=n,l=n+s;c<l;c++){let d;d=ri(i,t,e,o?o[c]:c),d&&d.distance<r&&(a=d,r=d.distance)}return a}function Ll(u,t,e,n,s,i,o){const{geometry:r}=e,{index:a}=r,c=r.attributes.position;for(let l=u,d=t+u;l<d;l++){let h;if(h=e.resolveTriangleIndex(l),et(o,h*3,a,c),o.needsUpdate=!0,n(o,h,s,i))return!0}return!1}const fr=new N;function Nl(u,t,e,n,s){Y.setBuffer(u._roots[t]),io(0,u,e,n,s),Y.clearBuffer()}function io(u,t,e,n,s){const{float32Array:i,uint16Array:o,uint32Array:r}=Y,a=u*2;if(mt(a,o)){const l=xt(u,r),d=zt(a,o);Bl(t,e,n,l,d,s)}else{const l=It(u);ze(l,i,n,fr)&&io(l,t,e,n,s);const d=Lt(u,r);ze(d,i,n,fr)&&io(d,t,e,n,s)}}const pr=new N,Fl=["x","y","z"];function Rl(u,t,e,n){Y.setBuffer(u._roots[t]);const s=oo(0,u,e,n);return Y.clearBuffer(),s}function oo(u,t,e,n){const{float32Array:s,uint16Array:i,uint32Array:o}=Y;let r=u*2;if(mt(r,i)){const c=xt(u,o),l=zt(r,i);return _l(t,e,n,c,l)}else{const c=ma(u,o),l=Fl[c],h=n.direction[l]>=0;let f,p;h?(f=It(u),p=Lt(u,o)):(f=Lt(u,o),p=It(u));const g=ze(f,s,n,pr)?oo(f,t,e,n):null;if(g){const v=g.point[l];if(h?v<=s[p+c]:v>=s[p+c+3])return g}const m=ze(p,s,n,pr)?oo(p,t,e,n):null;return g&&m?g.distance<=m.distance?g:m:g||m||null}}const bs=new Ut,tn=new Rt,en=new Rt,Ln=new ee,mr=new ut,As=new ut;function Vl(u,t,e,n){Y.setBuffer(u._roots[t]);const s=ro(0,u,e,n);return Y.clearBuffer(),s}function ro(u,t,e,n,s=null){const{float32Array:i,uint16Array:o,uint32Array:r}=Y;let a=u*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),mr.set(e.boundingBox.min,e.boundingBox.max,n),s=mr),mt(a,o)){const l=t.geometry,d=l.index,h=l.attributes.position,f=e.index,p=e.attributes.position,x=xt(u,r),g=zt(a,o);if(Ln.copy(n).invert(),e.boundsTree)return K(u,i,As),As.matrix.copy(Ln),As.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>As.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let v=x*3,b=(g+x)*3;v<b;v+=3)if(et(en,v,d,h),en.needsUpdate=!0,m.intersectsTriangle(en))return!0;return!1}});for(let y=x*3,m=(g+x)*3;y<m;y+=3){et(tn,y,d,h),tn.a.applyMatrix4(Ln),tn.b.applyMatrix4(Ln),tn.c.applyMatrix4(Ln),tn.needsUpdate=!0;for(let v=0,b=f.count;v<b;v+=3)if(et(en,v,f,p),en.needsUpdate=!0,tn.intersectsTriangle(en))return!0}}else{const l=u+8,d=r[u+6];return K(l,i,bs),!!(s.intersectsBox(bs)&&ro(l,t,e,n,s)||(K(d,i,bs),s.intersectsBox(bs)&&ro(d,t,e,n,s)))}}const Ss=new ee,zi=new ut,Nn=new ut,ql=new N,kl=new N,jl=new N,Ol=new N;function Wl(u,t,e,n={},s={},i=0,o=1/0){t.boundingBox||t.computeBoundingBox(),zi.set(t.boundingBox.min,t.boundingBox.max,e),zi.needsUpdate=!0;const r=u.geometry,a=r.attributes.position,c=r.index,l=t.attributes.position,d=t.index,h=Nt.getPrimitive(),f=Nt.getPrimitive();let p=ql,x=kl,g=null,y=null;s&&(g=jl,y=Ol);let m=1/0,v=null,b=null;return Ss.copy(e).invert(),Nn.matrix.copy(Ss),u.shapecast({boundsTraverseOrder:A=>zi.distanceToBox(A),intersectsBounds:(A,S,T)=>T<m&&T<o?(S&&(Nn.min.copy(A.min),Nn.max.copy(A.max),Nn.needsUpdate=!0),!0):!1,intersectsRange:(A,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>Nn.distanceToBox(M),intersectsBounds:(M,B,_)=>_<m&&_<o,intersectsRange:(M,B)=>{for(let _=M,z=M+B;_<z;_++){et(f,3*_,d,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let C=A,E=A+S;C<E;C++){et(h,3*C,c,a),h.needsUpdate=!0;const P=h.distanceToTriangle(f,p,g);if(P<m&&(x.copy(p),y&&y.copy(g),m=P,v=C,b=_),P<i)return!0}}}});{const T=En(t);for(let M=0,B=T;M<B;M++){et(f,3*M,d,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let _=A,z=A+S;_<z;_++){et(h,3*_,c,a),h.needsUpdate=!0;const C=h.distanceToTriangle(f,p,g);if(C<m&&(x.copy(p),y&&y.copy(g),m=C,v=_,b=M),C<i)return!0}}}}}),Nt.releasePrimitive(h),Nt.releasePrimitive(f),m===1/0?null:(n.point?n.point.copy(x):n.point=x.clone(),n.distance=m,n.faceIndex=v,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(Ss),x.applyMatrix4(Ss),s.distance=x.sub(s.point).length(),s.faceIndex=b),n)}function Gl(u,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=u.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let i,o,r,a,c=0;const l=u._roots;for(let h=0,f=l.length;h<f;h++)i=l[h],o=new Uint32Array(i),r=new Uint16Array(i),a=new Float32Array(i),d(0,c),c+=i.byteLength;function d(h,f,p=!1){const x=h*2;if(r[x+15]===oi){const y=o[h+6],m=r[x+14];let v=1/0,b=1/0,A=1/0,S=-1/0,T=-1/0,M=-1/0;for(let B=y,_=y+m;B<_;B++){const z=3*u.resolveTriangleIndex(B);for(let C=0;C<3;C++){let E=z+C;E=n?n[E]:E;const P=s.getX(E),I=s.getY(E),L=s.getZ(E);P<v&&(v=P),P>S&&(S=P),I<b&&(b=I),I>T&&(T=I),L<A&&(A=L),L>M&&(M=L)}}return a[h+0]!==v||a[h+1]!==b||a[h+2]!==A||a[h+3]!==S||a[h+4]!==T||a[h+5]!==M?(a[h+0]=v,a[h+1]=b,a[h+2]=A,a[h+3]=S,a[h+4]=T,a[h+5]=M,!0):!1}else{const y=h+8,m=o[h+6],v=y+f,b=m+f;let A=p,S=!1,T=!1;t?A||(S=t.has(v),T=t.has(b),A=!S&&!T):(S=!0,T=!0);const M=A||S,B=A||T;let _=!1;M&&(_=d(y,f,A));let z=!1;B&&(z=d(m,f,A));const C=_||z;if(C)for(let E=0;E<3;E++){const P=y+E,I=m+E,L=a[P],j=a[P+3],V=a[I],k=a[I+3];a[h+E]=L<V?L:V,a[h+E+3]=j>k?j:k}return C}}}const yr=new N;function Dl(u,t,e,n,s){Y.setBuffer(u._roots[t]),ao(0,u,e,n,s),Y.clearBuffer()}function ao(u,t,e,n,s){const{float32Array:i,uint16Array:o,uint32Array:r}=Y,a=u*2;if(mt(a,o)){const l=xt(u,r),d=zt(a,o);zl(t,e,n,l,d,s)}else{const l=It(u);ze(l,i,n,yr)&&ao(l,t,e,n,s);const d=Lt(u,r);ze(d,i,n,yr)&&ao(d,t,e,n,s)}}const wr=new N,Hl=["x","y","z"];function $l(u,t,e,n){Y.setBuffer(u._roots[t]);const s=co(0,u,e,n);return Y.clearBuffer(),s}function co(u,t,e,n){const{float32Array:s,uint16Array:i,uint32Array:o}=Y;let r=u*2;if(mt(r,i)){const c=xt(u,o),l=zt(r,i);return Il(t,e,n,c,l)}else{const c=ma(u,o),l=Hl[c],h=n.direction[l]>=0;let f,p;h?(f=It(u),p=Lt(u,o)):(f=Lt(u,o),p=It(u));const g=ze(f,s,n,wr)?co(f,t,e,n):null;if(g){const v=g.point[l];if(h?v<=s[p+c]:v>=s[p+c+3])return g}const m=ze(p,s,n,wr)?co(p,t,e,n):null;return g&&m?g.distance<=m.distance?g:m:g||m||null}}const Ts=new Ut,nn=new Rt,sn=new Rt,Fn=new ee,gr=new ut,Es=new ut;function Ul(u,t,e,n){Y.setBuffer(u._roots[t]);const s=lo(0,u,e,n);return Y.clearBuffer(),s}function lo(u,t,e,n,s=null){const{float32Array:i,uint16Array:o,uint32Array:r}=Y;let a=u*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),gr.set(e.boundingBox.min,e.boundingBox.max,n),s=gr),mt(a,o)){const l=t.geometry,d=l.index,h=l.attributes.position,f=e.index,p=e.attributes.position,x=xt(u,r),g=zt(a,o);if(Fn.copy(n).invert(),e.boundsTree)return K(u,i,Es),Es.matrix.copy(Fn),Es.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Es.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let v=x,b=g+x;v<b;v++)if(et(sn,3*t.resolveTriangleIndex(v),d,h),sn.needsUpdate=!0,m.intersectsTriangle(sn))return!0;return!1}});for(let y=x,m=g+x;y<m;y++){const v=t.resolveTriangleIndex(y);et(nn,3*v,d,h),nn.a.applyMatrix4(Fn),nn.b.applyMatrix4(Fn),nn.c.applyMatrix4(Fn),nn.needsUpdate=!0;for(let b=0,A=f.count;b<A;b+=3)if(et(sn,b,f,p),sn.needsUpdate=!0,nn.intersectsTriangle(sn))return!0}}else{const l=u+8,d=r[u+6];return K(l,i,Ts),!!(s.intersectsBox(Ts)&&lo(l,t,e,n,s)||(K(d,i,Ts),s.intersectsBox(Ts)&&lo(d,t,e,n,s)))}}const Ms=new ee,Ii=new ut,Rn=new ut,Xl=new N,Yl=new N,Zl=new N,Kl=new N;function Jl(u,t,e,n={},s={},i=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Ii.set(t.boundingBox.min,t.boundingBox.max,e),Ii.needsUpdate=!0;const r=u.geometry,a=r.attributes.position,c=r.index,l=t.attributes.position,d=t.index,h=Nt.getPrimitive(),f=Nt.getPrimitive();let p=Xl,x=Yl,g=null,y=null;s&&(g=Zl,y=Kl);let m=1/0,v=null,b=null;return Ms.copy(e).invert(),Rn.matrix.copy(Ms),u.shapecast({boundsTraverseOrder:A=>Ii.distanceToBox(A),intersectsBounds:(A,S,T)=>T<m&&T<o?(S&&(Rn.min.copy(A.min),Rn.max.copy(A.max),Rn.needsUpdate=!0),!0):!1,intersectsRange:(A,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:M=>Rn.distanceToBox(M),intersectsBounds:(M,B,_)=>_<m&&_<o,intersectsRange:(M,B)=>{for(let _=M,z=M+B;_<z;_++){const C=T.resolveTriangleIndex(_);et(f,3*C,d,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let E=A,P=A+S;E<P;E++){const I=u.resolveTriangleIndex(E);et(h,3*I,c,a),h.needsUpdate=!0;const L=h.distanceToTriangle(f,p,g);if(L<m&&(x.copy(p),y&&y.copy(g),m=L,v=E,b=_),L<i)return!0}}}})}else{const T=En(t);for(let M=0,B=T;M<B;M++){et(f,3*M,d,l),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let _=A,z=A+S;_<z;_++){const C=u.resolveTriangleIndex(_);et(h,3*C,c,a),h.needsUpdate=!0;const E=h.distanceToTriangle(f,p,g);if(E<m&&(x.copy(p),y&&y.copy(g),m=E,v=_,b=M),E<i)return!0}}}}}),Nt.releasePrimitive(h),Nt.releasePrimitive(f),m===1/0?null:(n.point?n.point.copy(x):n.point=x.clone(),n.distance=m,n.faceIndex=v,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(Ms),x.applyMatrix4(Ms),s.distance=x.sub(s.point).length(),s.faceIndex=b),n)}function Ql(){return typeof SharedArrayBuffer<"u"}const Dn=new Y.constructor,Hs=new Y.constructor,Be=new yo(()=>new Ut),on=new Ut,rn=new Ut,Li=new Ut,Ni=new Ut;let Fi=!1;function tu(u,t,e,n){if(Fi)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Fi=!0;const s=u._roots,i=t._roots;let o,r=0,a=0;const c=new ee().copy(e).invert();for(let l=0,d=s.length;l<d;l++){Dn.setBuffer(s[l]),a=0;const h=Be.getPrimitive();K(0,Dn.float32Array,h),h.applyMatrix4(c);for(let f=0,p=i.length;f<p&&(Hs.setBuffer(i[l]),o=Wt(0,0,e,c,n,r,a,0,0,h),Hs.clearBuffer(),a+=i[f].length,!o);f++);if(Be.releasePrimitive(h),Dn.clearBuffer(),r+=s[l].length,o)break}return Fi=!1,o}function Wt(u,t,e,n,s,i=0,o=0,r=0,a=0,c=null,l=!1){let d,h;l?(d=Hs,h=Dn):(d=Dn,h=Hs);const f=d.float32Array,p=d.uint32Array,x=d.uint16Array,g=h.float32Array,y=h.uint32Array,m=h.uint16Array,v=u*2,b=t*2,A=mt(v,x),S=mt(b,m);let T=!1;if(S&&A)l?T=s(xt(t,y),zt(t*2,m),xt(u,p),zt(u*2,x),a,o+t,r,i+u):T=s(xt(u,p),zt(u*2,x),xt(t,y),zt(t*2,m),r,i+u,a,o+t);else if(S){const M=Be.getPrimitive();K(t,g,M),M.applyMatrix4(e);const B=It(u),_=Lt(u,p);K(B,f,on),K(_,f,rn);const z=M.intersectsBox(on),C=M.intersectsBox(rn);T=z&&Wt(t,B,n,e,s,o,i,a,r+1,M,!l)||C&&Wt(t,_,n,e,s,o,i,a,r+1,M,!l),Be.releasePrimitive(M)}else{const M=It(t),B=Lt(t,y);K(M,g,Li),K(B,g,Ni);const _=c.intersectsBox(Li),z=c.intersectsBox(Ni);if(_&&z)T=Wt(u,M,e,n,s,i,o,r,a+1,c,l)||Wt(u,B,e,n,s,i,o,r,a+1,c,l);else if(_)if(A)T=Wt(u,M,e,n,s,i,o,r,a+1,c,l);else{const C=Be.getPrimitive();C.copy(Li).applyMatrix4(e);const E=It(u),P=Lt(u,p);K(E,f,on),K(P,f,rn);const I=C.intersectsBox(on),L=C.intersectsBox(rn);T=I&&Wt(M,E,n,e,s,o,i,a,r+1,C,!l)||L&&Wt(M,P,n,e,s,o,i,a,r+1,C,!l),Be.releasePrimitive(C)}else if(z)if(A)T=Wt(u,B,e,n,s,i,o,r,a+1,c,l);else{const C=Be.getPrimitive();C.copy(Ni).applyMatrix4(e);const E=It(u),P=Lt(u,p);K(E,f,on),K(P,f,rn);const I=C.intersectsBox(on),L=C.intersectsBox(rn);T=I&&Wt(B,E,n,e,s,o,i,a,r+1,C,!l)||L&&Wt(B,P,n,e,s,o,i,a,r+1,C,!l),Be.releasePrimitive(C)}}return T}const Bs=new ut,xr=new Ut,eu={strategy:da,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class wo{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,i=t._indirectBuffer,o=n.getIndex();let r;return e.cloneBuffers?r={roots:s.map(a=>a.slice()),index:o.array.slice(),indirectBuffer:i?i.slice():null}:r={roots:s,index:o.array,indirectBuffer:i},r}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:s,roots:i,indirectBuffer:o}=t,r=new wo(e,{...n,[Mi]:!0});if(r._roots=i,r._indirectBuffer=o||null,n.setIndex){const a=e.getIndex();if(a===null){const c=new ni(t.index,1,!1);e.setIndex(c)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...eu,[Mi]:!1},e),e.useSharedArrayBuffer&&!Ql())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Mi]||(wl(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Ut)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?s=>n[s]:s=>s}refit(t=null){return(this.indirect?Gl:Pl)(this,t)}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),i=new Uint16Array(n);o(0);function o(r,a=0){const c=r*2,l=i[c+15]===oi;if(l){const d=s[r+6],h=i[c+14];t(a,l,new Float32Array(n,r*4,6),d,h)}else{const d=r+Gn/4,h=s[r+6],f=s[r+7];t(a,l,new Float32Array(n,r*4,6),f)||(o(d,a+1),o(h,a+1))}}}raycast(t,e=Jo){const n=this._roots,s=this.geometry,i=[],o=e.isMaterial,r=Array.isArray(e),a=s.groups,c=o?e.side:e,l=this.indirect?Dl:Nl;for(let d=0,h=n.length;d<h;d++){const f=r?e[a[d].materialIndex].side:c,p=i.length;if(l(this,d,f,t,i),r){const x=a[d].materialIndex;for(let g=p,y=i.length;g<y;g++)i[g].face.materialIndex=x}}return i}raycastFirst(t,e=Jo){const n=this._roots,s=this.geometry,i=e.isMaterial,o=Array.isArray(e);let r=null;const a=s.groups,c=i?e.side:e,l=this.indirect?$l:Rl;for(let d=0,h=n.length;d<h;d++){const f=o?e[a[d].materialIndex].side:c,p=l(this,d,f,t);p!=null&&(r==null||p.distance<r.distance)&&(r=p,o&&(p.face.materialIndex=a[d].materialIndex))}return r}intersectsGeometry(t,e){let n=!1;const s=this._roots,i=this.indirect?Ul:Vl;for(let o=0,r=s.length;o<r&&(n=i(this,o,t,e),!n);o++);return n}shapecast(t){const e=Nt.getPrimitive(),n=this.indirect?Ll:Cl;let{boundsTraverseOrder:s,intersectsBounds:i,intersectsRange:o,intersectsTriangle:r}=t;if(o&&r){const d=o;o=(h,f,p,x,g)=>d(h,f,p,x,g)?!0:n(h,f,this,r,p,x,e)}else o||(r?o=(d,h,f,p)=>n(d,h,this,r,f,p,e):o=(d,h,f)=>f);let a=!1,c=0;const l=this._roots;for(let d=0,h=l.length;d<h;d++){const f=l[d];if(a=Sl(this,d,i,o,s,c),a)break;c+=f.byteLength}return Nt.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:i}=n;const o=Nt.getPrimitive(),r=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?p=>{const x=this.resolveTriangleIndex(p);et(o,x*3,r,a)}:p=>{et(o,p*3,r,a)},l=Nt.getPrimitive(),d=t.geometry.index,h=t.geometry.attributes.position,f=t.indirect?p=>{const x=t.resolveTriangleIndex(p);et(l,x*3,d,h)}:p=>{et(l,p*3,d,h)};if(i){const p=(x,g,y,m,v,b,A,S)=>{for(let T=y,M=y+m;T<M;T++){f(T),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let B=x,_=x+g;B<_;B++)if(c(B),o.needsUpdate=!0,i(o,l,B,T,v,b,A,S))return!0}return!1};if(s){const x=s;s=function(g,y,m,v,b,A,S,T){return x(g,y,m,v,b,A,S,T)?!0:p(g,y,m,v,b,A,S,T)}}else s=p}return tu(this,t,e,s)}intersectsBox(t,e){return Bs.set(t.min,t.max,e),Bs.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Bs.intersectsBox(n),intersectsTriangle:n=>Bs.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},i=0,o=1/0){return(this.indirect?Jl:Wl)(this,t,e,n,s,i,o)}closestPointToPoint(t,e={},n=0,s=1/0){return Tl(this,t,e,n,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{K(0,new Float32Array(n),xr),t.union(xr)}),t}}const ga=1e-6,nu=ga*.5,xa=Math.pow(10,-Math.log10(ga)),su=nu*xa;function te(u){return~~(u*xa+su)}function iu(u){return`${te(u.x)},${te(u.y)}`}function vr(u){return`${te(u.x)},${te(u.y)},${te(u.z)}`}function ou(u){return`${te(u.x)},${te(u.y)},${te(u.z)},${te(u.w)}`}function ru(u,t,e){e.direction.subVectors(t,u).normalize();const n=u.dot(e.direction);return e.origin.copy(u).addScaledVector(e.direction,-n),e}function va(){return typeof SharedArrayBuffer<"u"}function au(u){if(u.buffer instanceof SharedArrayBuffer)return u;const t=u.constructor,e=u.buffer,n=new SharedArrayBuffer(e.byteLength),s=new Uint8Array(e);return new Uint8Array(n).set(s,0),new t(n)}function cu(u,t=ArrayBuffer){return u>65535?new Uint32Array(new t(4*u)):new Uint16Array(new t(2*u))}function lu(u,t){if(!u.index){const e=u.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=cu(e,n);u.setIndex(new ni(s,1));for(let i=0;i<e;i++)s[i]=i}}function uu(u){return u.index?u.index.count:u.attributes.position.count}function go(u){return uu(u)/3}const hu=1e-8,du=new N;function fu(u){return~~(u/3)}function pu(u){return u%3}function br(u,t){return u.start-t.start}function Ar(u,t){return du.subVectors(t,u.origin).dot(u.direction)}function mu(u,t,e,n=hu){u.sort(br),t.sort(br);for(let r=0;r<u.length;r++){const a=u[r];for(let c=0;c<t.length;c++){const l=t[c];if(!(l.start>a.end)){if(a.end<l.start||l.end<a.start)continue;if(a.start<=l.start&&a.end>=l.end)i(l.end,a.end)||u.splice(r+1,0,{start:l.end,end:a.end,index:a.index}),a.end=l.start,l.start=0,l.end=0;else if(a.start>=l.start&&a.end<=l.end)i(a.end,l.end)||t.splice(c+1,0,{start:a.end,end:l.end,index:l.index}),l.end=a.start,a.start=0,a.end=0;else if(a.start<=l.start&&a.end<=l.end){const d=a.end;a.end=l.start,l.start=d}else if(a.start>=l.start&&a.end>=l.end){const d=l.end;l.end=a.start,a.start=d}else throw new Error}if(e.has(a.index)||e.set(a.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(a.index).push(l.index),e.get(l.index).push(a.index),o(l)&&(t.splice(c,1),c--),o(a)){u.splice(r,1),r--;break}}}s(u),s(t);function s(r){for(let a=0;a<r.length;a++)o(r[a])&&(r.splice(a,1),a--)}function i(r,a){return Math.abs(a-r)<n}function o(r){return Math.abs(r.end-r.start)<n}}const Sr=1e-5,Tr=1e-4;class yu{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let s=1/0,i=null;for(let a=0,c=e.length;a<c;a++){const l=e[a];if(o(l,t)&&o(l,n))continue;const d=r(l,t),h=r(l,n),f=Math.min(d,h);f<s&&(s=f,i=l)}return i;function o(a,c){const l=a.origin.distanceTo(c.origin)>Sr;return a.direction.angleTo(c.direction)>Tr||l}function r(a,c){const l=a.origin.distanceTo(c.origin),d=a.direction.angleTo(c.direction);return l/Sr+d/Tr}}}const Ri=new N,Vi=new N,_s=new la;function wu(u,t,e){const n=u.attributes,s=u.index,i=n.position,o=new Map,r=new Map,a=Array.from(t),c=new yu;for(let l=0,d=a.length;l<d;l++){const h=a[l],f=fu(h),p=pu(h);let x=3*f+p,g=3*f+(p+1)%3;s&&(x=s.getX(x),g=s.getX(g)),Ri.fromBufferAttribute(i,x),Vi.fromBufferAttribute(i,g),ru(Ri,Vi,_s);let y,m=c.findClosestRay(_s);m===null&&(m=_s.clone(),c.addRay(m)),r.has(m)||r.set(m,{forward:[],reverse:[],ray:m}),y=r.get(m);let v=Ar(m,Ri),b=Ar(m,Vi);v>b&&([v,b]=[b,v]),_s.direction.dot(m.direction)<0?y.reverse.push({start:v,end:b,index:h}):y.forward.push({start:v,end:b,index:h})}return r.forEach(({forward:l,reverse:d},h)=>{mu(l,d,o,e),l.length===0&&d.length===0&&r.delete(h)}),{disjointConnectivityMap:o,fragmentMap:r}}const gu=new We,qi=new N,xu=new Ge,ki=["","",""];class vu{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(i=>~~(i/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(i=>i%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:s,degenerateEpsilon:i}=this,o=e?v:m,r=new Map,{attributes:a}=t,c=e?Object.keys(a):null,l=t.index,d=a.position;let h=go(t);const f=h;let p=0;n&&(p=t.drawRange.start,t.drawRange.count!==1/0&&(h=~~(t.drawRange.count/3)));let x=this.data;(!x||x.length<3*f)&&(x=new Int32Array(3*f)),x.fill(-1);let g=0,y=new Set;for(let b=p,A=h*3+p;b<A;b+=3){const S=b;for(let T=0;T<3;T++){let M=S+T;l&&(M=l.getX(M)),ki[T]=o(M)}for(let T=0;T<3;T++){const M=(T+1)%3,B=ki[T],_=ki[M],z=`${_}_${B}`;if(r.has(z)){const C=S+T,E=r.get(z);x[C]=E,x[E]=C,r.delete(z),g+=2,y.delete(E)}else{const C=`${B}_${_}`,E=S+T;r.set(C,E),y.add(E)}}}if(s){const{fragmentMap:b,disjointConnectivityMap:A}=wu(t,y,i);y.clear(),b.forEach(({forward:S,reverse:T})=>{S.forEach(({index:M})=>y.add(M)),T.forEach(({index:M})=>y.add(M))}),this.unmatchedDisjointEdges=b,this.disjointConnections=A,g=h*3-y.size}this.matchedEdges=g,this.unmatchedEdges=y.size,this.data=x;function m(b){return qi.fromBufferAttribute(d,b),vr(qi)}function v(b){let A="";for(let S=0,T=c.length;S<T;S++){const M=a[c[S]];let B;switch(M.itemSize){case 1:B=te(M.getX(b));break;case 2:B=iu(gu.fromBufferAttribute(M,b));break;case 3:B=vr(qi.fromBufferAttribute(M,b));break;case 4:B=ou(xu.fromBufferAttribute(M,b));break}A!==""&&(A+="|"),A+=B}return A}}}class bt extends ${constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new ee,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,s=e.elements;for(let i=0;i<16;i++)if(n[i]!==s[i])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=va();if(n)for(const s in e){const i=e[s];if(i.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");i.array=au(i.array)}if(t.boundsTree||(lu(t,{useSharedArrayBuffer:n}),t.boundsTree=new wo(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new vu(t)),!t.groupIndices){const s=go(t),i=new Uint16Array(s),o=t.groups;for(let r=0,a=o.length;r<a;r++){const{start:c,count:l}=o[r];for(let d=c/3,h=(c+l)/3;d<h;d++)i[d]=r}t.groupIndices=i}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const bu=1e-14,ji=new N,Er=new N,Mr=new N;function _e(u,t=bu){ji.subVectors(u.b,u.a),Er.subVectors(u.c,u.a),Mr.subVectors(u.b,u.c);const e=ji.angleTo(Er),n=ji.angleTo(Mr),s=Math.PI-e-n;return Math.abs(e)<t||Math.abs(n)<t||Math.abs(s)<t||u.a.distanceToSquared(u.b)<t||u.a.distanceToSquared(u.c)<t||u.b.distanceToSquared(u.c)<t}const Oi=1e-10,Vn=1e-10,Au=1e-10,ie=new Ft,J=new Ft,oe=new N,Wi=new N,Br=new N,Cs=new fo,Gi=new Rt;class Su{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new gt),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class Tu{constructor(){this.trianglePool=new Su,this.triangles=[],this.normal=new N,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:s}=this;if(Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const r=t[i];if(i===0)r.getNormal(s);else if(Math.abs(1-r.getNormal(oe).dot(s))>Oi)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const a=n.getTriangle();a.copy(r),e.push(a)}else{t.getNormal(s);const i=n.getTriangle();i.copy(t),e.push(i)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(Wi).normalize(),Math.abs(1-Math.abs(Wi.dot(e)))<Au){this.coplanarTriangleUsed=!0;for(let i=0,o=n.length;i<o;i++){const r=n[i];r.coplanarCount=0}const s=[t.a,t.b,t.c];for(let i=0;i<3;i++){const o=(i+1)%3,r=s[i],a=s[o];oe.subVectors(a,r).normalize(),Br.crossVectors(Wi,oe),Cs.setFromNormalAndCoplanarPoint(Br,r),this.splitByPlane(Cs,t)}}else t.getPlane(Cs),this.splitByPlane(Cs,t)}splitByPlane(t,e){const{triangles:n,trianglePool:s}=this;Gi.copy(e),Gi.needsUpdate=!0;for(let i=0,o=n.length;i<o;i++){const r=n[i];if(!Gi.intersectsTriangle(r,ie,!0))continue;const{a,b:c,c:l}=r;let d=0,h=-1,f=!1,p=[],x=[];const g=[a,c,l];for(let y=0;y<3;y++){const m=(y+1)%3;ie.start.copy(g[y]),ie.end.copy(g[m]);const v=t.distanceToPoint(ie.start),b=t.distanceToPoint(ie.end);if(Math.abs(v)<Vn&&Math.abs(b)<Vn){f=!0;break}if(v>0?p.push(y):x.push(y),Math.abs(v)<Vn)continue;let A=!!t.intersectLine(ie,oe);!A&&Math.abs(b)<Vn&&(oe.copy(ie.end),A=!0),A&&!(oe.distanceTo(ie.start)<Oi)&&(oe.distanceTo(ie.end)<Oi&&(h=y),d===0?J.start.copy(oe):J.end.copy(oe),d++)}if(!f&&d===2&&J.distance()>Vn)if(h!==-1){h=(h+1)%3;let y=0;y===h&&(y=(y+1)%3);let m=y+1;m===h&&(m=(m+1)%3);const v=s.getTriangle();v.a.copy(g[m]),v.b.copy(J.end),v.c.copy(J.start),_e(v)||n.push(v),r.a.copy(g[y]),r.b.copy(J.start),r.c.copy(J.end),_e(r)&&(n.splice(i,1),i--,o--)}else{const y=p.length>=2?x[0]:p[0];if(y===0){let S=J.start;J.start=J.end,J.end=S}const m=(y+1)%3,v=(y+2)%3,b=s.getTriangle(),A=s.getTriangle();g[m].distanceToSquared(J.start)<g[v].distanceToSquared(J.end)?(b.a.copy(g[m]),b.b.copy(J.start),b.c.copy(J.end),A.a.copy(g[m]),A.b.copy(g[v]),A.c.copy(J.start)):(b.a.copy(g[v]),b.b.copy(J.start),b.c.copy(J.end),A.a.copy(g[m]),A.b.copy(g[v]),A.c.copy(J.end)),r.a.copy(g[y]),r.b.copy(J.end),r.c.copy(J.start),_e(b)||n.push(b),_e(A)||n.push(A),_e(r)&&(n.splice(i,1),i--,o--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function Eu(u){return u=~~u,u+4-u%4}class _r{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=va()?SharedArrayBuffer:ArrayBuffer,s=new e(new n(Eu(t*e.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let s=0,i=t.length;s<i;s++)e[n+s]=t[s];this.length+=t.length}clear(){this.length=0}}class Mu{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let s=0;for(let i=0;i<e;i++){const o=n[i];s+=o[t].length}return s}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const s={};e.push(s);for(const i in n){const o=n[i],r=new _r(o.type);r.itemSize=o.itemSize,r.normalized=o.normalized,s[i]=r}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,s){const{groupAttributes:i}=this,r=i[0][t];if(r){if(r.type!==e)for(let a=0,c=i.length;a<c;a++){const l=i[a][t];l.setType(e),l.itemSize=n,l.normalized=s}}else for(let a=0,c=i.length;a<c;a++){const l=new _r(e);l.itemSize=n,l.normalized=s,i[a][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const n in e)e[n].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Cr{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:s}=this;n[t]||(n[t]=[],s.push(t)),n[t].push(e)}}const pe=0,xo=1,Bu=2,_u=3,Cu=4,ba=5,Aa=6,Pt=new la,Pr=new ee,lt=new gt,re=new N,zr=new Ge,Ir=new Ge,Lr=new Ge,Di=new Ge,Ps=new Ge,zs=new Ge,Nr=new Ft,Hi=new N,$i=1e-8,Pu=1e-15,qe=-1,ke=1,Ws=-2,Gs=2,Hn=0,Fe=1,vo=2,zu=1e-14;let Ds=null;function Fr(u){Ds=u}function Sa(u,t){u.getMidpoint(Pt.origin),u.getNormal(Pt.direction);const e=t.raycastFirst(Pt,po);return!!(e&&Pt.direction.dot(e.face.normal)>0)?qe:ke}function Iu(u,t){function e(){return Math.random()-.5}u.getNormal(Hi),Pt.direction.copy(Hi),u.getMidpoint(Pt.origin);const n=3;let s=0,i=1/0;for(let o=0;o<n;o++){Pt.direction.x+=e()*$i,Pt.direction.y+=e()*$i,Pt.direction.z+=e()*$i,Pt.direction.multiplyScalar(-1);const r=t.raycastFirst(Pt,po);if(!!(r&&Pt.direction.dot(r.face.normal)>0)&&s++,r!==null&&(i=Math.min(i,r.distance)),i<=Pu)return r.face.normal.dot(Hi)>0?Gs:Ws;if(s/n>.5||(o-s+1)/n>.5)break}return s/n>.5?qe:ke}function Lu(u,t){const e=new Cr,n=new Cr;return Pr.copy(u.matrixWorld).invert().multiply(t.matrixWorld),u.geometry.boundsTree.bvhcast(t.geometry.boundsTree,Pr,{intersectsTriangles(s,i,o,r){if(!_e(s)&&!_e(i)){let a=s.intersectsTriangle(i,Nr,!0);if(!a){const c=s.plane,l=i.plane,d=c.normal,h=l.normal;d.dot(h)===1&&Math.abs(c.constant-l.constant)<zu&&(a=!0)}if(a){let c=u.geometry.boundsTree.resolveTriangleIndex(o),l=t.geometry.boundsTree.resolveTriangleIndex(r);e.add(c,l),n.add(l,c),Ds&&(Ds.addEdge(Nr),Ds.addIntersectingTriangles(o,s,r,i))}}return!1}}),{aIntersections:e,bIntersections:n}}function Nu(u,t,e,n,s,i,o=!1){const r=e.attributes,a=e.index,c=u*3,l=a.getX(c+0),d=a.getX(c+1),h=a.getX(c+2);for(const f in i){const p=r[f],x=i[f];if(!(f in r))throw new Error(`CSG Operations: Attribute ${f} not available on geometry.`);const g=p.itemSize;f==="position"?(lt.a.fromBufferAttribute(p,l).applyMatrix4(n),lt.b.fromBufferAttribute(p,d).applyMatrix4(n),lt.c.fromBufferAttribute(p,h).applyMatrix4(n),Ui(lt.a,lt.b,lt.c,t,3,x,o)):f==="normal"?(lt.a.fromBufferAttribute(p,l).applyNormalMatrix(s),lt.b.fromBufferAttribute(p,d).applyNormalMatrix(s),lt.c.fromBufferAttribute(p,h).applyNormalMatrix(s),o&&(lt.a.multiplyScalar(-1),lt.b.multiplyScalar(-1),lt.c.multiplyScalar(-1)),Ui(lt.a,lt.b,lt.c,t,3,x,o,!0)):(zr.fromBufferAttribute(p,l),Ir.fromBufferAttribute(p,d),Lr.fromBufferAttribute(p,h),Ui(zr,Ir,Lr,t,g,x,o))}}function Fu(u,t,e,n,s,i,o,r=!1){Xi(u,n,s,i,o,r),Xi(r?e:t,n,s,i,o,r),Xi(r?t:e,n,s,i,o,r)}function Ta(u,t,e=!1){switch(u){case pe:if(t===ke||t===Gs&&!e)return Fe;break;case xo:if(e){if(t===qe)return Hn}else if(t===ke||t===Ws)return Fe;break;case Bu:if(e){if(t===ke||t===Ws)return Fe}else if(t===qe)return Hn;break;case Cu:if(t===qe)return Hn;if(t===ke)return Fe;break;case _u:if(t===qe||t===Gs&&!e)return Fe;break;case ba:if(!e&&(t===ke||t===Ws))return Fe;break;case Aa:if(!e&&(t===qe||t===Gs))return Fe;break;default:throw new Error(`Unrecognized CSG operation enum "${u}".`)}return vo}function Ui(u,t,e,n,s,i,o=!1,r=!1){const a=c=>{i.push(c.x),s>1&&i.push(c.y),s>2&&i.push(c.z),s>3&&i.push(c.w)};Di.set(0,0,0,0).addScaledVector(u,n.a.x).addScaledVector(t,n.a.y).addScaledVector(e,n.a.z),Ps.set(0,0,0,0).addScaledVector(u,n.b.x).addScaledVector(t,n.b.y).addScaledVector(e,n.b.z),zs.set(0,0,0,0).addScaledVector(u,n.c.x).addScaledVector(t,n.c.y).addScaledVector(e,n.c.z),r&&(Di.normalize(),Ps.normalize(),zs.normalize()),a(Di),o?(a(zs),a(Ps)):(a(Ps),a(zs))}function Xi(u,t,e,n,s,i=!1){for(const o in s){const r=t[o],a=s[o];if(!(o in t))throw new Error(`CSG Operations: Attribute ${o} no available on geometry.`);const c=r.itemSize;o==="position"?(re.fromBufferAttribute(r,u).applyMatrix4(e),a.push(re.x,re.y,re.z)):o==="normal"?(re.fromBufferAttribute(r,u).applyNormalMatrix(n),i&&re.multiplyScalar(-1),a.push(re.x,re.y,re.z)):(a.push(r.getX(u)),c>1&&a.push(r.getY(u)),c>2&&a.push(r.getZ(u)),c>3&&a.push(r.getW(u)))}}class Ru{constructor(t){this.triangle=new gt().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new gt().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class Rr{constructor(){this.data={}}addTriangleIntersection(t,e,n,s){const{data:i}=this;i[t]||(i[t]=new Ru(e)),i[t].addTriangle(n,s)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const s in e)n.push(e[s].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,s=new Set,i=[],o=r=>{if(n[r])if(e!==null)n[r].intersects[e]&&i.push(n[r].intersects[e]);else{const a=n[r].intersects;for(const c in a)s.has(c)||(s.add(c),i.push(a[c]))}};if(t!==null)o(t);else for(const r in n)o(r);return i}reset(){this.data={}}}class Vu{constructor(){this.enabled=!1,this.triangleIntersectsA=new Rr,this.triangleIntersectsB=new Rr,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,s){const{triangleIntersectsA:i,triangleIntersectsB:o}=this;i.addTriangleIntersection(t,e,n,s),o.addTriangleIntersection(n,s,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Fr(this))}complete(){this.enabled&&Fr(null)}}const Pe=new ee,$s=new qc,Re=new gt,Is=new gt,Ee=new gt,Ls=new gt,Gt=[],Oe=[];function qu(u){for(const t of u)return t}function ku(u,t,e,n,s,i={}){const{useGroups:o=!0}=i,{aIntersections:r,bIntersections:a}=Lu(u,t),c=[];let l=null,d;return d=o?0:-1,Vr(u,t,r,e,!1,n,s,d),qr(u,t,r,e,!1,s,d),e.findIndex(f=>f!==Aa&&f!==ba)!==-1&&(d=o?u.geometry.groups.length||1:-1,Vr(t,u,a,e,!0,n,s,d),qr(t,u,a,e,!0,s,d)),Gt.length=0,Oe.length=0,{groups:c,materials:l}}function Vr(u,t,e,n,s,i,o,r=0){const a=u.matrixWorld.determinant()<0;Pe.copy(t.matrixWorld).invert().multiply(u.matrixWorld),$s.getNormalMatrix(u.matrixWorld).multiplyScalar(a?-1:1);const c=u.geometry.groupIndices,l=u.geometry.index,d=u.geometry.attributes.position,h=t.geometry.boundsTree,f=t.geometry.index,p=t.geometry.attributes.position,x=e.ids,g=e.intersectionSet;for(let y=0,m=x.length;y<m;y++){const v=x[y],b=r===-1?0:c[v]+r,A=3*v,S=l.getX(A+0),T=l.getX(A+1),M=l.getX(A+2);Re.a.fromBufferAttribute(d,S).applyMatrix4(Pe),Re.b.fromBufferAttribute(d,T).applyMatrix4(Pe),Re.c.fromBufferAttribute(d,M).applyMatrix4(Pe),i.reset(),i.initialize(Re);const B=g[v];for(let z=0,C=B.length;z<C;z++){const E=3*B[z],P=f.getX(E+0),I=f.getX(E+1),L=f.getX(E+2);Is.a.fromBufferAttribute(p,P),Is.b.fromBufferAttribute(p,I),Is.c.fromBufferAttribute(p,L),i.splitByTriangle(Is)}const _=i.triangles;for(let z=0,C=_.length;z<C;z++){const E=_[z],P=i.coplanarTriangleUsed?Iu(E,h):Sa(E,h);Gt.length=0,Oe.length=0;for(let I=0,L=n.length;I<L;I++){const j=Ta(n[I],P,s);j!==vo&&(Oe.push(j),Gt.push(o[I].getGroupAttrSet(b)))}if(Gt.length!==0){Re.getBarycoord(E.a,Ls.a),Re.getBarycoord(E.b,Ls.b),Re.getBarycoord(E.c,Ls.c);for(let I=0,L=Gt.length;I<L;I++){const j=Gt[I],k=Oe[I]===Hn;Nu(v,Ls,u.geometry,u.matrixWorld,$s,j,a!==k)}}}}return x.length}function qr(u,t,e,n,s,i,o=0){const r=u.matrixWorld.determinant()<0;Pe.copy(t.matrixWorld).invert().multiply(u.matrixWorld),$s.getNormalMatrix(u.matrixWorld).multiplyScalar(r?-1:1);const a=t.geometry.boundsTree,c=u.geometry.groupIndices,l=u.geometry.index,d=u.geometry.attributes,h=d.position,f=[],p=u.geometry.halfEdges,x=new Set,g=go(u.geometry);for(let y=0,m=g;y<m;y++)y in e.intersectionSet||x.add(y);for(;x.size>0;){const y=qu(x);x.delete(y),f.push(y);const m=3*y,v=l.getX(m+0),b=l.getX(m+1),A=l.getX(m+2);Ee.a.fromBufferAttribute(h,v).applyMatrix4(Pe),Ee.b.fromBufferAttribute(h,b).applyMatrix4(Pe),Ee.c.fromBufferAttribute(h,A).applyMatrix4(Pe);const S=Sa(Ee,a);Oe.length=0,Gt.length=0;for(let T=0,M=n.length;T<M;T++){const B=Ta(n[T],S,s);B!==vo&&(Oe.push(B),Gt.push(i[T]))}for(;f.length>0;){const T=f.pop();for(let M=0;M<3;M++){const B=p.getSiblingTriangleIndex(T,M);B!==-1&&x.has(B)&&(f.push(B),x.delete(B))}if(Gt.length!==0){const M=3*T,B=l.getX(M+0),_=l.getX(M+1),z=l.getX(M+2),C=o===-1?0:c[T]+o;if(Ee.a.fromBufferAttribute(h,B),Ee.b.fromBufferAttribute(h,_),Ee.c.fromBufferAttribute(h,z),!_e(Ee))for(let E=0,P=Gt.length;E<P;E++){const I=Oe[E],L=Gt[E].getGroupAttrSet(C),j=I===Hn;Fu(B,_,z,d,u.matrixWorld,$s,L,j!==r)}}}}}function ju(u){for(let t=0;t<u.length-1;t++){const e=u[t],n=u[t+1];if(e.materialIndex===n.materialIndex){const s=e.start,i=n.start+n.count;n.start=s,n.count=i-s,u.splice(t,1),t--}}}function Ou(u,t,e,n){e.clear();const s=u.attributes;for(let i=0,o=n.length;i<o;i++){const r=n[i],a=s[r];e.initializeArray(r,a.array.constructor,a.itemSize,a.normalized)}for(const i in e.attributes)n.includes(i)||e.delete(i);for(const i in t.attributes)n.includes(i)||(t.deleteAttribute(i),t.dispose())}function Wu(u,t,e){let n=!1,s=-1;const i=u.attributes,o=t.groupAttributes[0];for(const a in o){const c=t.getTotalLength(a),l=t.getType(a),d=t.getItemSize(a),h=t.getNormalized(a);let f=i[a];(!f||f.array.length<c)&&(f=new ni(new l(c),d,h),u.setAttribute(a,f),n=!0);let p=0;for(let x=0,g=Math.min(e.length,t.groupCount);x<g;x++){const y=e[x].index,{array:m,type:v,length:b}=t.groupAttributes[y][a],A=new v(m.buffer,0,b);f.array.set(A,p),p+=A.length}f.needsUpdate=!0,s=c/f.itemSize}if(u.index){const a=u.index.array;if(a.length<s)u.index=null,n=!0;else for(let c=0,l=a.length;c<l;c++)a[c]=c}let r=0;u.clearGroups();for(let a=0,c=Math.min(e.length,t.groupCount);a<c;a++){const{index:l,materialIndex:d}=e[a],h=t.getCount(l);h!==0&&(u.addGroup(r,h,d),r+=h)}u.setDrawRange(0,s),u.boundsTree=null,n&&u.dispose()}function kr(u,t){let e=t;return Array.isArray(t)||(e=[],u.forEach(n=>{e[n.materialIndex]=t})),e}class Ea{constructor(){this.triangleSplitter=new Tu,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Vu}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,n,s=new bt){let i=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s],i=!1),s.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:o,attributeData:r,attributes:a,useGroups:c,consolidateGroups:l,debug:d}=this;for(;r.length<s.length;)r.push(new Mu);s.forEach((y,m)=>{Ou(t.geometry,y.geometry,r[m],a)}),d.init(),ku(t,e,n,o,r,{useGroups:c}),d.complete();const h=this.getGroupRanges(t.geometry),f=kr(h,t.material),p=this.getGroupRanges(e.geometry),x=kr(p,e.material);p.forEach(y=>y.materialIndex+=f.length);let g=[...h,...p].map((y,m)=>({...y,index:m}));if(c){const y=[...f,...x];l&&(g=g.map(v=>{const b=y[v.materialIndex];return v.materialIndex=y.indexOf(b),v}).sort((v,b)=>v.materialIndex-b.materialIndex));const m=[];for(let v=0,b=y.length;v<b;v++){let A=!1;for(let S=0,T=g.length;S<T;S++){const M=g[S];M.materialIndex===v&&(A=!0,M.materialIndex=m.length)}A&&m.push(y[v])}s.forEach(v=>{v.material=m})}else g=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach(y=>{y.material=f[0]});return s.forEach((y,m)=>{const v=y.geometry;Wu(v,r[m],g),l&&ju(v.groups)}),i?s:s[0]}evaluateHierarchy(t,e=new bt){t.updateMatrixWorld(!0);const n=(i,o)=>{const r=i.children;for(let a=0,c=r.length;a<c;a++){const l=r[a];l.isOperationGroup?n(l,o):o(l)}},s=i=>{const o=i.children;let r=!1;for(let c=0,l=o.length;c<l;c++){const d=o[c];r=s(d)||r}const a=i.isDirty();if(a&&i.markUpdated(),r&&!i.isOperationGroup){let c;return n(i,l=>{c?c=this.evaluate(c,l,l.operation):c=this.evaluate(i,l,l.operation)}),i._cachedGeometry=c.geometry,i._cachedMaterials=c.material,!0}else return r||a};return s(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const At=!1,G={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},Dt={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},Gu=Ie({title:"Shelf Texture"}),Mn=new An(Gu),Xn=Mn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_COL_1K_METALNESS.png");Xn.colorSpace=Un;const Yn=Mn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_NRM_1K_METALNESS.png"),Zn=Mn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_AO_1K_METALNESS.png"),Kn=Mn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_ROUGHNESS_1K_METALNESS.png"),Jn=Mn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_METALNESS_1K_METALNESS.png"),Qn=Mn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_DISP_1K_METALNESS.png");Xn.wrapS=Xn.wrapT=Yn.wrapS=Yn.wrapT=Zn.wrapS=Zn.wrapT=Kn.wrapS=Kn.wrapT=Jn.wrapS=Jn.wrapT=Qn.wrapS=Qn.wrapT=W;const Vt=.3;Xn.repeat.set(Vt,Vt);Yn.repeat.set(Vt,Vt);Zn.repeat.set(Vt,Vt);Kn.repeat.set(Vt,Vt);Jn.repeat.set(Vt,Vt);Qn.repeat.set(Vt,Vt);const Du=Ie({title:"Window texture"}),Bn=new An(Du),bo=Bn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-albedo.png");bo.colorSpace=Un;const ai=Bn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Normal-dx.png"),ci=Bn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-ao.png"),li=Bn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Roughness.png"),ui=Bn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Metallic.png"),Ao=Bn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Height.png");bo.wrapS=W;bo.wrapT=W;ai.wrapS=W;ai.wrapT=W;ci.wrapS=W;ci.wrapT=W;li.wrapS=W;li.wrapT=W;ui.wrapS=W;ui.wrapT=W;Ao.wrapS=W;Ao.wrapT=W;const{frameThickness:So,frameWidthOuter:Ma,frameHeightOuter:Ba,slatWidth:dn,x:Hu,y:$u,frameWidthInner:_a,frameHeightInner:Ca}=Dt,qt=new vt({roughness:.1,metalness:.6,wireframe:At,color:16777215}),Pa=new bt(new ei(Ma,Ba,So),qt);Pa.updateMatrixWorld();const za=new bt(new ei(_a,Ca,So),qt);za.updateMatrixWorld();const as=new Ea,Uu=as.evaluate(Pa,za,xo),To=new bt(new O(_a+1,dn*2,dn*2,G.roundSegments,G.roundRadius/2),qt);To.position.set(0,-2.2,0);To.updateMatrixWorld();const Eo=new bt(new O(.6,Ca+1,.6,G.roundSegments,G.roundRadius/2),qt);Eo.position.set(0,0,0);Eo.updateMatrixWorld();let ts=as.evaluate(To,Eo,pe);const Mo=new bt(new O(dn,13.4,dn,G.roundSegments,G.roundRadius/2),qt);Mo.position.set(-8.2,4.6,0);Mo.updateMatrixWorld();ts=as.evaluate(ts,Mo,pe);const Bo=new bt(new O(dn,13.4,dn,G.roundSegments,G.roundRadius/2),qt);Bo.position.set(8.2,4.6,0);Bo.updateMatrixWorld();ts=as.evaluate(ts,Bo,pe);const _o=as.evaluate(Uu,ts,pe);_o.position.set(Ma/2+Hu,Ba/2+$u,-(G.wallThickness-So/2));_o.updateMatrixWorld();qt.normalMap=ai;qt.aoMap=ci;qt.roughnessMap=li;qt.metalnessMap=ui;qt.displacementMap=Ao;qt.displacementScale=.01;const{floorXLength:kt,floorZLength:jt,wallHeight:me,wallThickness:Z,roundRadius:De,roundSegments:He,ny:Xu}=G,cs=new Ea,Yu=Ie({title:"Wall texture"}),Co=new An(Yu),Us=Co.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_albedo.png"),Xs=Co.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_normal-ogl.png"),Ys=Co.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_ao.png");Us.repeat.set(2,2);Xs.repeat.set(2,2);Ys.repeat.set(2,2);Us.wrapS=Us.wrapT=W;Xs.wrapS=Xs.wrapT=W;Ys.wrapS=Ys.wrapT=W;const _n=new vt({roughness:1,metalness:0,wireframe:At});_n.map=Us;_n.normalMap=Xs;_n.aoMap=Ys;const Po=new vt({roughness:1,metalness:0,wireframe:At,transparent:!0,opacity:0}),Zu=new O(kt+1,Z,jt+1,He,De),Ku=Ie({title:"Floor texture"}),hi=new An(Ku),Ju=new vt({roughness:1,metalness:0,wireframe:At});let es=new bt(Zu,Ju);es.position.set(kt/2-1/2,-Z/2,jt/2-1/2);es.updateMatrixWorld();const Qu=new O(kt+1,.4,jt+1,He,De),ns=hi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DIFFUSE-1K.png"),ss=hi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-NORMALS16_OPENGL-1K.png"),is=hi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DISPLACEMENT16-1K.png"),os=hi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-ROUGHNESS-1K.png");ns.wrapS=ns.wrapT=ss.wrapS=ss.wrapT=is.wrapS=is.wrapT=os.wrapS=os.wrapT=W;ns.rotation=ss.rotation=is.rotation=os.rotation=Math.PI/2;ns.repeat.set(1.3,1.3);ss.repeat.set(1.3,1.3);is.repeat.set(1.3,1.3);os.repeat.set(1.3,1.3);const th=new vt({wireframe:At,map:ns,normalMap:ss,displacementMap:is,displacementScale:.001,roughnessMap:os}),zo=new bt(Qu,th);zo.position.set(kt/2-1/2,-.199,jt/2-1/2);zo.updateMatrixWorld();es=cs.evaluate(zo,es,pe);const eh=new O(Z,me,jt+1,He,De),Io=new bt(eh,_n);Io.position.set(-Z/2,me/2-Z,jt/2-1/2);Io.updateMatrixWorld();const nh=new O(kt+Z,me,Z,He,De),Lo=new bt(nh,_n);Lo.position.set(kt/2-Z/2,me/2-Z,-Z/2);Lo.updateMatrixWorld();const sh=new ei(Dt.frameWidthOuter,Dt.frameHeightOuter,Z),No=new bt(sh,_n);No.position.set(Dt.frameWidthOuter/2+Dt.x,Dt.frameHeightOuter/2+Dt.y,-Z/2);No.updateMatrixWorld();const Ia=cs.evaluate(Lo,No,xo);Ia.updateMatrixWorld();const di=cs.evaluate(Ia,_o,pe);di.receiveShadow=!0;di.castShadow=!0;di.updateMatrixWorld();const ih=new O(kt+Z+.1,me,.1,He,De),fi=new $(ih,Po);fi.position.set(kt/2-Z/2,me/2-Z,jt-.19);fi.receiveShadow=!0;fi.castShadow=!0;const oh=new O(.1,me,jt+Z,He,De),pi=new $(oh,Po);pi.position.set(kt+.1/2,me/2-Z,jt/2-Z/2);pi.receiveShadow=!0;pi.castShadow=!0;const rh=new O(kt+Z+.1,Z,jt+Z+.1,He,De),mi=new $(rh,Po);mi.position.set(kt/2-Z/2,me-Z/2,jt/2-Z/2);mi.receiveShadow=!0;mi.castShadow=!0;const $e=new fe;$e.position.set(-kt/2,-Xu,-jt/2);let fn=cs.evaluate(Io,di,pe);fn.updateMatrixWorld();fn=cs.evaluate(fn,es,pe);fn.castShadow=!0;fn.receiveShadow=!0;$e.add(fn);$e.add(fi);$e.add(pi);$e.add(mi);H.add($e);const Fo=new kc($e);Fo.visible=!1;H.add(Fo);class Ht{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new w);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new w);const n=this.elements,s=t.x,i=t.y,o=t.z;return e.x=n[0]*s+n[1]*i+n[2]*o,e.y=n[3]*s+n[4]*i+n[5]*o,e.z=n[6]*s+n[7]*i+n[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new Ht);const n=this.elements,s=t.elements,i=e.elements,o=n[0],r=n[1],a=n[2],c=n[3],l=n[4],d=n[5],h=n[6],f=n[7],p=n[8],x=s[0],g=s[1],y=s[2],m=s[3],v=s[4],b=s[5],A=s[6],S=s[7],T=s[8];return i[0]=o*x+r*m+a*A,i[1]=o*g+r*v+a*S,i[2]=o*y+r*b+a*T,i[3]=c*x+l*m+d*A,i[4]=c*g+l*v+d*S,i[5]=c*y+l*b+d*T,i[6]=h*x+f*m+p*A,i[7]=h*g+f*v+p*S,i[8]=h*y+f*b+p*T,e}scale(t,e){e===void 0&&(e=new Ht);const n=this.elements,s=e.elements;for(let i=0;i!==3;i++)s[3*i+0]=t.x*n[3*i+0],s[3*i+1]=t.y*n[3*i+1],s[3*i+2]=t.z*n[3*i+2];return e}solve(t,e){e===void 0&&(e=new w);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=t.x,i[3+4*1]=t.y,i[3+4*2]=t.z;let a=3;const c=a;let l;const d=4;let h;do{if(o=c-a,i[o+s*o]===0){for(r=o+1;r<c;r++)if(i[o+s*r]!==0){l=d;do h=d-l,i[h+s*o]+=i[h+s*r];while(--l);break}}if(i[o+s*o]!==0)for(r=o+1;r<c;r++){const f=i[o+s*r]/i[o+s*o];l=d;do h=d-l,i[h+s*r]=h<=o?0:i[h+s*r]-i[h+s*o]*f;while(--l)}}while(--a);if(e.z=i[2*s+3]/i[2*s+2],e.y=(i[1*s+3]-i[1*s+2]*e.z)/i[1*s+1],e.x=(i[0*s+3]-i[0*s+2]*e.z-i[0*s+1]*e.y)/i[0*s+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,n){if(n===void 0)return this.elements[e+3*t];this.elements[e+3*t]=n}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let n=0;n<9;n++)t+=this.elements[n]+e;return t}reverse(t){t===void 0&&(t=new Ht);const e=3,n=6,s=ah;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const a=r;let c;const l=n;let d;do{if(i=a-r,s[i+n*i]===0){for(o=i+1;o<a;o++)if(s[i+n*o]!==0){c=l;do d=l-c,s[d+n*i]+=s[d+n*o];while(--c);break}}if(s[i+n*i]!==0)for(o=i+1;o<a;o++){const h=s[i+n*o]/s[i+n*i];c=l;do d=l-c,s[d+n*o]=d<=i?0:s[d+n*o]-s[d+n*i]*h;while(--c)}}while(--r);i=2;do{o=i-1;do{const h=s[i+n*o]/s[i+n*i];c=n;do d=n-c,s[d+n*o]=s[d+n*o]-s[d+n*i]*h;while(--c)}while(o--)}while(--i);i=2;do{const h=1/s[i+n*i];c=n;do d=n-c,s[d+n*i]=s[d+n*i]*h;while(--c)}while(i--);i=2;do{o=2;do{if(d=s[e+o+n*i],isNaN(d)||d===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,o,d)}while(o--)}while(i--);return t}setRotationFromQuaternion(t){const e=t.x,n=t.y,s=t.z,i=t.w,o=e+e,r=n+n,a=s+s,c=e*o,l=e*r,d=e*a,h=n*r,f=n*a,p=s*a,x=i*o,g=i*r,y=i*a,m=this.elements;return m[3*0+0]=1-(h+p),m[3*0+1]=l-y,m[3*0+2]=d+g,m[3*1+0]=l+y,m[3*1+1]=1-(c+p),m[3*1+2]=f-x,m[3*2+0]=d-g,m[3*2+1]=f+x,m[3*2+2]=1-(c+h),this}transpose(t){t===void 0&&(t=new Ht);const e=this.elements,n=t.elements;let s;return n[0]=e[0],n[4]=e[4],n[8]=e[8],s=e[1],n[1]=e[3],n[3]=s,s=e[2],n[2]=e[6],n[6]=s,s=e[5],n[5]=e[7],n[7]=s,t}}const ah=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class w{constructor(t,e,n){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),this.x=t,this.y=e,this.z=n}cross(t,e){e===void 0&&(e=new w);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z;return e.x=r*i-a*s,e.y=a*n-o*i,e.z=o*s-r*n,e}set(t,e,n){return this.x=t,this.y=e,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new w(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new w(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new Ht([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,n=this.z,s=Math.sqrt(t*t+e*e+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(t){t===void 0&&(t=new w);const e=this.x,n=this.y,s=this.z;let i=Math.sqrt(e*e+n*n+s*s);return i>0?(i=1/i,t.x=e*i,t.y=n*i,t.z=s*i):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,n=this.z;return Math.sqrt(t*t+e*e+n*n)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return Math.sqrt((i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return(i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s)}scale(t,e){e===void 0&&(e=new w);const n=this.x,s=this.y,i=this.z;return e.x=t*n,e.y=t*s,e.z=t*i,e}vmul(t,e){return e===void 0&&(e=new w),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,n){return n===void 0&&(n=new w),n.x=this.x+t*e.x,n.y=this.y+t*e.y,n.z=this.z+t*e.z,n}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new w),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const n=this.length();if(n>0){const s=ch,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=lh;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,t)):(o.set(0,1,0),s.cross(o,t)),s.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,n){const s=this.x,i=this.y,o=this.z;n.x=s+(t.x-s)*e,n.y=i+(t.y-i)*e,n.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(jr),jr.almostEquals(t,e)}clone(){return new w(this.x,this.y,this.z)}}w.ZERO=new w(0,0,0);w.UNIT_X=new w(1,0,0);w.UNIT_Y=new w(0,1,0);w.UNIT_Z=new w(0,0,1);const ch=new w,lh=new w,jr=new w;class St{constructor(t){t===void 0&&(t={}),this.lowerBound=new w,this.upperBound=new w,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(t[0]),r&&r.vmult(i,i),o.copy(i);for(let a=1;a<t.length;a++){let c=t[a];r&&(r.vmult(c,Or),c=Or),c.x>o.x&&(o.x=c.x),c.x<i.x&&(i.x=c.x),c.y>o.y&&(o.y=c.y),c.y<i.y&&(i.y=c.y),c.z>o.z&&(o.z=c.z),c.z<i.z&&(i.z=c.z)}return e&&(e.vadd(i,i),e.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new St().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound,o=s.x<=n.x&&n.x<=i.x||e.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||e.y<=i.y&&i.y<=n.y,a=s.z<=n.z&&n.z<=i.z||e.z<=i.z&&i.z<=n.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound;return e.x<=s.x&&n.x>=i.x&&e.y<=s.y&&n.y>=i.y&&e.z<=s.z&&n.z>=i.z}getCorners(t,e,n,s,i,o,r,a){const c=this.lowerBound,l=this.upperBound;t.copy(c),e.set(l.x,c.y,c.z),n.set(l.x,l.y,c.z),s.set(c.x,l.y,l.z),i.set(l.x,c.y,l.z),o.set(c.x,l.y,c.z),r.set(c.x,c.y,l.z),a.copy(l)}toLocalFrame(t,e){const n=Wr,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],l=n[6],d=n[7];this.getCorners(s,i,o,r,a,c,l,d);for(let h=0;h!==8;h++){const f=n[h];t.pointToLocal(f,f)}return e.setFromPoints(n)}toWorldFrame(t,e){const n=Wr,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],l=n[6],d=n[7];this.getCorners(s,i,o,r,a,c,l,d);for(let h=0;h!==8;h++){const f=n[h];t.pointToWorld(f,f)}return e.setFromPoints(n)}overlapsRay(t){const{direction:e,from:n}=t,s=1/e.x,i=1/e.y,o=1/e.z,r=(this.lowerBound.x-n.x)*s,a=(this.upperBound.x-n.x)*s,c=(this.lowerBound.y-n.y)*i,l=(this.upperBound.y-n.y)*i,d=(this.lowerBound.z-n.z)*o,h=(this.upperBound.z-n.z)*o,f=Math.max(Math.max(Math.min(r,a),Math.min(c,l)),Math.min(d,h)),p=Math.min(Math.min(Math.max(r,a),Math.max(c,l)),Math.max(d,h));return!(p<0||f>p)}}const Or=new w,Wr=[new w,new w,new w,new w,new w,new w,new w,new w];class Gr{constructor(){this.matrix=[]}get(t,e){let{index:n}=t,{index:s}=e;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(t,e,n){let{index:s}=t,{index:i}=e;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class La{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[t]===void 0&&(n[t]=[]),n[t].includes(e)||n[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[t]!==void 0&&n[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const n=this._listeners;if(n[t]===void 0)return this;const s=n[t].indexOf(e);return s!==-1&&n[t].splice(s,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const n=this._listeners[t.type];if(n!==void 0){t.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,t)}return this}}class tt{constructor(t,e,n,s){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=t,this.y=e,this.z=n,this.w=s}set(t,e,n,s){return this.x=t,this.y=e,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const n=Math.sin(e*.5);return this.x=t.x*n,this.y=t.y*n,this.z=t.z*n,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new w),this.normalize();const e=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/n,t.y=this.y/n,t.z=this.z/n),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const n=uh,s=hh;t.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=t.cross(e);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new tt);const n=this.x,s=this.y,i=this.z,o=this.w,r=t.x,a=t.y,c=t.z,l=t.w;return e.x=n*l+o*r+s*c-i*a,e.y=s*l+o*a+i*r-n*c,e.z=i*l+o*c+n*a-s*r,e.w=o*l-n*r-s*a-i*c,e}inverse(t){t===void 0&&(t=new tt);const e=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(t);const o=1/(e*e+n*n+s*s+i*i);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new tt),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new w);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z,c=this.w,l=c*n+r*i-a*s,d=c*s+a*n-o*i,h=c*i+o*s-r*n,f=-o*n-r*s-a*i;return e.x=l*c+f*-o+d*-a-h*-r,e.y=d*c+f*-r+h*-o-l*-a,e.z=h*c+f*-a+l*-r-d*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let n,s,i;const o=this.x,r=this.y,a=this.z,c=this.w;switch(e){case"YZX":const l=o*r+a*c;if(l>.499&&(n=2*Math.atan2(o,c),s=Math.PI/2,i=0),l<-.499&&(n=-2*Math.atan2(o,c),s=-Math.PI/2,i=0),n===void 0){const d=o*o,h=r*r,f=a*a;n=Math.atan2(2*r*c-2*o*a,1-2*h-2*f),s=Math.asin(2*l),i=Math.atan2(2*o*c-2*r*a,1-2*d-2*f)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=n,t.z=s,t.x=i}setFromEuler(t,e,n,s){s===void 0&&(s="XYZ");const i=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(n/2),a=Math.sin(t/2),c=Math.sin(e/2),l=Math.sin(n/2);return s==="XYZ"?(this.x=a*o*r+i*c*l,this.y=i*c*r-a*o*l,this.z=i*o*l+a*c*r,this.w=i*o*r-a*c*l):s==="YXZ"?(this.x=a*o*r+i*c*l,this.y=i*c*r-a*o*l,this.z=i*o*l-a*c*r,this.w=i*o*r+a*c*l):s==="ZXY"?(this.x=a*o*r-i*c*l,this.y=i*c*r+a*o*l,this.z=i*o*l+a*c*r,this.w=i*o*r-a*c*l):s==="ZYX"?(this.x=a*o*r-i*c*l,this.y=i*c*r+a*o*l,this.z=i*o*l-a*c*r,this.w=i*o*r+a*c*l):s==="YZX"?(this.x=a*o*r+i*c*l,this.y=i*c*r+a*o*l,this.z=i*o*l-a*c*r,this.w=i*o*r-a*c*l):s==="XZY"&&(this.x=a*o*r-i*c*l,this.y=i*c*r-a*o*l,this.z=i*o*l+a*c*r,this.w=i*o*r+a*c*l),this}clone(){return new tt(this.x,this.y,this.z,this.w)}slerp(t,e,n){n===void 0&&(n=new tt);const s=this.x,i=this.y,o=this.z,r=this.w;let a=t.x,c=t.y,l=t.z,d=t.w,h,f,p,x,g;return f=s*a+i*c+o*l+r*d,f<0&&(f=-f,a=-a,c=-c,l=-l,d=-d),1-f>1e-6?(h=Math.acos(f),p=Math.sin(h),x=Math.sin((1-e)*h)/p,g=Math.sin(e*h)/p):(x=1-e,g=e),n.x=x*s+g*a,n.y=x*i+g*c,n.z=x*o+g*l,n.w=x*r+g*d,n}integrate(t,e,n,s){s===void 0&&(s=new tt);const i=t.x*n.x,o=t.y*n.y,r=t.z*n.z,a=this.x,c=this.y,l=this.z,d=this.w,h=e*.5;return s.x+=h*(i*d+o*l-r*c),s.y+=h*(o*d+r*a-i*l),s.z+=h*(r*d+i*c-o*a),s.w+=h*(-i*a-o*c-r*l),s}}const uh=new w,hh=new w,dh={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class R{constructor(t){t===void 0&&(t={}),this.id=R.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}R.idCounter=0;R.types=dh;class D{constructor(t){t===void 0&&(t={}),this.position=new w,this.quaternion=new tt,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return D.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return D.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new w),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,n,s){return s===void 0&&(s=new w),n.vsub(t,s),e.conjugate(Dr),Dr.vmult(s,s),s}static pointToWorldFrame(t,e,n,s){return s===void 0&&(s=new w),e.vmult(n,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,n){return n===void 0&&(n=new w),t.vmult(e,n),n}static vectorToLocalFrame(t,e,n,s){return s===void 0&&(s=new w),e.w*=-1,e.vmult(n,s),e.w*=-1,s}}const Dr=new tt;class $n extends R{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=t;super({type:R.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,n=this.uniqueEdges;n.length=0;const s=new w;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let a=0;a!==r;a++){const c=(a+1)%r;e[o[a]].vsub(e[o[c]],s),s.normalize();let l=!1;for(let d=0;d!==n.length;d++)if(n[d].almostEquals(s)||n[d].almostEquals(s)){l=!0;break}l||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const e=this.faceNormals[t]||new w;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const n=this.vertices[this.faces[t][0]];if(e.dot(n)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,e){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];$n.computeNormal(s,i,o,e)}static computeNormal(t,e,n,s){const i=new w,o=new w;e.vsub(t,o),n.vsub(e,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,n,s,i,o,r,a,c){const l=new w;let d=-1,h=-Number.MAX_VALUE;for(let p=0;p<n.faces.length;p++){l.copy(n.faceNormals[p]),i.vmult(l,l);const x=l.dot(o);x>h&&(h=x,d=p)}const f=[];for(let p=0;p<n.faces[d].length;p++){const x=n.vertices[n.faces[d][p]],g=new w;g.copy(x),i.vmult(g,g),s.vadd(g,g),f.push(g)}d>=0&&this.clipFaceAgainstHull(o,t,e,f,r,a,c)}findSeparatingAxis(t,e,n,s,i,o,r,a){const c=new w,l=new w,d=new w,h=new w,f=new w,p=new w;let x=Number.MAX_VALUE;const g=this;if(g.uniqueAxes)for(let y=0;y!==g.uniqueAxes.length;y++){n.vmult(g.uniqueAxes[y],c);const m=g.testSepAxis(c,t,e,n,s,i);if(m===!1)return!1;m<x&&(x=m,o.copy(c))}else{const y=r?r.length:g.faces.length;for(let m=0;m<y;m++){const v=r?r[m]:m;c.copy(g.faceNormals[v]),n.vmult(c,c);const b=g.testSepAxis(c,t,e,n,s,i);if(b===!1)return!1;b<x&&(x=b,o.copy(c))}}if(t.uniqueAxes)for(let y=0;y!==t.uniqueAxes.length;y++){i.vmult(t.uniqueAxes[y],l);const m=g.testSepAxis(l,t,e,n,s,i);if(m===!1)return!1;m<x&&(x=m,o.copy(l))}else{const y=a?a.length:t.faces.length;for(let m=0;m<y;m++){const v=a?a[m]:m;l.copy(t.faceNormals[v]),i.vmult(l,l);const b=g.testSepAxis(l,t,e,n,s,i);if(b===!1)return!1;b<x&&(x=b,o.copy(l))}}for(let y=0;y!==g.uniqueEdges.length;y++){n.vmult(g.uniqueEdges[y],h);for(let m=0;m!==t.uniqueEdges.length;m++)if(i.vmult(t.uniqueEdges[m],f),h.cross(f,p),!p.almostZero()){p.normalize();const v=g.testSepAxis(p,t,e,n,s,i);if(v===!1)return!1;v<x&&(x=v,o.copy(p))}}return s.vsub(e,d),d.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,n,s,i,o){const r=this;$n.project(r,t,n,s,Yi),$n.project(e,t,i,o,Zi);const a=Yi[0],c=Yi[1],l=Zi[0],d=Zi[1];if(a<d||l<c)return!1;const h=a-d,f=l-c;return h<f?h:f}calculateLocalInertia(t,e){const n=new w,s=new w;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*i*2*i+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],n=this.faceNormals[t],s=this.vertices[e[0]];return-n.dot(s)}clipFaceAgainstHull(t,e,n,s,i,o,r){const a=new w,c=new w,l=new w,d=new w,h=new w,f=new w,p=new w,x=new w,g=this,y=[],m=s,v=y;let b=-1,A=Number.MAX_VALUE;for(let _=0;_<g.faces.length;_++){a.copy(g.faceNormals[_]),n.vmult(a,a);const z=a.dot(t);z<A&&(A=z,b=_)}if(b<0)return;const S=g.faces[b];S.connectedFaces=[];for(let _=0;_<g.faces.length;_++)for(let z=0;z<g.faces[_].length;z++)S.indexOf(g.faces[_][z])!==-1&&_!==b&&S.connectedFaces.indexOf(_)===-1&&S.connectedFaces.push(_);const T=S.length;for(let _=0;_<T;_++){const z=g.vertices[S[_]],C=g.vertices[S[(_+1)%T]];z.vsub(C,c),l.copy(c),n.vmult(l,l),e.vadd(l,l),d.copy(this.faceNormals[b]),n.vmult(d,d),e.vadd(d,d),l.cross(d,h),h.negate(h),f.copy(z),n.vmult(f,f),e.vadd(f,f);const E=S.connectedFaces[_];p.copy(this.faceNormals[E]);const P=this.getPlaneConstantOfFace(E);x.copy(p),n.vmult(x,x);const I=P-x.dot(e);for(this.clipFaceAgainstPlane(m,v,x,I);m.length;)m.shift();for(;v.length;)m.push(v.shift())}p.copy(this.faceNormals[b]);const M=this.getPlaneConstantOfFace(b);x.copy(p),n.vmult(x,x);const B=M-x.dot(e);for(let _=0;_<m.length;_++){let z=x.dot(m[_])+B;if(z<=i&&(console.log(`clamped: depth=${z} to minDist=${i}`),z=i),z<=o){const C=m[_];if(z<=1e-6){const E={point:C,normal:x,depth:z};r.push(E)}}}}clipFaceAgainstPlane(t,e,n,s){let i,o;const r=t.length;if(r<2)return e;let a=t[t.length-1],c=t[0];i=n.dot(a)+s;for(let l=0;l<r;l++){if(c=t[l],o=n.dot(c)+s,i<0)if(o<0){const d=new w;d.copy(c),e.push(d)}else{const d=new w;a.lerp(c,i/(i-o),d),e.push(d)}else if(o<0){const d=new w;a.lerp(c,i/(i-o),d),e.push(d),e.push(c)}a=c,i=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new w);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(n[i],s[i]),t.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const n=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<t.x?t.x=i.x:i.x>e.x&&(e.x=i.x),i.y<t.y?t.y=i.y:i.y>e.y&&(e.y=i.y),i.z<t.z?t.z=i.z:i.z>e.z&&(e.z=i.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new w);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let n=0;n!==e.length;n++){const s=e[n].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,n,s){const i=this.vertices;let o,r,a,c,l,d,h=new w;for(let f=0;f<i.length;f++){h.copy(i[f]),e.vmult(h,h),t.vadd(h,h);const p=h;(o===void 0||p.x<o)&&(o=p.x),(c===void 0||p.x>c)&&(c=p.x),(r===void 0||p.y<r)&&(r=p.y),(l===void 0||p.y>l)&&(l=p.y),(a===void 0||p.z<a)&&(a=p.z),(d===void 0||p.z>d)&&(d=p.z)}n.set(o,r,a),s.set(c,l,d)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new w);const e=this.vertices;for(let n=0;n<e.length;n++)t.vadd(e[n],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const n=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<n;i++){const o=s[i];e.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];e.vmult(o,o)}}if(t)for(let i=0;i<n;i++){const o=s[i];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,n=this.faces,s=this.faceNormals,i=null,o=new w;this.getAveragePointLocal(o);for(let r=0;r<this.faces.length;r++){let a=s[r];const c=e[n[r][0]],l=new w;t.vsub(c,l);const d=a.dot(l),h=new w;o.vsub(c,h);const f=a.dot(h);if(d<0&&f>0||d>0&&f<0)return!1}return i?1:-1}static project(t,e,n,s,i){const o=t.vertices.length,r=fh;let a=0,c=0;const l=ph,d=t.vertices;l.setZero(),D.vectorToLocalFrame(n,s,e,r),D.pointToLocalFrame(n,s,l,l);const h=l.dot(r);c=a=d[0].dot(r);for(let f=1;f<o;f++){const p=d[f].dot(r);p>a&&(a=p),p<c&&(c=p)}if(c-=h,a-=h,c>a){const f=c;c=a,a=f}i[0]=a,i[1]=c}}const Yi=[],Zi=[];new w;const fh=new w,ph=new w;class Ro extends R{constructor(t){super({type:R.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,n=this.halfExtents.z,s=w,i=[new s(-t,-e,-n),new s(t,-e,-n),new s(t,e,-n),new s(-t,e,-n),new s(-t,-e,n),new s(t,-e,n),new s(t,e,n),new s(-t,e,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],a=new $n({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new w),Ro.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,n){const s=t;n.x=1/12*e*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*e*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*e*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(t,e){const n=t,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),e!==void 0)for(let i=0;i!==n.length;i++)e.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)Me.set(i[o][0],i[o][1],i[o][2]),e.vmult(Me,Me),t.vadd(Me,Me),n(Me.x,Me.y,Me.z)}calculateWorldAABB(t,e,n,s){const i=this.halfExtents;Zt[0].set(i.x,i.y,i.z),Zt[1].set(-i.x,i.y,i.z),Zt[2].set(-i.x,-i.y,i.z),Zt[3].set(-i.x,-i.y,-i.z),Zt[4].set(i.x,-i.y,-i.z),Zt[5].set(i.x,i.y,-i.z),Zt[6].set(-i.x,i.y,-i.z),Zt[7].set(i.x,-i.y,i.z);const o=Zt[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const a=Zt[r];e.vmult(a,a),t.vadd(a,a);const c=a.x,l=a.y,d=a.z;c>s.x&&(s.x=c),l>s.y&&(s.y=l),d>s.z&&(s.z=d),c<n.x&&(n.x=c),l<n.y&&(n.y=l),d<n.z&&(n.z=d)}}}const Me=new w,Zt=[new w,new w,new w,new w,new w,new w,new w,new w],Vo={DYNAMIC:1,STATIC:2,KINEMATIC:4},qo={AWAKE:0,SLEEPY:1,SLEEPING:2};class F extends La{constructor(t){t===void 0&&(t={}),super(),this.id=F.idCounter++,this.index=-1,this.world=null,this.vlambda=new w,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new w,this.previousPosition=new w,this.interpolatedPosition=new w,this.initPosition=new w,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new w,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new w,this.force=new w;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?F.STATIC:F.DYNAMIC,typeof t.type==typeof F.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=F.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new w,this.quaternion=new tt,this.initQuaternion=new tt,this.previousQuaternion=new tt,this.interpolatedQuaternion=new tt,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new w,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new w,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new w,this.invInertia=new w,this.invInertiaWorld=new Ht,this.invMassSolve=0,this.invInertiaSolve=new w,this.invInertiaWorldSolve=new Ht,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new w(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new w(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new St,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new w,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=F.AWAKE,this.wakeUpAfterNarrowphase=!1,t===F.SLEEPING&&this.dispatchEvent(F.wakeupEvent)}sleep(){this.sleepState=F.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===F.AWAKE&&n<s?(this.sleepState=F.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(F.sleepyEvent)):e===F.SLEEPY&&n>s?this.wakeUp():e===F.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(F.sleepEvent))}}updateSolveMassProperties(){this.sleepState===F.SLEEPING||this.type===F.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new w),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new w),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new w),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new w),this.quaternion.vmult(t,e),e}addShape(t,e,n){const s=new w,i=new tt;return e&&s.copy(e),n&&i.copy(n),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,n=t.length;let s=0;for(let i=0;i!==n;i++){const o=t[i];o.updateBoundingSphereRadius();const r=e[i].length(),a=o.boundingSphereRadius;r+a>s&&(s=r+a)}this.boundingRadius=s}updateAABB(){const t=this.shapes,e=this.shapeOffsets,n=this.shapeOrientations,s=t.length,i=mh,o=yh,r=this.quaternion,a=this.aabb,c=wh;for(let l=0;l!==s;l++){const d=t[l];r.vmult(e[l],i),i.vadd(this.position,i),r.mult(n[l],o),d.calculateWorldAABB(i,o,c.lowerBound,c.upperBound),l===0?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const n=gh,s=xh;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(e,n),n.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new w),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=vh;e.cross(t,n),this.force.vadd(t,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new w),this.type!==F.DYNAMIC)return;const n=bh,s=Ah;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyForce(n,s)}applyTorque(t){this.type===F.DYNAMIC&&(this.sleepState===F.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new w),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=e,s=Sh;s.copy(t),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=Th;n.cross(t,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new w),this.type!==F.DYNAMIC)return;const n=Eh,s=Mh;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyImpulse(n,s)}updateMassProperties(){const t=Bh;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,n=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Ro.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!n?1/e.x:0,e.y>0&&!n?1/e.y:0,e.z>0&&!n?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const n=new w;return t.vsub(this.position,n),this.angularVelocity.cross(n,e),this.velocity.vadd(e,e),e}integrate(t,e,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===F.DYNAMIC||this.type===F.KINEMATIC)||this.sleepState===F.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,a=this.torque,c=this.quaternion,l=this.invMass,d=this.invInertiaWorld,h=this.linearFactor,f=l*t;s.x+=r.x*f*h.x,s.y+=r.y*f*h.y,s.z+=r.z*f*h.z;const p=d.elements,x=this.angularFactor,g=a.x*x.x,y=a.y*x.y,m=a.z*x.z;i.x+=t*(p[0]*g+p[1]*y+p[2]*m),i.y+=t*(p[3]*g+p[4]*y+p[5]*m),i.z+=t*(p[6]*g+p[7]*y+p[8]*m),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,c.integrate(this.angularVelocity,t,this.angularFactor,c),e&&(n?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}F.idCounter=0;F.COLLIDE_EVENT_NAME="collide";F.DYNAMIC=Vo.DYNAMIC;F.STATIC=Vo.STATIC;F.KINEMATIC=Vo.KINEMATIC;F.AWAKE=qo.AWAKE;F.SLEEPY=qo.SLEEPY;F.SLEEPING=qo.SLEEPING;F.wakeupEvent={type:"wakeup"};F.sleepyEvent={type:"sleepy"};F.sleepEvent={type:"sleep"};const mh=new w,yh=new tt,wh=new St,gh=new Ht,xh=new Ht;new Ht;const vh=new w,bh=new w,Ah=new w,Sh=new w,Th=new w,Eh=new w,Mh=new w,Bh=new w;class _h{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!(!(t.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&t.collisionFilterMask)||(t.type&F.STATIC||t.sleepState===F.SLEEPING)&&(e.type&F.STATIC||e.sleepState===F.SLEEPING))}intersectionTest(t,e,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,n,s):this.doBoundingSphereBroadphase(t,e,n,s)}doBoundingSphereBroadphase(t,e,n,s){const i=Ch;e.position.vsub(t.position,i);const o=(t.boundingRadius+e.boundingRadius)**2;i.lengthSquared()<o&&(n.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,n,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(n.push(t),s.push(e))}makePairsUnique(t,e){const n=Ph,s=zh,i=Ih,o=t.length;for(let r=0;r!==o;r++)s[r]=t[r],i[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const a=s[r].id,c=i[r].id,l=a<c?`${a},${c}`:`${c},${a}`;n[l]=r,n.keys.push(l)}for(let r=0;r!==n.keys.length;r++){const a=n.keys.pop(),c=n[a];t.push(s[c]),e.push(i[c]),delete n[a]}}setWorld(t){}static boundingSphereCheck(t,e){const n=new w;t.position.vsub(e.position,n);const s=t.shapes[0],i=e.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(t,e,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Ch=new w;new w;new tt;new w;const Ph={keys:[]},zh=[],Ih=[];new w;new w;new w;class Lh extends _h{constructor(){super()}collisionPairs(t,e,n){const s=t.bodies,i=s.length;let o,r;for(let a=0;a!==i;a++)for(let c=0;c!==a;c++)o=s[a],r=s[c],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,n)}aabbQuery(t,e,n){n===void 0&&(n=[]);for(let s=0;s<t.bodies.length;s++){const i=t.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(e)&&n.push(i)}return n}}class Zs{constructor(){this.rayFromWorld=new w,this.rayToWorld=new w,this.hitNormalWorld=new w,this.hitPointWorld=new w,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,n,s,i,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let Na,Fa,Ra,Va,qa,ka,ja;const ko={CLOSEST:1,ANY:2,ALL:4};Na=R.types.SPHERE;Fa=R.types.PLANE;Ra=R.types.BOX;Va=R.types.CYLINDER;qa=R.types.CONVEXPOLYHEDRON;ka=R.types.HEIGHTFIELD;ja=R.types.TRIMESH;class Q{get[Na](){return this._intersectSphere}get[Fa](){return this._intersectPlane}get[Ra](){return this._intersectBox}get[Va](){return this._intersectConvex}get[qa](){return this._intersectConvex}get[ka](){return this._intersectHeightfield}get[ja](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new w),e===void 0&&(e=new w),this.from=t.clone(),this.to=e.clone(),this.direction=new w,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Q.ANY,this.result=new Zs,this.hasHit=!1,this.callback=n=>{}}intersectWorld(t,e){return this.mode=e.mode||Q.ANY,this.result=e.result||new Zs,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Hr),Ki.length=0,t.broadphase.aabbQuery(t,Hr,Ki),this.intersectBodies(Ki),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!t.collisionResponse||!(this.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&this.collisionFilterMask))return;const s=Nh,i=Fh;for(let o=0,r=t.shapes.length;o<r;o++){const a=t.shapes[o];if(!(n&&!a.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],i),t.quaternion.vmult(t.shapeOffsets[o],s),s.vadd(t.position,s),this.intersectShape(a,i,s,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let n=0,s=t.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(t[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,n,s){const i=this.from;if(Yh(i,this.direction,n)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,n,s,t)}_intersectBox(t,e,n,s,i){return this._intersectConvex(t.convexPolyhedronRepresentation,e,n,s,i)}_intersectPlane(t,e,n,s,i){const o=this.from,r=this.to,a=this.direction,c=new w(0,0,1);e.vmult(c,c);const l=new w;o.vsub(n,l);const d=l.dot(c);r.vsub(n,l);const h=l.dot(c);if(d*h>0||o.distanceTo(r)<d)return;const f=c.dot(a);if(Math.abs(f)<this.precision)return;const p=new w,x=new w,g=new w;o.vsub(n,p);const y=-c.dot(p)/f;a.scale(y,x),o.vadd(x,g),this.reportIntersection(c,g,i,s,-1)}getAABB(t){const{lowerBound:e,upperBound:n}=t,s=this.to,i=this.from;e.x=Math.min(s.x,i.x),e.y=Math.min(s.y,i.y),e.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(t,e,n,s,i){t.data,t.elementSize;const o=Rh;o.from.copy(this.from),o.to.copy(this.to),D.pointToLocalFrame(n,e,o.from,o.from),D.pointToLocalFrame(n,e,o.to,o.to),o.updateDirection();const r=Vh;let a,c,l,d;a=c=0,l=d=t.data.length-1;const h=new St;o.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,r,!0),a=Math.max(a,r[0]),c=Math.max(c,r[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,r,!0),l=Math.min(l,r[0]+1),d=Math.min(d,r[1]+1);for(let f=a;f<l;f++)for(let p=c;p<d;p++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(f,p,h),!!h.overlapsRay(o)){if(t.getConvexTrianglePillar(f,p,!1),D.pointToWorldFrame(n,e,t.pillarOffset,Ns),this._intersectConvex(t.pillarConvex,e,Ns,s,i,$r),this.result.shouldStop)return;t.getConvexTrianglePillar(f,p,!0),D.pointToWorldFrame(n,e,t.pillarOffset,Ns),this._intersectConvex(t.pillarConvex,e,Ns,s,i,$r)}}}_intersectSphere(t,e,n,s,i){const o=this.from,r=this.to,a=t.radius,c=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,l=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),d=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-a**2,h=l**2-4*c*d,f=qh,p=kh;if(!(h<0))if(h===0)o.lerp(r,h,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1);else{const x=(-l-Math.sqrt(h))/(2*c),g=(-l+Math.sqrt(h))/(2*c);if(x>=0&&x<=1&&(o.lerp(r,x,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1)),this.result.shouldStop)return;g>=0&&g<=1&&(o.lerp(r,g,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1))}}_intersectConvex(t,e,n,s,i,o){const r=jh,a=Ur,c=o&&o.faceList||null,l=t.faces,d=t.vertices,h=t.faceNormals,f=this.direction,p=this.from,x=this.to,g=p.distanceTo(x),y=c?c.length:l.length,m=this.result;for(let v=0;!m.shouldStop&&v<y;v++){const b=c?c[v]:v,A=l[b],S=h[b],T=e,M=n;a.copy(d[A[0]]),T.vmult(a,a),a.vadd(M,a),a.vsub(p,a),T.vmult(S,r);const B=f.dot(r);if(Math.abs(B)<this.precision)continue;const _=r.dot(a)/B;if(!(_<0)){f.scale(_,pt),pt.vadd(p,pt),Ot.copy(d[A[0]]),T.vmult(Ot,Ot),M.vadd(Ot,Ot);for(let z=1;!m.shouldStop&&z<A.length-1;z++){Kt.copy(d[A[z]]),Jt.copy(d[A[z+1]]),T.vmult(Kt,Kt),T.vmult(Jt,Jt),M.vadd(Kt,Kt),M.vadd(Jt,Jt);const C=pt.distanceTo(p);!(Q.pointInTriangle(pt,Ot,Kt,Jt)||Q.pointInTriangle(pt,Kt,Ot,Jt))||C>g||this.reportIntersection(r,pt,i,s,b)}}}}_intersectTrimesh(t,e,n,s,i,o){const r=Oh,a=Uh,c=Xh,l=Ur,d=Wh,h=Gh,f=Dh,p=$h,x=Hh,g=t.indices;t.vertices;const y=this.from,m=this.to,v=this.direction;c.position.copy(n),c.quaternion.copy(e),D.vectorToLocalFrame(n,e,v,d),D.pointToLocalFrame(n,e,y,h),D.pointToLocalFrame(n,e,m,f),f.x*=t.scale.x,f.y*=t.scale.y,f.z*=t.scale.z,h.x*=t.scale.x,h.y*=t.scale.y,h.z*=t.scale.z,f.vsub(h,d),d.normalize();const b=h.distanceSquared(f);t.tree.rayQuery(this,c,a);for(let A=0,S=a.length;!this.result.shouldStop&&A!==S;A++){const T=a[A];t.getNormal(T,r),t.getVertex(g[T*3],Ot),Ot.vsub(h,l);const M=d.dot(r),B=r.dot(l)/M;if(B<0)continue;d.scale(B,pt),pt.vadd(h,pt),t.getVertex(g[T*3+1],Kt),t.getVertex(g[T*3+2],Jt);const _=pt.distanceSquared(h);!(Q.pointInTriangle(pt,Kt,Ot,Jt)||Q.pointInTriangle(pt,Ot,Kt,Jt))||_>b||(D.vectorToWorldFrame(e,r,x),D.pointToWorldFrame(n,e,pt,p),this.reportIntersection(x,p,i,s,T))}a.length=0}reportIntersection(t,e,n,s,i){const o=this.from,r=this.to,a=o.distanceTo(e),c=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(c.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case Q.ALL:this.hasHit=!0,c.set(o,r,t,e,n,s,a),c.hasHit=!0,this.callback(c);break;case Q.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a));break;case Q.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a),c.shouldStop=!0;break}}static pointInTriangle(t,e,n,s){s.vsub(e,je),n.vsub(e,qn),t.vsub(e,Ji);const i=je.dot(je),o=je.dot(qn),r=je.dot(Ji),a=qn.dot(qn),c=qn.dot(Ji);let l,d;return(l=a*r-o*c)>=0&&(d=i*c-o*r)>=0&&l+d<i*a-o*o}}Q.CLOSEST=ko.CLOSEST;Q.ANY=ko.ANY;Q.ALL=ko.ALL;const Hr=new St,Ki=[],qn=new w,Ji=new w,Nh=new w,Fh=new tt,pt=new w,Ot=new w,Kt=new w,Jt=new w;new w;new Zs;const $r={faceList:[0]},Ns=new w,Rh=new Q,Vh=[],qh=new w,kh=new w,jh=new w;new w;new w;const Ur=new w,Oh=new w,Wh=new w,Gh=new w,Dh=new w,Hh=new w,$h=new w;new St;const Uh=[],Xh=new D,je=new w,Fs=new w;function Yh(u,t,e){e.vsub(u,je);const n=je.dot(t);return t.scale(n,Fs),Fs.vadd(u,Fs),e.distanceTo(Fs)}class Zh{static defaults(t,e){t===void 0&&(t={});for(let n in e)n in t||(t[n]=e[n]);return t}}class Xr{constructor(){this.spatial=new w,this.rotational=new w}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class ls{constructor(t,e,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=ls.idCounter++,this.minForce=n,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Xr,this.jacobianElementB=new Xr,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,n){const s=e,i=t,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(t,e,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*t-s*e-o*n}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return t.spatial.dot(i)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,a=s.angularVelocity;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,a=s.wlambda;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,a=s.torque,c=n.invMassSolve,l=s.invMassSolve;return i.scale(c,Yr),r.scale(l,Zr),n.invInertiaWorldSolve.vmult(o,Kr),s.invInertiaWorldSolve.vmult(a,Jr),t.multiplyVectors(Yr,Kr)+e.multiplyVectors(Zr,Jr)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,a=s.invInertiaWorldSolve;let c=i+o;return r.vmult(t.rotational,Rs),c+=Rs.dot(t.rotational),a.vmult(e.rotational,Rs),c+=Rs.dot(e.rotational),c}addToWlambda(t){const e=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=Kh;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*t,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,o),s.wlambda.addScaledVector(t,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}ls.idCounter=0;const Yr=new w,Zr=new w,Kr=new w,Jr=new w,Rs=new w,Kh=new w;class Jh extends ls{constructor(t,e,n){n===void 0&&(n=1e6),super(t,e,0,n),this.restitution=0,this.ri=new w,this.rj=new w,this.ni=new w}computeB(t){const e=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,a=Qh,c=td,l=s.velocity,d=s.angularVelocity;s.force,s.torque;const h=i.velocity,f=i.angularVelocity;i.force,i.torque;const p=ed,x=this.jacobianElementA,g=this.jacobianElementB,y=this.ni;o.cross(y,a),r.cross(y,c),y.negate(x.spatial),a.negate(x.rotational),g.spatial.copy(y),g.rotational.copy(c),p.copy(i.position),p.vadd(r,p),p.vsub(s.position,p),p.vsub(o,p);const m=y.dot(p),v=this.restitution+1,b=v*h.dot(y)-v*l.dot(y)+f.dot(c)-d.dot(a),A=this.computeGiMf();return-m*e-b*n-t*A}getImpactVelocityAlongNormal(){const t=nd,e=sd,n=id,s=od,i=rd;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,t),this.bj.getVelocityAtWorldPoint(s,e),t.vsub(e,i),this.ni.dot(i)}}const Qh=new w,td=new w,ed=new w,nd=new w,sd=new w,id=new w,od=new w,rd=new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;class Qr extends ls{constructor(t,e,n){super(t,e,-n,n),this.ri=new w,this.rj=new w,this.t=new w}computeB(t){this.a;const e=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=ad,o=cd,r=this.t;n.cross(r,i),s.cross(r,o);const a=this.jacobianElementA,c=this.jacobianElementB;r.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(r),c.rotational.copy(o);const l=this.computeGW(),d=this.computeGiMf();return-l*e-t*d}}const ad=new w,cd=new w;class yi{constructor(t,e,n){n=Zh.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=yi.idCounter++,this.materials=[t,e],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}yi.idCounter=0;class wi{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=wi.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}wi.idCounter=0;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new Q;new w;new w;new w;new w(1,0,0),new w(0,1,0),new w(0,0,1);new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new w;new St;new w;new St;new w;new w;new w;new w;new w;new w;new w;new St;new w;new D;new St;class ld{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,n=e.indexOf(t);n!==-1&&e.splice(n,1)}removeAllEquations(){this.equations.length=0}}class ud extends ld{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=e.bodies,c=a.length,l=t;let d,h,f,p,x,g;if(r!==0)for(let b=0;b!==c;b++)a[b].updateSolveMassProperties();const y=dd,m=fd,v=hd;y.length=r,m.length=r,v.length=r;for(let b=0;b!==r;b++){const A=o[b];v[b]=0,m[b]=A.computeB(l),y[b]=1/A.computeC()}if(r!==0){for(let S=0;S!==c;S++){const T=a[S],M=T.vlambda,B=T.wlambda;M.set(0,0,0),B.set(0,0,0)}for(n=0;n!==s;n++){p=0;for(let S=0;S!==r;S++){const T=o[S];d=m[S],h=y[S],g=v[S],x=T.computeGWlambda(),f=h*(d-x-T.eps*g),g+f<T.minForce?f=T.minForce-g:g+f>T.maxForce&&(f=T.maxForce-g),v[S]+=f,p+=f>0?f:-f,T.addToWlambda(f)}if(p*p<i)break}for(let S=0;S!==c;S++){const T=a[S],M=T.velocity,B=T.angularVelocity;T.vlambda.vmul(T.linearFactor,T.vlambda),M.vadd(T.vlambda,M),T.wlambda.vmul(T.angularFactor,T.wlambda),B.vadd(T.wlambda,B)}let b=o.length;const A=1/l;for(;b--;)o[b].multiplier=v[b]*A}return n}}const hd=[],dd=[],fd=[];F.STATIC;class pd{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class md extends pd{constructor(){super(...arguments),this.type=w}constructObject(){return new w}}const X={sphereSphere:R.types.SPHERE,spherePlane:R.types.SPHERE|R.types.PLANE,boxBox:R.types.BOX|R.types.BOX,sphereBox:R.types.SPHERE|R.types.BOX,planeBox:R.types.PLANE|R.types.BOX,convexConvex:R.types.CONVEXPOLYHEDRON,sphereConvex:R.types.SPHERE|R.types.CONVEXPOLYHEDRON,planeConvex:R.types.PLANE|R.types.CONVEXPOLYHEDRON,boxConvex:R.types.BOX|R.types.CONVEXPOLYHEDRON,sphereHeightfield:R.types.SPHERE|R.types.HEIGHTFIELD,boxHeightfield:R.types.BOX|R.types.HEIGHTFIELD,convexHeightfield:R.types.CONVEXPOLYHEDRON|R.types.HEIGHTFIELD,sphereParticle:R.types.PARTICLE|R.types.SPHERE,planeParticle:R.types.PLANE|R.types.PARTICLE,boxParticle:R.types.BOX|R.types.PARTICLE,convexParticle:R.types.PARTICLE|R.types.CONVEXPOLYHEDRON,cylinderCylinder:R.types.CYLINDER,sphereCylinder:R.types.SPHERE|R.types.CYLINDER,planeCylinder:R.types.PLANE|R.types.CYLINDER,boxCylinder:R.types.BOX|R.types.CYLINDER,convexCylinder:R.types.CONVEXPOLYHEDRON|R.types.CYLINDER,heightfieldCylinder:R.types.HEIGHTFIELD|R.types.CYLINDER,particleCylinder:R.types.PARTICLE|R.types.CYLINDER,sphereTrimesh:R.types.SPHERE|R.types.TRIMESH,planeTrimesh:R.types.PLANE|R.types.TRIMESH};class yd{get[X.sphereSphere](){return this.sphereSphere}get[X.spherePlane](){return this.spherePlane}get[X.boxBox](){return this.boxBox}get[X.sphereBox](){return this.sphereBox}get[X.planeBox](){return this.planeBox}get[X.convexConvex](){return this.convexConvex}get[X.sphereConvex](){return this.sphereConvex}get[X.planeConvex](){return this.planeConvex}get[X.boxConvex](){return this.boxConvex}get[X.sphereHeightfield](){return this.sphereHeightfield}get[X.boxHeightfield](){return this.boxHeightfield}get[X.convexHeightfield](){return this.convexHeightfield}get[X.sphereParticle](){return this.sphereParticle}get[X.planeParticle](){return this.planeParticle}get[X.boxParticle](){return this.boxParticle}get[X.convexParticle](){return this.convexParticle}get[X.cylinderCylinder](){return this.convexConvex}get[X.sphereCylinder](){return this.sphereConvex}get[X.planeCylinder](){return this.planeConvex}get[X.boxCylinder](){return this.boxConvex}get[X.convexCylinder](){return this.convexConvex}get[X.heightfieldCylinder](){return this.heightfieldCylinder}get[X.particleCylinder](){return this.particleCylinder}get[X.sphereTrimesh](){return this.sphereTrimesh}get[X.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new md,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new Jh(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&n.collisionResponse&&s.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=n.material||t.material,l=s.material||e.material;return c&&l&&c.restitution>=0&&l.restitution>=0&&(r.restitution=c.restitution*l.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){const n=t.bi,s=t.bj,i=t.si,o=t.sj,r=this.world,a=this.currentContactMaterial;let c=a.friction;const l=i.material||n.material,d=o.material||s.material;if(l&&d&&l.friction>=0&&d.friction>=0&&(c=l.friction*d.friction),c>0){const h=c*(r.frictionGravity||r.gravity).length();let f=n.invMass+s.invMass;f>0&&(f=1/f);const p=this.frictionEquationPool,x=p.length?p.pop():new Qr(n,s,h*f),g=p.length?p.pop():new Qr(n,s,h*f);return x.bi=g.bi=n,x.bj=g.bj=s,x.minForce=g.minForce=-h*f,x.maxForce=g.maxForce=h*f,x.ri.copy(t.ri),x.rj.copy(t.rj),g.ri.copy(t.ri),g.rj.copy(t.rj),t.ni.tangents(x.t,g.t),x.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),g.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),x.enabled=g.enabled=t.enabled,e.push(x,g),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];Ve.setZero(),an.setZero(),cn.setZero();const i=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==i?(Ve.vadd(e.ni,Ve),an.vadd(e.ri,an),cn.vadd(e.rj,cn)):(Ve.vsub(e.ni,Ve),an.vadd(e.rj,an),cn.vadd(e.ri,cn));const o=1/t;an.scale(o,n.ri),cn.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),Ve.normalize(),Ve.tangents(n.t,s.t)}getContacts(t,e,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const a=xd,c=vd,l=wd,d=gd;for(let h=0,f=t.length;h!==f;h++){const p=t[h],x=e[h];let g=null;p.material&&x.material&&(g=n.getContactMaterial(p.material,x.material)||null);const y=p.type&F.KINEMATIC&&x.type&F.STATIC||p.type&F.STATIC&&x.type&F.KINEMATIC||p.type&F.KINEMATIC&&x.type&F.KINEMATIC;for(let m=0;m<p.shapes.length;m++){p.quaternion.mult(p.shapeOrientations[m],a),p.quaternion.vmult(p.shapeOffsets[m],l),l.vadd(p.position,l);const v=p.shapes[m];for(let b=0;b<x.shapes.length;b++){x.quaternion.mult(x.shapeOrientations[b],c),x.quaternion.vmult(x.shapeOffsets[b],d),d.vadd(x.position,d);const A=x.shapes[b];if(!(v.collisionFilterMask&A.collisionFilterGroup&&A.collisionFilterMask&v.collisionFilterGroup)||l.distanceTo(d)>v.boundingSphereRadius+A.boundingSphereRadius)continue;let S=null;v.material&&A.material&&(S=n.getContactMaterial(v.material,A.material)||null),this.currentContactMaterial=S||g||n.defaultContactMaterial;const T=v.type|A.type,M=this[T];if(M){let B=!1;v.type<A.type?B=M.call(this,v,A,l,d,a,c,p,x,v,A,y):B=M.call(this,A,v,d,l,c,a,x,p,v,A,y),B&&y&&(n.shapeOverlapKeeper.set(v.id,A.id),n.bodyOverlapKeeper.set(p.id,x.id))}}}}}sphereSphere(t,e,n,s,i,o,r,a,c,l,d){if(d)return n.distanceSquared(s)<(t.radius+e.radius)**2;const h=this.createContactEquation(r,a,t,e,c,l);s.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(t.radius,h.ri),h.rj.scale(-e.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(r.position,h.ri),h.rj.vadd(s,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(t,e,n,s,i,o,r,a,c,l,d){const h=this.createContactEquation(r,a,t,e,c,l);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(t.radius,h.ri),n.vsub(s,Vs),h.ni.scale(h.ni.dot(Vs),ta),Vs.vsub(ta,h.rj),-Vs.dot(h.ni)<=t.radius){if(d)return!0;const f=h.ri,p=h.rj;f.vadd(n,f),f.vsub(r.position,f),p.vadd(s,p),p.vsub(a.position,p),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(t,e,n,s,i,o,r,a,c,l,d){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,d)}sphereBox(t,e,n,s,i,o,r,a,c,l,d){const h=this.v3pool,f=$d;n.vsub(s,qs),e.getSideNormals(f,o);const p=t.radius;let x=!1;const g=Xd,y=Yd,m=Zd;let v=null,b=0,A=0,S=0,T=null;for(let L=0,j=f.length;L!==j&&x===!1;L++){const V=Gd;V.copy(f[L]);const k=V.length();V.normalize();const ft=qs.dot(V);if(ft<k+p&&ft>0){const rt=Dd,q=Hd;rt.copy(f[(L+1)%3]),q.copy(f[(L+2)%3]);const Xe=rt.length(),hs=q.length();rt.normalize(),q.normalize();const xi=qs.dot(rt),vi=qs.dot(q);if(xi<Xe&&xi>-Xe&&vi<hs&&vi>-hs){const Xo=Math.abs(ft-k-p);if((T===null||Xo<T)&&(T=Xo,A=xi,S=vi,v=k,g.copy(V),y.copy(rt),m.copy(q),b++,d))return!0}}}if(b){x=!0;const L=this.createContactEquation(r,a,t,e,c,l);g.scale(-p,L.ri),L.ni.copy(g),L.ni.negate(L.ni),g.scale(v,g),y.scale(A,y),g.vadd(y,g),m.scale(S,m),g.vadd(m,L.rj),L.ri.vadd(n,L.ri),L.ri.vsub(r.position,L.ri),L.rj.vadd(s,L.rj),L.rj.vsub(a.position,L.rj),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}let M=h.get();const B=Ud;for(let L=0;L!==2&&!x;L++)for(let j=0;j!==2&&!x;j++)for(let V=0;V!==2&&!x;V++)if(M.set(0,0,0),L?M.vadd(f[0],M):M.vsub(f[0],M),j?M.vadd(f[1],M):M.vsub(f[1],M),V?M.vadd(f[2],M):M.vsub(f[2],M),s.vadd(M,B),B.vsub(n,B),B.lengthSquared()<p*p){if(d)return!0;x=!0;const k=this.createContactEquation(r,a,t,e,c,l);k.ri.copy(B),k.ri.normalize(),k.ni.copy(k.ri),k.ri.scale(p,k.ri),k.rj.copy(M),k.ri.vadd(n,k.ri),k.ri.vsub(r.position,k.ri),k.rj.vadd(s,k.rj),k.rj.vsub(a.position,k.rj),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult)}h.release(M),M=null;const _=h.get(),z=h.get(),C=h.get(),E=h.get(),P=h.get(),I=f.length;for(let L=0;L!==I&&!x;L++)for(let j=0;j!==I&&!x;j++)if(L%3!==j%3){f[j].cross(f[L],_),_.normalize(),f[L].vadd(f[j],z),C.copy(n),C.vsub(z,C),C.vsub(s,C);const V=C.dot(_);_.scale(V,E);let k=0;for(;k===L%3||k===j%3;)k++;P.copy(n),P.vsub(E,P),P.vsub(z,P),P.vsub(s,P);const ft=Math.abs(V),rt=P.length();if(ft<f[k].length()&&rt<p){if(d)return!0;x=!0;const q=this.createContactEquation(r,a,t,e,c,l);z.vadd(E,q.rj),q.rj.copy(q.rj),P.negate(q.ni),q.ni.normalize(),q.ri.copy(q.rj),q.ri.vadd(s,q.ri),q.ri.vsub(n,q.ri),q.ri.normalize(),q.ri.scale(p,q.ri),q.ri.vadd(n,q.ri),q.ri.vsub(r.position,q.ri),q.rj.vadd(s,q.rj),q.rj.vsub(a.position,q.rj),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult)}}h.release(_,z,C,E,P)}planeBox(t,e,n,s,i,o,r,a,c,l,d){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,d)}convexConvex(t,e,n,s,i,o,r,a,c,l,d,h,f){const p=df;if(!(n.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,n,i,s,o,p,h,f)){const x=[],g=ff;t.clipAgainstHull(n,i,e,s,o,p,-100,100,x);let y=0;for(let m=0;m!==x.length;m++){if(d)return!0;const v=this.createContactEquation(r,a,t,e,c,l),b=v.ri,A=v.rj;p.negate(v.ni),x[m].normal.negate(g),g.scale(x[m].depth,g),x[m].point.vadd(g,b),A.copy(x[m].point),b.vsub(n,b),A.vsub(s,A),b.vadd(n,b),b.vsub(r.position,b),A.vadd(s,A),A.vsub(a.position,A),this.result.push(v),y++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(v,this.frictionResult)}this.enableFrictionReduction&&y&&this.createFrictionFromAverage(y)}}sphereConvex(t,e,n,s,i,o,r,a,c,l,d){const h=this.v3pool;n.vsub(s,Kd);const f=e.faceNormals,p=e.faces,x=e.vertices,g=t.radius;let y=!1;for(let m=0;m!==x.length;m++){const v=x[m],b=ef;o.vmult(v,b),s.vadd(b,b);const A=tf;if(b.vsub(n,A),A.lengthSquared()<g*g){if(d)return!0;y=!0;const S=this.createContactEquation(r,a,t,e,c,l);S.ri.copy(A),S.ri.normalize(),S.ni.copy(S.ri),S.ri.scale(g,S.ri),b.vsub(s,S.rj),S.ri.vadd(n,S.ri),S.ri.vsub(r.position,S.ri),S.rj.vadd(s,S.rj),S.rj.vsub(a.position,S.rj),this.result.push(S),this.createFrictionEquationsFromContact(S,this.frictionResult);return}}for(let m=0,v=p.length;m!==v&&y===!1;m++){const b=f[m],A=p[m],S=nf;o.vmult(b,S);const T=sf;o.vmult(x[A[0]],T),T.vadd(s,T);const M=of;S.scale(-g,M),n.vadd(M,M);const B=rf;M.vsub(T,B);const _=B.dot(S),z=af;if(n.vsub(T,z),_<0&&z.dot(S)>0){const C=[];for(let E=0,P=A.length;E!==P;E++){const I=h.get();o.vmult(x[A[E]],I),s.vadd(I,I),C.push(I)}if(Wd(C,S,n)){if(d)return!0;y=!0;const E=this.createContactEquation(r,a,t,e,c,l);S.scale(-g,E.ri),S.negate(E.ni);const P=h.get();S.scale(-_,P);const I=h.get();S.scale(-g,I),n.vsub(s,E.rj),E.rj.vadd(I,E.rj),E.rj.vadd(P,E.rj),E.rj.vadd(s,E.rj),E.rj.vsub(a.position,E.rj),E.ri.vadd(n,E.ri),E.ri.vsub(r.position,E.ri),h.release(P),h.release(I),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult);for(let L=0,j=C.length;L!==j;L++)h.release(C[L]);return}else for(let E=0;E!==A.length;E++){const P=h.get(),I=h.get();o.vmult(x[A[(E+1)%A.length]],P),o.vmult(x[A[(E+2)%A.length]],I),s.vadd(P,P),s.vadd(I,I);const L=Jd;I.vsub(P,L);const j=Qd;L.unit(j);const V=h.get(),k=h.get();n.vsub(P,k);const ft=k.dot(j);j.scale(ft,V),V.vadd(P,V);const rt=h.get();if(V.vsub(n,rt),ft>0&&ft*ft<L.lengthSquared()&&rt.lengthSquared()<g*g){if(d)return!0;const q=this.createContactEquation(r,a,t,e,c,l);V.vsub(s,q.rj),V.vsub(n,q.ni),q.ni.normalize(),q.ni.scale(g,q.ri),q.rj.vadd(s,q.rj),q.rj.vsub(a.position,q.rj),q.ri.vadd(n,q.ri),q.ri.vsub(r.position,q.ri),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult);for(let Xe=0,hs=C.length;Xe!==hs;Xe++)h.release(C[Xe]);h.release(P),h.release(I),h.release(V),h.release(rt),h.release(k);return}h.release(P),h.release(I),h.release(V),h.release(rt),h.release(k)}for(let E=0,P=C.length;E!==P;E++)h.release(C[E])}}}planeConvex(t,e,n,s,i,o,r,a,c,l,d){const h=cf,f=lf;f.set(0,0,1),i.vmult(f,f);let p=0;const x=uf;for(let g=0;g!==e.vertices.length;g++)if(h.copy(e.vertices[g]),o.vmult(h,h),s.vadd(h,h),h.vsub(n,x),f.dot(x)<=0){if(d)return!0;const m=this.createContactEquation(r,a,t,e,c,l),v=hf;f.scale(f.dot(x),v),h.vsub(v,v),v.vsub(n,m.ri),m.ni.copy(f),h.vsub(s,m.rj),m.ri.vadd(n,m.ri),m.ri.vsub(r.position,m.ri),m.rj.vadd(s,m.rj),m.rj.vsub(a.position,m.rj),this.result.push(m),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(m,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(t,e,n,s,i,o,r,a,c,l,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,d)}sphereHeightfield(t,e,n,s,i,o,r,a,c,l,d){const h=e.data,f=t.radius,p=e.elementSize,x=Ef,g=Tf;D.pointToLocalFrame(s,o,n,g);let y=Math.floor((g.x-f)/p)-1,m=Math.ceil((g.x+f)/p)+1,v=Math.floor((g.y-f)/p)-1,b=Math.ceil((g.y+f)/p)+1;if(m<0||b<0||y>h.length||v>h[0].length)return;y<0&&(y=0),m<0&&(m=0),v<0&&(v=0),b<0&&(b=0),y>=h.length&&(y=h.length-1),m>=h.length&&(m=h.length-1),b>=h[0].length&&(b=h[0].length-1),v>=h[0].length&&(v=h[0].length-1);const A=[];e.getRectMinMax(y,v,m,b,A);const S=A[0],T=A[1];if(g.z-f>T||g.z+f<S)return;const M=this.result;for(let B=y;B<m;B++)for(let _=v;_<b;_++){const z=M.length;let C=!1;if(e.getConvexTrianglePillar(B,_,!1),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(C=this.sphereConvex(t,e.pillarConvex,n,x,i,o,r,a,t,e,d)),d&&C||(e.getConvexTrianglePillar(B,_,!0),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(C=this.sphereConvex(t,e.pillarConvex,n,x,i,o,r,a,t,e,d)),d&&C))return!0;if(M.length-z>2)return}}boxHeightfield(t,e,n,s,i,o,r,a,c,l,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,d)}convexHeightfield(t,e,n,s,i,o,r,a,c,l,d){const h=e.data,f=e.elementSize,p=t.boundingSphereRadius,x=Af,g=Sf,y=bf;D.pointToLocalFrame(s,o,n,y);let m=Math.floor((y.x-p)/f)-1,v=Math.ceil((y.x+p)/f)+1,b=Math.floor((y.y-p)/f)-1,A=Math.ceil((y.y+p)/f)+1;if(v<0||A<0||m>h.length||b>h[0].length)return;m<0&&(m=0),v<0&&(v=0),b<0&&(b=0),A<0&&(A=0),m>=h.length&&(m=h.length-1),v>=h.length&&(v=h.length-1),A>=h[0].length&&(A=h[0].length-1),b>=h[0].length&&(b=h[0].length-1);const S=[];e.getRectMinMax(m,b,v,A,S);const T=S[0],M=S[1];if(!(y.z-p>M||y.z+p<T))for(let B=m;B<v;B++)for(let _=b;_<A;_++){let z=!1;if(e.getConvexTrianglePillar(B,_,!1),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(z=this.convexConvex(t,e.pillarConvex,n,x,i,o,r,a,null,null,d,g,null)),d&&z||(e.getConvexTrianglePillar(B,_,!0),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(z=this.convexConvex(t,e.pillarConvex,n,x,i,o,r,a,null,null,d,g,null)),d&&z))return!0}}sphereParticle(t,e,n,s,i,o,r,a,c,l,d){const h=wf;if(h.set(0,0,1),s.vsub(n,h),h.lengthSquared()<=t.radius*t.radius){if(d)return!0;const p=this.createContactEquation(a,r,e,t,c,l);h.normalize(),p.rj.copy(h),p.rj.scale(t.radius,p.rj),p.ni.copy(h),p.ni.negate(p.ni),p.ri.set(0,0,0),this.result.push(p),this.createFrictionEquationsFromContact(p,this.frictionResult)}}planeParticle(t,e,n,s,i,o,r,a,c,l,d){const h=pf;h.set(0,0,1),r.quaternion.vmult(h,h);const f=mf;if(s.vsub(r.position,f),h.dot(f)<=0){if(d)return!0;const x=this.createContactEquation(a,r,e,t,c,l);x.ni.copy(h),x.ni.negate(x.ni),x.ri.set(0,0,0);const g=yf;h.scale(h.dot(s),g),s.vsub(g,g),x.rj.copy(g),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}}boxParticle(t,e,n,s,i,o,r,a,c,l,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,d)}convexParticle(t,e,n,s,i,o,r,a,c,l,d){let h=-1;const f=xf,p=vf;let x=null;const g=gf;if(g.copy(s),g.vsub(n,g),i.conjugate(ea),ea.vmult(g,g),t.pointIsInside(g)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(n,i),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(i);for(let y=0,m=t.faces.length;y!==m;y++){const v=[t.worldVertices[t.faces[y][0]]],b=t.worldFaceNormals[y];s.vsub(v[0],na);const A=-b.dot(na);if(x===null||Math.abs(A)<Math.abs(x)){if(d)return!0;x=A,h=y,f.copy(b)}}if(h!==-1){const y=this.createContactEquation(a,r,e,t,c,l);f.scale(x,p),p.vadd(s,p),p.vsub(n,p),y.rj.copy(p),f.negate(y.ni),y.ri.set(0,0,0);const m=y.ri,v=y.rj;m.vadd(s,m),m.vsub(a.position,m),v.vadd(n,v),v.vsub(r.position,v),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,n,s,i,o,r,a,c,l,d){return this.convexHeightfield(e,t,s,n,o,i,a,r,c,l,d)}particleCylinder(t,e,n,s,i,o,r,a,c,l,d){return this.convexParticle(e,t,s,n,o,i,a,r,c,l,d)}sphereTrimesh(t,e,n,s,i,o,r,a,c,l,d){const h=_d,f=Cd,p=Pd,x=zd,g=Id,y=Ld,m=Vd,v=Bd,b=Ed,A=qd;D.pointToLocalFrame(s,o,n,g);const S=t.radius;m.lowerBound.set(g.x-S,g.y-S,g.z-S),m.upperBound.set(g.x+S,g.y+S,g.z+S),e.getTrianglesInAABB(m,A);const T=Md,M=t.radius*t.radius;for(let E=0;E<A.length;E++)for(let P=0;P<3;P++)if(e.getVertex(e.indices[A[E]*3+P],T),T.vsub(g,b),b.lengthSquared()<=M){if(v.copy(T),D.pointToWorldFrame(s,o,v,T),T.vsub(n,b),d)return!0;let I=this.createContactEquation(r,a,t,e,c,l);I.ni.copy(b),I.ni.normalize(),I.ri.copy(I.ni),I.ri.scale(t.radius,I.ri),I.ri.vadd(n,I.ri),I.ri.vsub(r.position,I.ri),I.rj.copy(T),I.rj.vsub(a.position,I.rj),this.result.push(I),this.createFrictionEquationsFromContact(I,this.frictionResult)}for(let E=0;E<A.length;E++)for(let P=0;P<3;P++){e.getVertex(e.indices[A[E]*3+P],h),e.getVertex(e.indices[A[E]*3+(P+1)%3],f),f.vsub(h,p),g.vsub(f,y);const I=y.dot(p);g.vsub(h,y);let L=y.dot(p);if(L>0&&I<0&&(g.vsub(h,y),x.copy(p),x.normalize(),L=y.dot(x),x.scale(L,y),y.vadd(h,y),y.distanceTo(g)<t.radius)){if(d)return!0;const V=this.createContactEquation(r,a,t,e,c,l);y.vsub(g,V.ni),V.ni.normalize(),V.ni.scale(t.radius,V.ri),V.ri.vadd(n,V.ri),V.ri.vsub(r.position,V.ri),D.pointToWorldFrame(s,o,y,y),y.vsub(a.position,V.rj),D.vectorToWorldFrame(o,V.ni,V.ni),D.vectorToWorldFrame(o,V.ri,V.ri),this.result.push(V),this.createFrictionEquationsFromContact(V,this.frictionResult)}}const B=Nd,_=Fd,z=Rd,C=Td;for(let E=0,P=A.length;E!==P;E++){e.getTriangleVertices(A[E],B,_,z),e.getNormal(A[E],C),g.vsub(B,y);let I=y.dot(C);if(C.scale(I,y),g.vsub(y,y),I=y.distanceTo(g),Q.pointInTriangle(y,B,_,z)&&I<t.radius){if(d)return!0;let L=this.createContactEquation(r,a,t,e,c,l);y.vsub(g,L.ni),L.ni.normalize(),L.ni.scale(t.radius,L.ri),L.ri.vadd(n,L.ri),L.ri.vsub(r.position,L.ri),D.pointToWorldFrame(s,o,y,y),y.vsub(a.position,L.rj),D.vectorToWorldFrame(o,L.ni,L.ni),D.vectorToWorldFrame(o,L.ri,L.ri),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}}A.length=0}planeTrimesh(t,e,n,s,i,o,r,a,c,l,d){const h=new w,f=bd;f.set(0,0,1),i.vmult(f,f);for(let p=0;p<e.vertices.length/3;p++){e.getVertex(p,h);const x=new w;x.copy(h),D.pointToWorldFrame(s,o,x,h);const g=Ad;if(h.vsub(n,g),f.dot(g)<=0){if(d)return!0;const m=this.createContactEquation(r,a,t,e,c,l);m.ni.copy(f);const v=Sd;f.scale(g.dot(f),v),h.vsub(v,v),m.ri.copy(v),m.ri.vsub(r.position,m.ri),m.rj.copy(h),m.rj.vsub(a.position,m.rj),this.result.push(m),this.createFrictionEquationsFromContact(m,this.frictionResult)}}}}const Ve=new w,an=new w,cn=new w,wd=new w,gd=new w,xd=new tt,vd=new tt,bd=new w,Ad=new w,Sd=new w,Td=new w,Ed=new w;new w;const Md=new w,Bd=new w,_d=new w,Cd=new w,Pd=new w,zd=new w,Id=new w,Ld=new w,Nd=new w,Fd=new w,Rd=new w,Vd=new St,qd=[],Vs=new w,ta=new w,kd=new w,jd=new w,Od=new w;function Wd(u,t,e){let n=null;const s=u.length;for(let i=0;i!==s;i++){const o=u[i],r=kd;u[(i+1)%s].vsub(o,r);const a=jd;r.cross(t,a);const c=Od;e.vsub(o,c);const l=a.dot(c);if(n===null||l>0&&n===!0||l<=0&&n===!1){n===null&&(n=l>0);continue}else return!1}return!0}const qs=new w,Gd=new w,Dd=new w,Hd=new w,$d=[new w,new w,new w,new w,new w,new w],Ud=new w,Xd=new w,Yd=new w,Zd=new w,Kd=new w,Jd=new w,Qd=new w,tf=new w,ef=new w,nf=new w,sf=new w,of=new w,rf=new w,af=new w;new w;new w;const cf=new w,lf=new w,uf=new w,hf=new w,df=new w,ff=new w,pf=new w,mf=new w,yf=new w,wf=new w,ea=new tt,gf=new w;new w;const xf=new w,na=new w,vf=new w,bf=new w,Af=new w,Sf=[0],Tf=new w,Ef=new w;class sa{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const n=e;e=t,t=n}return t<<16|e}set(t,e){const n=this.getKey(t,e),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let a=0;a<i;a++){let c=!1;const l=n[a];for(;l>s[r];)r++;c=l===s[r],c||ia(t,l)}r=0;for(let a=0;a<o;a++){let c=!1;const l=s[a];for(;l>n[r];)r++;c=n[r]===l,c||ia(e,l)}}}function ia(u,t){u.push((t&4294901760)>>16,t&65535)}const Qi=(u,t)=>u<t?`${u}-${t}`:`${t}-${u}`;class Mf{constructor(){this.data={keys:[]}}get(t,e){const n=Qi(t,e);return this.data[n]}set(t,e,n){const s=Qi(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=n}delete(t,e){const n=Qi(t,e),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const n=e.pop();delete t[n]}}}class Bf extends La{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new w,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new w,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new Lh,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new ud,this.constraints=[],this.narrowphase=new yd(this),this.collisionMatrix=new Gr,this.collisionMatrixPrevious=new Gr,this.bodyOverlapKeeper=new sa,this.shapeOverlapKeeper=new sa,this.contactmaterials=[],this.contactMaterialTable=new Mf,this.defaultMaterial=new wi("default"),this.defaultContactMaterial=new yi(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,n){n instanceof Zs?this.raycastClosest(t,e,{skipBackfaces:!0},n):this.raycastAll(t,e,{skipBackfaces:!0},n)}raycastAll(t,e,n,s){return n===void 0&&(n={}),n.mode=Q.ALL,n.from=t,n.to=e,n.callback=s,to.intersectWorld(this,n)}raycastAny(t,e,n,s){return n===void 0&&(n={}),n.mode=Q.ANY,n.from=t,n.to=e,n.result=s,to.intersectWorld(this,n)}raycastClosest(t,e,n,s){return n===void 0&&(n={}),n.mode=Q.CLOSEST,n.from=t,n.to=e,n.result=s,to.intersectWorld(this,n)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof F&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,n=this.bodies,s=n.indexOf(t);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const n=st.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const s=n-this.lastCallTime;this.step(t,s,e)}this.lastCallTime=n}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const s=st.now();let i=0;for(;this.accumulator>=t&&i<n&&(this.internalStep(t),this.accumulator-=t,i++,!(st.now()-s>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,n=If,s=Lf,i=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,c=this.doProfiling,l=this.profile,d=F.DYNAMIC;let h=-1/0;const f=this.constraints,p=zf;a.length();const x=a.x,g=a.y,y=a.z;let m=0;for(c&&(h=st.now()),m=0;m!==i;m++){const E=o[m];if(E.type===d){const P=E.force,I=E.mass;P.x+=I*x,P.y+=I*g,P.z+=I*y}}for(let E=0,P=this.subsystems.length;E!==P;E++)this.subsystems[E].update();c&&(h=st.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),c&&(l.broadphase=st.now()-h);let v=f.length;for(m=0;m!==v;m++){const E=f[m];if(!E.collideConnected)for(let P=n.length-1;P>=0;P-=1)(E.bodyA===n[P]&&E.bodyB===s[P]||E.bodyB===n[P]&&E.bodyA===s[P])&&(n.splice(P,1),s.splice(P,1))}this.collisionMatrixTick(),c&&(h=st.now());const b=Pf,A=e.length;for(m=0;m!==A;m++)b.push(e[m]);e.length=0;const S=this.frictionEquations.length;for(m=0;m!==S;m++)p.push(this.frictionEquations[m]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,e,b,this.frictionEquations,p),c&&(l.narrowphase=st.now()-h),c&&(h=st.now()),m=0;m<this.frictionEquations.length;m++)r.addEquation(this.frictionEquations[m]);const T=e.length;for(let E=0;E!==T;E++){const P=e[E],I=P.bi,L=P.bj,j=P.si,V=P.sj;let k;if(I.material&&L.material?k=this.getContactMaterial(I.material,L.material)||this.defaultContactMaterial:k=this.defaultContactMaterial,k.friction,I.material&&L.material&&(I.material.friction>=0&&L.material.friction>=0&&I.material.friction*L.material.friction,I.material.restitution>=0&&L.material.restitution>=0&&(P.restitution=I.material.restitution*L.material.restitution)),r.addEquation(P),I.allowSleep&&I.type===F.DYNAMIC&&I.sleepState===F.SLEEPING&&L.sleepState===F.AWAKE&&L.type!==F.STATIC){const ft=L.velocity.lengthSquared()+L.angularVelocity.lengthSquared(),rt=L.sleepSpeedLimit**2;ft>=rt*2&&(I.wakeUpAfterNarrowphase=!0)}if(L.allowSleep&&L.type===F.DYNAMIC&&L.sleepState===F.SLEEPING&&I.sleepState===F.AWAKE&&I.type!==F.STATIC){const ft=I.velocity.lengthSquared()+I.angularVelocity.lengthSquared(),rt=I.sleepSpeedLimit**2;ft>=rt*2&&(L.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(I,L,!0),this.collisionMatrixPrevious.get(I,L)||(kn.body=L,kn.contact=P,I.dispatchEvent(kn),kn.body=I,L.dispatchEvent(kn)),this.bodyOverlapKeeper.set(I.id,L.id),this.shapeOverlapKeeper.set(j.id,V.id)}for(this.emitContactEvents(),c&&(l.makeContactConstraints=st.now()-h,h=st.now()),m=0;m!==i;m++){const E=o[m];E.wakeUpAfterNarrowphase&&(E.wakeUp(),E.wakeUpAfterNarrowphase=!1)}for(v=f.length,m=0;m!==v;m++){const E=f[m];E.update();for(let P=0,I=E.equations.length;P!==I;P++){const L=E.equations[P];r.addEquation(L)}}r.solve(t,this),c&&(l.solve=st.now()-h),r.removeAllEquations();const M=Math.pow;for(m=0;m!==i;m++){const E=o[m];if(E.type&d){const P=M(1-E.linearDamping,t),I=E.velocity;I.scale(P,I);const L=E.angularVelocity;if(L){const j=M(1-E.angularDamping,t);L.scale(j,L)}}}this.dispatchEvent(Cf),c&&(h=st.now());const _=this.stepnumber%(this.quatNormalizeSkip+1)===0,z=this.quatNormalizeFast;for(m=0;m!==i;m++)o[m].integrate(t,_,z);this.clearForces(),this.broadphase.dirty=!0,c&&(l.integrate=st.now()-h),this.stepnumber+=1,this.dispatchEvent(_f);let C=!0;if(this.allowSleep)for(C=!1,m=0;m!==i;m++){const E=o[m];E.sleepTick(this.time),E.sleepState!==F.SLEEPING&&(C=!0)}this.hasActiveBodies=C}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(ae,ce),t){for(let i=0,o=ae.length;i<o;i+=2)jn.bodyA=this.getBodyById(ae[i]),jn.bodyB=this.getBodyById(ae[i+1]),this.dispatchEvent(jn);jn.bodyA=jn.bodyB=null}if(e){for(let i=0,o=ce.length;i<o;i+=2)On.bodyA=this.getBodyById(ce[i]),On.bodyB=this.getBodyById(ce[i+1]),this.dispatchEvent(On);On.bodyA=On.bodyB=null}ae.length=ce.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(ae,ce),n){for(let i=0,o=ae.length;i<o;i+=2){const r=this.getShapeById(ae[i]),a=this.getShapeById(ae[i+1]);le.shapeA=r,le.shapeB=a,r&&(le.bodyA=r.body),a&&(le.bodyB=a.body),this.dispatchEvent(le)}le.bodyA=le.bodyB=le.shapeA=le.shapeB=null}if(s){for(let i=0,o=ce.length;i<o;i+=2){const r=this.getShapeById(ce[i]),a=this.getShapeById(ce[i+1]);ue.shapeA=r,ue.shapeB=a,r&&(ue.bodyA=r.body),a&&(ue.bodyB=a.body),this.dispatchEvent(ue)}ue.bodyA=ue.bodyB=ue.shapeA=ue.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let n=0;n!==e;n++){const s=t[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new St;const to=new Q,st=globalThis.performance||{};if(!st.now){let u=Date.now();st.timing&&st.timing.navigationStart&&(u=st.timing.navigationStart),st.now=()=>Date.now()-u}new w;const _f={type:"postStep"},Cf={type:"preStep"},kn={type:F.COLLIDE_EVENT_NAME,body:null,contact:null},Pf=[],zf=[],If=[],Lf=[],ae=[],ce=[],jn={type:"beginContact",bodyA:null,bodyB:null},On={type:"endContact",bodyA:null,bodyB:null},le={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},ue={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},jo=new Bf;jo.gravity.set(0,-9.82,0);jo.allowSleep=!0;const Oa=Dt.frameWidthInner/2+.1,Wa=.8,Oo=Wa-.04,Nf=.03,Ga=Math.ceil(Dt.frameHeightInner/Oo),{floorXLength:Ff,floorZLength:Rf,ny:Vf}=G,Wo=new fe;Wo.position.set(-Ff/2+Oa/2+3.5,-Vf+Oo*Ga+.5,-Rf/2-.3);const qf=new O(Oa,Nf,Wa,2,.4),kf=new vt({wireframe:At,roughness:.6,metalness:.8}),at=[];for(let u=0;u<Ga;u++){const t=new $(qf,kf);t.position.set(0,-u*Oo,0),t.receiveShadow=!0,t.castShadow=!0,t.rotation.set(Qt(15),0,0),at.push(t)}Wo.add(...at);H.add(Wo);const ks=1,oa=.15;let pn=!1,mn=!1,yn=!1,wn=!1;const jf=()=>{pn=!0,mn=!1,yn=!1,wn=!1},Of=()=>{mn=!0,pn=!1,yn=!1,wn=!1},Wf=()=>{yn=!0,pn=!1,mn=!1,wn=!1},Gf=()=>{wn=!0,pn=!1,mn=!1,yn=!1},Df=u=>{pn?at[0].rotation.x>Qt(-88)?at.forEach(t=>{t.rotation.x-=u*ks}):pn=!1:mn?at[0].rotation.x<Qt(15)?at.forEach(t=>{t.rotation.x+=u*ks}):mn=!1:yn?at[0].rotation.x>Qt(2)?at.forEach(t=>{t.rotation.x-=u*ks}):at[0].rotation.x<Qt(-2)?at.forEach(t=>{t.rotation.x+=u*ks}):at[at.length-1].position.y<-1?at.forEach((t,e)=>{t.position.y+=u*oa*e}):(console.log("lifted"),yn=!1):wn&&(at[at.length-1].position.y>-21.27?at.forEach((t,e)=>{t.position.y-=u*oa*e}):(console.log("dropped"),wn=!1))},uo=Dt.frameWidthInner/2+.1,Da=.8,Go=Da-.04,Hf=.03,Ha=Math.ceil(Dt.frameHeightInner/Go),{floorXLength:$f,floorZLength:Uf,ny:Xf}=G,Do=new fe;Do.position.set(-$f/2+uo+uo/2+3.6,-Xf+Go*Ha+.5,-Uf/2-.3);const Yf=new O(uo,Hf,Da,2,.4),Zf=new vt({wireframe:At,roughness:.6,metalness:.8}),ct=[];for(let u=0;u<Ha;u++){const t=new $(Yf,Zf);t.position.set(0,-u*Go,0),t.receiveShadow=!0,t.castShadow=!0,t.rotation.set(Qt(15),0,0),ct.push(t)}Do.add(...ct);H.add(Do);const js=1,ra=.15;let gn=!1,xn=!1,vn=!1,bn=!1;const Kf=()=>{gn=!0,xn=!1,vn=!1,bn=!1},Jf=()=>{xn=!0,gn=!1,vn=!1,bn=!1},Qf=()=>{vn=!0,gn=!1,xn=!1,bn=!1},tp=()=>{bn=!0,gn=!1,xn=!1,vn=!1},ep=u=>{gn?ct[0].rotation.x>Qt(-88)?ct.forEach(t=>{t.rotation.x-=u*js}):gn=!1:xn?ct[0].rotation.x<Qt(15)?ct.forEach(t=>{t.rotation.x+=u*js}):xn=!1:vn?ct[0].rotation.x>Qt(2)?ct.forEach(t=>{t.rotation.x-=u*js}):ct[0].rotation.x<Qt(-2)?ct.forEach(t=>{t.rotation.x+=u*js}):ct[ct.length-1].position.y<-1?ct.forEach((t,e)=>{t.position.y+=u*ra*e}):(console.log("lifted"),vn=!1):bn&&(ct[ct.length-1].position.y>-21.27?ct.forEach((t,e)=>{t.position.y-=u*ra*e}):(console.log("dropped"),bn=!1))},np=new jc,$a=()=>{Qo.begin(),$t.clear(),Fo.update(),Tn.update(),jo.fixedStep();const u=np.getDelta();Ti.animating&&Ti.update(u),Df(u),ep(u),$t.render(H,hn),Ti.render($t),Qo.end(),requestAnimationFrame($a)},Ua=new Oc("#ffffff",.2);H.add(Ua);const ht=new Wc("#ffffff",2);ht.position.set(20,20,-30);ht.castShadow=!0;ht.shadow.mapSize.width=1024;ht.shadow.mapSize.height=1024;ht.shadow.camera.near=1;ht.shadow.camera.far=200;ht.shadow.camera.top=50;ht.shadow.camera.right=50;ht.shadow.camera.bottom=-50;ht.shadow.camera.left=-50;ht.shadow.normalBias=.2;H.add(ht);const Xa=new Gc(ht,10);H.add(Xa);Xa.visible=!1;const Ya=new Sn(ht.shadow.camera);H.add(Ya);Ya.visible=!1;const se=new Dc(16777215,30,40,1);se.position.set(G.wallThickness,2,G.wallThickness);se.castShadow=!0;se.shadow.camera.near=1;se.shadow.camera.far=30;se.shadow.normalBias=.7;se.shadow.radius=5;H.add(se);const Za=new Hc(se,10);H.add(Za);Za.visible=!1;const Ka=new Sn(se.shadow.camera);H.add(Ka);Ka.visible=!1;const ye=new si(16777215,30,60,Math.PI*.11,.6,1);ye.position.set(G.floorXLength/2-3,6,-6);ye.target.position.set(G.floorXLength/2-3,-G.ny,-6);ye.castShadow=!0;ye.shadow.camera.near=1;ye.shadow.camera.far=30;H.add(ye);const Ja=new ii(ye,16776960);H.add(Ja);Ja.visible=!1;const Qa=new Sn(ye.shadow.camera);H.add(Qa);Qa.visible=!1;const we=new si(16777215,30,60,Math.PI*.11,.6,1);we.position.set(G.floorXLength/2-3,6,6);we.target.position.set(G.floorXLength/2-3,-G.ny,6);we.castShadow=!0;we.shadow.camera.near=1;we.shadow.camera.far=30;H.add(we);const tc=new ii(we,16776960);H.add(tc);tc.visible=!1;const ec=new Sn(we.shadow.camera);H.add(ec);ec.visible=!1;const ge=new si(16777215,30,60,Math.PI*.19,.6,1.5);ge.position.set(-(G.floorXLength/2-1),6.8,6);ge.target.position.set(-(G.floorXLength/2),-G.ny,6);ge.castShadow=!0;ge.shadow.camera.near=1;ge.shadow.camera.far=30;H.add(ge);const nc=new ii(ge,16776960);H.add(nc);nc.visible=!1;const sc=new Sn(ge.shadow.camera);H.add(sc);sc.visible=!1;const xe=new si(16777215,30,60,Math.PI*.19,.6,1.5);xe.position.set(-(G.floorXLength/2-1),6.8,-6);xe.target.position.set(-(G.floorXLength/2),-G.ny,-6);xe.castShadow=!0;xe.shadow.camera.near=1;xe.shadow.camera.far=30;H.add(xe);const ic=new ii(xe,16776960);H.add(ic);ic.visible=!1;const oc=new Sn(xe.shadow.camera);H.add(oc);oc.visible=!1;const rc=[ye,we,ge,xe],sp=()=>{rc.forEach(u=>{u.visible=!1})},ip=()=>{rc.forEach(u=>{u.visible=!0})},{floorXLength:op,floorZLength:rp,ny:ap}=G,Ho=new $c(42);Ho.position.set(-op/2,-ap,-rp/2);Ho.visible=!1;H.add(Ho);const{floorXLength:cp,floorZLength:lp,ny:up}=G,$o=new fe;$o.position.set(-cp/2,-up,-lp/2);const hp=Ie({title:"Sofa"}),dp=new ua(hp);dp.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/ikeaSofa.obj",u=>{u.scale.set(10,10,10),u.rotation.y=-Math.PI/2,u.position.set(33,0,15);const e=u.children[0],n=u.children[1];aa(e),aa(n);const s=Ie({title:"Sofa texture",onLoad:()=>{const f=new vt({map:o,normalMap:r,aoMap:a,roughnessMap:c,wireframe:At});e.material=f;const p=new vt({map:l,normalMap:d,aoMap:h,color:5093036,wireframe:At});n.material=p,$o.add(u)}}),i=new An(s),o=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Color.jpg");o.colorSpace=Un,o.wrapS=W,o.wrapT=W;const r=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_NormalGL.jpg");r.wrapS=W,r.wrapT=W;const a=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_AmbientOcclusion.jpg");a.wrapS=W,a.wrapT=W;const c=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Roughness.jpg");c.wrapS=W,c.wrapT=W;const l=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_b.png");l.colorSpace=Un,l.wrapS=W,l.wrapT=W;const d=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_n.png");d.wrapS=W,d.wrapT=W;const h=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_o.png");h.wrapS=W,h.wrapT=W});const aa=u=>{u.castShadow=!0,u.receiveShadow=!0};H.add($o);const{floorXLength:fp,floorZLength:pp,ny:mp}=G,Uo=new fe;Uo.position.set(-fp/2,-mp,-pp/2);const yp=new O(22,.2,26,2,.5),wp=Ie({title:"Rug Texture"}),us=new An(wp),rs=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_COLOR2.png");rs.colorSpace=Un;const Ks=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_DISP.png"),Js=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_NRM.jpg"),Qs=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_OCC.jpg"),ti=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_ROUGH.jpg");rs.wrapS=rs.wrapT=Ks.wrapS=Ks.wrapT=Js.wrapS=Js.wrapT=Qs.wrapS=Qs.wrapT=ti.wrapS=ti.wrapT=W;const ne=.44;rs.repeat.set(ne,ne);Ks.repeat.set(ne,ne);Js.repeat.set(ne,ne);Qs.repeat.set(ne,ne);ti.repeat.set(ne,ne);const ac=new vt({wireframe:At,map:rs,displacementMap:Ks,displacementScale:.005,normalMap:Js,aoMap:Qs,roughnessMap:ti});ac.normalScale.set(1.2,1.2);const gi=new $(yp,ac);gi.position.set(28,.01,15);gi.receiveShadow=!0;gi.castShadow=!0;Uo.add(gi);H.add(Uo);const yt=18.2,Tt=18.2,wt=3.3,U=.37,ot=.24,Xt=3.3,Et=3,Mt=.05,gp={shelfWidth:yt,shelfHeight:Tt,shelfDepth:wt,shelfBorderBoardThickness:U,shelfBoardThickness:ot,shelfInnerWidth:Xt,roundSegments:Et,roundRadius:Mt},{floorXLength:xp,floorZLength:vp,ny:bp}=G,dt=new fe;dt.position.set(-xp/2+wt/2,-bp+U/2+.1,-vp/2+yt/2+2);const nt=new vt({wireframe:At,map:Xn,normalMap:Yn,aoMap:Zn,roughnessMap:Kn,metalnessMap:Jn,displacementMap:Qn,displacementScale:.006}),cc=new $(new O(wt,Tt,U,Et,Mt),nt);cc.position.set(0,Tt/2-U/2,-yt/2+U/2);const Ap=new $(new O(wt,U,yt,Et,Mt),nt),lc=new $(new O(wt,ot,yt,Et,Mt),nt);lc.position.set(0,U+Xt,0);const uc=new $(new O(wt,ot,yt,Et,Mt),nt);uc.position.set(0,U+Xt*2+ot,0);const hc=new $(new O(wt,ot,yt,Et,Mt),nt);hc.position.set(0,U+Xt*3+ot*2,0);const dc=new $(new O(wt,ot,yt,Et,Mt),nt);dc.position.set(0,U+Xt*4+ot*3,0);const fc=new $(new O(wt,U,yt,Et,Mt),nt);fc.position.set(0,U+Xt*5+ot*4,0);const pc=new $(new O(wt,Tt,ot,Et,Mt),nt);pc.position.set(0,Tt/2-U/2,-yt/2+U/2+U+Xt);const mc=new $(new O(wt,Tt,ot,Et,Mt),nt);mc.position.set(0,Tt/2-U/2,-yt/2+U/2+U+Xt*2+ot);const yc=new $(new O(wt,Tt,ot,Et,Mt),nt);yc.position.set(0,Tt/2-U/2,-yt/2+U/2+U+Xt*3+ot*2);const wc=new $(new O(wt,Tt,ot,Et,Mt),nt);wc.position.set(0,Tt/2-U/2,-yt/2+U/2+U+Xt*4+ot*3);const gc=new $(new O(wt,Tt,U,Et,Mt),nt);gc.position.set(0,Tt/2-U/2,-yt/2+U/2+U+Xt*5+ot*4);dt.add(Ap);dt.add(lc);dt.add(uc);dt.add(hc);dt.add(dc);dt.add(fc);dt.add(cc);dt.add(pc);dt.add(mc);dt.add(yc);dt.add(wc);dt.add(gc);dt.children.forEach(u=>{u.castShadow=!0,u.receiveShadow=!0});H.add(dt);const{shelfWidth:Sp,shelfDepth:ve,shelfBorderBoardThickness:it,shelfBoardThickness:be,shelfInnerWidth:Ue,roundSegments:Le,roundRadius:Ne}=gp,Ae=Ue*2+be+it*2,Cn=Ue*4+be*3+it*2,{floorXLength:Tp,floorZLength:Ep,ny:Mp}=G,Yt=new fe;Yt.position.set(-Tp/2+ve/2,-Mp+it/2+.1,-Ep/2+Ae/2+2+Sp);const Bp=new $(new O(ve,it,Ae,Le,Ne),nt),xc=new $(new O(ve,be,Ae,Le,Ne),nt);xc.position.set(0,it+Ue,0);const vc=new $(new O(ve,be,Ae,Le,Ne),nt);vc.position.set(0,it+Ue*2+be,0);const bc=new $(new O(ve,be,Ae,Le,Ne),nt);bc.position.set(0,it+Ue*3+be*2,0);const Ac=new $(new O(ve,it,Ae,Le,Ne),nt);Ac.position.set(0,it+Ue*4+be*3,0);const Sc=new $(new O(ve,Cn,it,Le,Ne),nt);Sc.position.set(0,Cn/2-it/2,-Ae/2+it/2);const Tc=new $(new O(ve,Cn,it,Le,Ne),nt);Tc.position.set(0,Cn/2-it/2,Ae/2-it/2);const Ec=new $(new O(ve,Cn,be,Le,Ne),nt);Ec.position.set(0,Cn/2-it/2,-Ae/2+it/2+it+Ue);Yt.add(Bp);Yt.add(xc);Yt.add(vc);Yt.add(bc);Yt.add(Ac);Yt.add(Sc);Yt.add(Tc);Yt.add(Ec);Yt.children.forEach(u=>{u.castShadow=!0,u.receiveShadow=!0});H.add(Yt);const{floorXLength:_p,floorZLength:Cp,ny:Pp}=G,ho=new fe;ho.position.set(-_p/2,-Pp,-Cp/2);const zp=Ie({title:"Table"}),Ip=new ua(zp),ca=new vt({wireframe:At,color:16777215,normalMap:Yn,aoMap:Zn,roughnessMap:Kn,metalnessMap:Jn,displacementMap:Qn,displacementScale:.002}),Lp=new vt({wireframe:At,color:16777215,normalMap:ai,aoMap:ci,roughnessMap:li,metalnessMap:ui});Ip.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/table/ikea Kvistbro storage.obj",u=>{u.scale.set(12,10,12),u.position.set(22,0,15),u.children[73].material=ca,u.children[72].material=ca,u.children[73].castShadow=!0,u.children[73].receiveShadow=!0,u.children[72].castShadow=!0,u.children[72].receiveShadow=!0;for(let e=0;e<72;e++){const n=u.children[e];n.castShadow=!0,n.receiveShadow=!0,n.material=Lp}ho.add(u),H.add(ho)});const Bt=new Uc,Se={spotLight:!0,closeBlind1:()=>{jf()},openBlind1:()=>{Of()},liftBlind1:()=>{Wf()},dropBlind1:()=>{Gf()},closeBlind2:()=>{Kf()},openBlind2:()=>{Jf()},liftBlind2:()=>{Qf()},dropBlind2:()=>{tp()}};Bt.add(ht,"visible").name("directionalLight");Bt.add(se,"visible").name("pointLight");Bt.add(Ua,"visible").name("ambientLight");Bt.add(Se,"spotLight").name("spotLight").onChange(u=>{u?ip():sp()});Bt.add(Tn,"autoRotate");Bt.add(Se,"closeBlind1");Bt.add(Se,"openBlind1");Bt.add(Se,"liftBlind1");Bt.add(Se,"dropBlind1");Bt.add(Se,"closeBlind2");Bt.add(Se,"openBlind2");Bt.add(Se,"liftBlind2");Bt.add(Se,"dropBlind2");$a();Xc(un,hn,$t);

import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as N,aP as Le,n as tl,j as el,m as nl,a4 as pe,_ as fr,aQ as Qe,X as ki,U as pr,Q as gs,aR as sl,a0 as mr,a3 as qi,M as G,P as il,W as ol,aS as rl,O as al,S as cl,c as ll,J as ci,V as He,aT as Io,aU as Rt,aV as xt,ar as ul,v as ee,aq as Xt,aW as hl,Y as Lo,ak as wr,aX as Ba,aY as Ue,aZ as dl,s as Ne,z as Tn,t as Jn,R as H,a as bt,a_ as No,a$ as zt,r as li,b0 as fl,b as yr,d as pl,b1 as ml,q as wl,b2 as yl,b3 as En,p as gl,b4 as xl,o as ui,b5 as hi,A as vl,G as bl,l as Al}from"./index-Btor9uwS.js";const Ln=new N;function Ct(l,t,e,n,s,i){const o=2*Math.PI*s/4,r=Math.max(i-2*s,0),a=Math.PI/4;Ln.copy(t),Ln[n]=0,Ln.normalize();const c=.5*o/(o+r),u=1-Ln.angleTo(l)/a;return Math.sign(Ln[e])===1?u*c:r/(o+r)+c+c*(1-u)}class W extends Le{constructor(t=1,e=1,n=1,s=2,i=.1){if(s=s*2+1,i=Math.min(t/2,e/2,n/2,i),super(1,1,1,s,s,s),s===1)return;const o=this.toNonIndexed();this.index=null,this.attributes.position=o.attributes.position,this.attributes.normal=o.attributes.normal,this.attributes.uv=o.attributes.uv;const r=new N,a=new N,c=new N(t,e,n).divideScalar(2).subScalar(i),u=this.attributes.position.array,d=this.attributes.normal.array,h=this.attributes.uv.array,f=u.length/6,p=new N,x=.5/s;for(let g=0,w=0;g<u.length;g+=3,w+=2)switch(r.fromArray(u,g),a.copy(r),a.x-=Math.sign(a.x)*x,a.y-=Math.sign(a.y)*x,a.z-=Math.sign(a.z)*x,a.normalize(),u[g+0]=c.x*Math.sign(r.x)+a.x*i,u[g+1]=c.y*Math.sign(r.y)+a.y*i,u[g+2]=c.z*Math.sign(r.z)+a.z*i,d[g+0]=a.x,d[g+1]=a.y,d[g+2]=a.z,Math.floor(g/f)){case 0:p.set(1,0,0),h[w+0]=Ct(p,a,"z","y",i,n),h[w+1]=1-Ct(p,a,"y","z",i,e);break;case 1:p.set(-1,0,0),h[w+0]=1-Ct(p,a,"z","y",i,n),h[w+1]=1-Ct(p,a,"y","z",i,e);break;case 2:p.set(0,1,0),h[w+0]=1-Ct(p,a,"x","z",i,t),h[w+1]=Ct(p,a,"z","x",i,n);break;case 3:p.set(0,-1,0),h[w+0]=1-Ct(p,a,"x","z",i,t),h[w+1]=1-Ct(p,a,"z","x",i,n);break;case 4:p.set(0,0,1),h[w+0]=1-Ct(p,a,"x","y",i,t),h[w+1]=1-Ct(p,a,"y","x",i,e);break;case 5:p.set(0,0,-1),h[w+0]=Ct(p,a,"x","y",i,t),h[w+1]=1-Ct(p,a,"y","x",i,e);break}}}const Sl=/^[og]\s*(.+)?/,Tl=/^mtllib /,El=/^usemtl /,Ml=/^usemap /,gr=/\s+/,xr=new N,ji=new N,vr=new N,br=new N,_t=new N,xs=new tl;function Bl(){const l={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(s,i){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const r={index:this.materials.length,name:s||"",mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(a){const c={index:typeof a=="number"?a:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(r),r},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(s){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),s&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return s&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}},n&&n.name&&typeof n.clone=="function"){const s=n.clone(0);s.inherited=!0,this.object.materials.push(s)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseNormalIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseUVIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/2)*2},addVertex:function(t,e,n){const s=this.vertices,i=this.object.geometry.vertices;i.push(s[t+0],s[t+1],s[t+2]),i.push(s[e+0],s[e+1],s[e+2]),i.push(s[n+0],s[n+1],s[n+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,n){const s=this.normals,i=this.object.geometry.normals;i.push(s[t+0],s[t+1],s[t+2]),i.push(s[e+0],s[e+1],s[e+2]),i.push(s[n+0],s[n+1],s[n+2])},addFaceNormal:function(t,e,n){const s=this.vertices,i=this.object.geometry.normals;xr.fromArray(s,t),ji.fromArray(s,e),vr.fromArray(s,n),_t.subVectors(vr,ji),br.subVectors(xr,ji),_t.cross(br),_t.normalize(),i.push(_t.x,_t.y,_t.z),i.push(_t.x,_t.y,_t.z),i.push(_t.x,_t.y,_t.z)},addColor:function(t,e,n){const s=this.colors,i=this.object.geometry.colors;s[t]!==void 0&&i.push(s[t+0],s[t+1],s[t+2]),s[e]!==void 0&&i.push(s[e+0],s[e+1],s[e+2]),s[n]!==void 0&&i.push(s[n+0],s[n+1],s[n+2])},addUV:function(t,e,n){const s=this.uvs,i=this.object.geometry.uvs;i.push(s[t+0],s[t+1]),i.push(s[e+0],s[e+1]),i.push(s[n+0],s[n+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,n,s,i,o,r,a,c){const u=this.vertices.length;let d=this.parseVertexIndex(t,u),h=this.parseVertexIndex(e,u),f=this.parseVertexIndex(n,u);if(this.addVertex(d,h,f),this.addColor(d,h,f),r!==void 0&&r!==""){const p=this.normals.length;d=this.parseNormalIndex(r,p),h=this.parseNormalIndex(a,p),f=this.parseNormalIndex(c,p),this.addNormal(d,h,f)}else this.addFaceNormal(d,h,f);if(s!==void 0&&s!==""){const p=this.uvs.length;d=this.parseUVIndex(s,p),h=this.parseUVIndex(i,p),f=this.parseUVIndex(o,p),this.addUV(d,h,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let n=0,s=t.length;n<s;n++){const i=this.parseVertexIndex(t[n],e);this.addVertexPoint(i),this.addColor(i)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const n=this.vertices.length,s=this.uvs.length;for(let i=0,o=t.length;i<o;i++)this.addVertexLine(this.parseVertexIndex(t[i],n));for(let i=0,o=e.length;i<o;i++)this.addUVLine(this.parseUVIndex(e[i],s))}};return l.startObject("",!1),l}class Ca extends el{constructor(t){super(t),this.materials=null}load(t,e,n,s){const i=this,o=new nl(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(r){try{e(i.parse(r))}catch(a){s?s(a):console.error(a),i.manager.itemError(t)}},n,s)}setMaterials(t){return this.materials=t,this}parse(t){const e=new Bl;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const n=t.split(`
`);let s=[];for(let r=0,a=n.length;r<a;r++){const c=n[r].trimStart();if(c.length===0)continue;const u=c.charAt(0);if(u!=="#")if(u==="v"){const d=c.split(gr);switch(d[0]){case"v":e.vertices.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3])),d.length>=7?(xs.setRGB(parseFloat(d[4]),parseFloat(d[5]),parseFloat(d[6])).convertSRGBToLinear(),e.colors.push(xs.r,xs.g,xs.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3]));break;case"vt":e.uvs.push(parseFloat(d[1]),parseFloat(d[2]));break}}else if(u==="f"){const h=c.slice(1).trim().split(gr),f=[];for(let x=0,g=h.length;x<g;x++){const w=h[x];if(w.length>0){const m=w.split("/");f.push(m)}}const p=f[0];for(let x=1,g=f.length-1;x<g;x++){const w=f[x],m=f[x+1];e.addFace(p[0],w[0],m[0],p[1],w[1],m[1],p[2],w[2],m[2])}}else if(u==="l"){const d=c.substring(1).trim().split(" ");let h=[];const f=[];if(c.indexOf("/")===-1)h=d;else for(let p=0,x=d.length;p<x;p++){const g=d[p].split("/");g[0]!==""&&h.push(g[0]),g[1]!==""&&f.push(g[1])}e.addLineGeometry(h,f)}else if(u==="p"){const h=c.slice(1).trim().split(" ");e.addPointGeometry(h)}else if((s=Sl.exec(c))!==null){const d=(" "+s[0].slice(1).trim()).slice(1);e.startObject(d)}else if(El.test(c))e.object.startMaterial(c.substring(7).trim(),e.materialLibraries);else if(Tl.test(c))e.materialLibraries.push(c.substring(7).trim());else if(Ml.test(c))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(u==="s"){if(s=c.split(" "),s.length>1){const h=s[1].trim().toLowerCase();e.object.smooth=h!=="0"&&h!=="off"}else e.object.smooth=!0;const d=e.object.currentMaterial();d&&(d.smooth=e.object.smooth)}else{if(c==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+c+'"')}}e.finalize();const i=new pe;if(i.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let r=0,a=e.objects.length;r<a;r++){const c=e.objects[r],u=c.geometry,d=c.materials,h=u.type==="Line",f=u.type==="Points";let p=!1;if(u.vertices.length===0)continue;const x=new fr;x.setAttribute("position",new Qe(u.vertices,3)),u.normals.length>0&&x.setAttribute("normal",new Qe(u.normals,3)),u.colors.length>0&&(p=!0,x.setAttribute("color",new Qe(u.colors,3))),u.hasUVIndices===!0&&x.setAttribute("uv",new Qe(u.uvs,2));const g=[];for(let m=0,v=d.length;m<v;m++){const b=d[m],A=b.name+"_"+b.smooth+"_"+p;let S=e.materials[A];if(this.materials!==null){if(S=this.materials.create(b.name),h&&S&&!(S instanceof ki)){const T=new ki;pr.prototype.copy.call(T,S),T.color.copy(S.color),S=T}else if(f&&S&&!(S instanceof gs)){const T=new gs({size:10,sizeAttenuation:!1});pr.prototype.copy.call(T,S),T.color.copy(S.color),T.map=S.map,S=T}}S===void 0&&(h?S=new ki:f?S=new gs({size:1,sizeAttenuation:!1}):S=new sl,S.name=b.name,S.flatShading=!b.smooth,S.vertexColors=p,e.materials[A]=S),g.push(S)}let w;if(g.length>1){for(let m=0,v=d.length;m<v;m++){const b=d[m];x.addGroup(b.groupStart,b.groupCount,m)}h?w=new mr(x,g):f?w=new qi(x,g):w=new G(x,g)}else h?w=new mr(x,g[0]):f?w=new qi(x,g[0]):w=new G(x,g[0]);w.name=c.name,i.add(w)}else if(e.vertices.length>0){const r=new gs({size:1,sizeAttenuation:!1}),a=new fr;a.setAttribute("position",new Qe(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(a.setAttribute("color",new Qe(e.colors,3)),r.vertexColors=!0);const c=new qi(a,r);i.add(c)}return i}}const ne={width:window.innerWidth,height:window.innerHeight},De=new il(20,ne.width/ne.height,25,800);ne.width<768?De.position.set(200,175,200):De.position.set(120,100,120);const _a=document.querySelector("canvas.webgl");if(_a===null)throw new Error("Cannot find the canvas element");const Ut=new ol({canvas:_a,antialias:!0});Ut.setSize(ne.width,ne.height);Ut.setPixelRatio(Math.min(window.devicePixelRatio,2));Ut.autoClear=!1;Ut.shadowMap.enabled=!0;Ut.shadowMap.type=rl;const Mn=new al(De,Ut.domElement);Mn.enableDamping=!0;Mn.minDistance=30;Mn.maxDistance=400;Mn.maxPolarAngle=Math.PI/1.98;const O=new cl,Oi=ll(De,Ut.domElement),Pa=0,Cl=1,_l=2,Ar=2,Wi=1.25,Sr=1,Xn=6*4+4+4,di=65535,Pl=Math.pow(2,-24),Gi=Symbol("SKIP_GENERATION");function zl(l){return l.index?l.index.count:l.attributes.position.count}function Bn(l){return zl(l)/3}function Il(l,t=ArrayBuffer){return l>65535?new Uint32Array(new t(4*l)):new Uint16Array(new t(2*l))}function Ll(l,t){if(!l.index){const e=l.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Il(e,n);l.setIndex(new ci(s,1));for(let i=0;i<e;i++)s[i]=i}}function za(l){const t=Bn(l),e=l.drawRange,n=e.start/3,s=(e.start+e.count)/3,i=Math.max(0,n),o=Math.min(t,s)-i;return[{offset:Math.floor(i),count:Math.floor(o)}]}function Ia(l){if(!l.groups||!l.groups.length)return za(l);const t=[],e=new Set,n=l.drawRange,s=n.start/3,i=(n.start+n.count)/3;for(const r of l.groups){const a=r.start/3,c=(r.start+r.count)/3;e.add(Math.max(s,a)),e.add(Math.min(i,c))}const o=Array.from(e.values()).sort((r,a)=>r-a);for(let r=0;r<o.length-1;r++){const a=o[r],c=o[r+1];t.push({offset:Math.floor(a),count:Math.floor(c-a)})}return t}function Nl(l){if(l.groups.length===0)return!1;const t=Bn(l),e=Ia(l).sort((i,o)=>i.offset-o.offset),n=e[e.length-1];n.count=Math.min(t-n.offset,n.count);let s=0;return e.forEach(({count:i})=>s+=i),t!==s}function $i(l,t,e,n,s){let i=1/0,o=1/0,r=1/0,a=-1/0,c=-1/0,u=-1/0,d=1/0,h=1/0,f=1/0,p=-1/0,x=-1/0,g=-1/0;for(let w=t*6,m=(t+e)*6;w<m;w+=6){const v=l[w+0],b=l[w+1],A=v-b,S=v+b;A<i&&(i=A),S>a&&(a=S),v<d&&(d=v),v>p&&(p=v);const T=l[w+2],M=l[w+3],B=T-M,C=T+M;B<o&&(o=B),C>c&&(c=C),T<h&&(h=T),T>x&&(x=T);const z=l[w+4],_=l[w+5],E=z-_,P=z+_;E<r&&(r=E),P>u&&(u=P),z<f&&(f=z),z>g&&(g=z)}n[0]=i,n[1]=o,n[2]=r,n[3]=a,n[4]=c,n[5]=u,s[0]=d,s[1]=h,s[2]=f,s[3]=p,s[4]=x,s[5]=g}function Fl(l,t=null,e=null,n=null){const s=l.attributes.position,i=l.index?l.index.array:null,o=Bn(l),r=s.normalized;let a;t===null?(a=new Float32Array(o*6*4),e=0,n=o):(a=t,e=e||0,n=n||o);const c=s.array,u=s.offset||0;let d=3;s.isInterleavedBufferAttribute&&(d=s.data.stride);const h=["getX","getY","getZ"];for(let f=e;f<e+n;f++){const p=f*3,x=f*6;let g=p+0,w=p+1,m=p+2;i&&(g=i[g],w=i[w],m=i[m]),r||(g=g*d+u,w=w*d+u,m=m*d+u);for(let v=0;v<3;v++){let b,A,S;r?(b=s[h[v]](g),A=s[h[v]](w),S=s[h[v]](m)):(b=c[g+v],A=c[w+v],S=c[m+v]);let T=b;A<T&&(T=A),S<T&&(T=S);let M=b;A>M&&(M=A),S>M&&(M=S);const B=(M-T)/2,C=v*2;a[x+C+0]=T+B,a[x+C+1]=B+(Math.abs(T)+B)*Pl}}return a}function K(l,t,e){return e.min.x=t[l],e.min.y=t[l+1],e.min.z=t[l+2],e.max.x=t[l+3],e.max.y=t[l+4],e.max.z=t[l+5],e}function Tr(l){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=l[n+3]-l[n];s>e&&(e=s,t=n)}return t}function Er(l,t){t.set(l)}function Mr(l,t,e){let n,s;for(let i=0;i<3;i++){const o=i+3;n=l[i],s=t[i],e[i]=n<s?n:s,n=l[o],s=t[o],e[o]=n>s?n:s}}function vs(l,t,e){for(let n=0;n<3;n++){const s=t[l+2*n],i=t[l+2*n+1],o=s-i,r=s+i;o<e[n]&&(e[n]=o),r>e[n+3]&&(e[n+3]=r)}}function Nn(l){const t=l[3]-l[0],e=l[4]-l[1],n=l[5]-l[2];return 2*(t*e+e*n+n*t)}const de=32,Rl=(l,t)=>l.candidate-t.candidate,Te=new Array(de).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),bs=new Float32Array(6);function Vl(l,t,e,n,s,i){let o=-1,r=0;if(i===Pa)o=Tr(t),o!==-1&&(r=(t[o]+t[o+3])/2);else if(i===Cl)o=Tr(l),o!==-1&&(r=kl(e,n,s,o));else if(i===_l){const a=Nn(l);let c=Wi*s;const u=n*6,d=(n+s)*6;for(let h=0;h<3;h++){const f=t[h],g=(t[h+3]-f)/de;if(s<de/4){const w=[...Te];w.length=s;let m=0;for(let b=u;b<d;b+=6,m++){const A=w[m];A.candidate=e[b+2*h],A.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:M}=A;for(let B=0;B<3;B++)M[B]=1/0,M[B+3]=-1/0,T[B]=1/0,T[B+3]=-1/0,S[B]=1/0,S[B+3]=-1/0;vs(b,e,S)}w.sort(Rl);let v=s;for(let b=0;b<v;b++){const A=w[b];for(;b+1<v&&w[b+1].candidate===A.candidate;)w.splice(b+1,1),v--}for(let b=u;b<d;b+=6){const A=e[b+2*h];for(let S=0;S<v;S++){const T=w[S];A>=T.candidate?vs(b,e,T.rightCacheBounds):(vs(b,e,T.leftCacheBounds),T.count++)}}for(let b=0;b<v;b++){const A=w[b],S=A.count,T=s-A.count,M=A.leftCacheBounds,B=A.rightCacheBounds;let C=0;S!==0&&(C=Nn(M)/a);let z=0;T!==0&&(z=Nn(B)/a);const _=Sr+Wi*(C*S+z*T);_<c&&(o=h,c=_,r=A.candidate)}}else{for(let v=0;v<de;v++){const b=Te[v];b.count=0,b.candidate=f+g+v*g;const A=b.bounds;for(let S=0;S<3;S++)A[S]=1/0,A[S+3]=-1/0}for(let v=u;v<d;v+=6){let S=~~((e[v+2*h]-f)/g);S>=de&&(S=de-1);const T=Te[S];T.count++,vs(v,e,T.bounds)}const w=Te[de-1];Er(w.bounds,w.rightCacheBounds);for(let v=de-2;v>=0;v--){const b=Te[v],A=Te[v+1];Mr(b.bounds,A.rightCacheBounds,b.rightCacheBounds)}let m=0;for(let v=0;v<de-1;v++){const b=Te[v],A=b.count,S=b.bounds,M=Te[v+1].rightCacheBounds;A!==0&&(m===0?Er(S,bs):Mr(S,bs,bs)),m+=A;let B=0,C=0;m!==0&&(B=Nn(bs)/a);const z=s-m;z!==0&&(C=Nn(M)/a);const _=Sr+Wi*(B*m+C*z);_<c&&(o=h,c=_,r=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:o,pos:r}}function kl(l,t,e,n){let s=0;for(let i=t,o=t+e;i<o;i++)s+=l[i*6+n*2];return s/e}class Hi{constructor(){this.boundingData=new Float32Array(6)}}function ql(l,t,e,n,s,i){let o=n,r=n+s-1;const a=i.pos,c=i.axis*2;for(;;){for(;o<=r&&e[o*6+c]<a;)o++;for(;o<=r&&e[r*6+c]>=a;)r--;if(o<r){for(let u=0;u<3;u++){let d=t[o*3+u];t[o*3+u]=t[r*3+u],t[r*3+u]=d}for(let u=0;u<6;u++){let d=e[o*6+u];e[o*6+u]=e[r*6+u],e[r*6+u]=d}o++,r--}else return o}}function jl(l,t,e,n,s,i){let o=n,r=n+s-1;const a=i.pos,c=i.axis*2;for(;;){for(;o<=r&&e[o*6+c]<a;)o++;for(;o<=r&&e[r*6+c]>=a;)r--;if(o<r){let u=l[o];l[o]=l[r],l[r]=u;for(let d=0;d<6;d++){let h=e[o*6+d];e[o*6+d]=e[r*6+d],e[r*6+d]=h}o++,r--}else return o}}function wt(l,t){return t[l+15]===65535}function vt(l,t){return t[l+6]}function It(l,t){return t[l+14]}function Lt(l){return l+8}function Nt(l,t){return t[l+6]}function La(l,t){return t[l+7]}let Na,Un,Ds,Fa;const Ol=Math.pow(2,32);function bo(l){return"count"in l?1:1+bo(l.left)+bo(l.right)}function Wl(l,t,e){return Na=new Float32Array(e),Un=new Uint32Array(e),Ds=new Uint16Array(e),Fa=new Uint8Array(e),Ao(l,t)}function Ao(l,t){const e=l/4,n=l/2,s="count"in t,i=t.boundingData;for(let o=0;o<6;o++)Na[e+o]=i[o];if(s)if(t.buffer){const o=t.buffer;Fa.set(new Uint8Array(o),l);for(let r=l,a=l+o.byteLength;r<a;r+=Xn){const c=r/2;wt(c,Ds)||(Un[r/4+6]+=e)}return l+o.byteLength}else{const o=t.offset,r=t.count;return Un[e+6]=o,Ds[n+14]=r,Ds[n+15]=di,l+Xn}else{const o=t.left,r=t.right,a=t.splitAxis;let c;if(c=Ao(l+Xn,o),c/4>Ol)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Un[e+6]=c/4,c=Ao(c,r),Un[e+7]=a,c}}function Gl(l,t){const e=(l.index?l.index.count:l.attributes.position.count)/3,n=e>2**16,s=n?4:2,i=t?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),o=n?new Uint32Array(i):new Uint16Array(i);for(let r=0,a=o.length;r<a;r++)o[r]=r;return o}function $l(l,t,e,n,s){const{maxDepth:i,verbose:o,maxLeafTris:r,strategy:a,onProgress:c,indirect:u}=s,d=l._indirectBuffer,h=l.geometry,f=h.index?h.index.array:null,p=u?jl:ql,x=Bn(h),g=new Float32Array(6);let w=!1;const m=new Hi;return $i(t,e,n,m.boundingData,g),b(m,e,n,g),m;function v(A){c&&c(A/x)}function b(A,S,T,M=null,B=0){if(!w&&B>=i&&(w=!0,o&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(h))),T<=r||B>=i)return v(S+T),A.offset=S,A.count=T,A;const C=Vl(A.boundingData,M,t,S,T,a);if(C.axis===-1)return v(S+T),A.offset=S,A.count=T,A;const z=p(d,f,t,S,T,C);if(z===S||z===S+T)v(S+T),A.offset=S,A.count=T;else{A.splitAxis=C.axis;const _=new Hi,E=S,P=z-S;A.left=_,$i(t,E,P,_.boundingData,g),b(_,E,P,g,B+1);const I=new Hi,L=z,j=T-P;A.right=I,$i(t,L,j,I.boundingData,g),b(I,L,j,g,B+1)}return A}}function Hl(l,t){const e=l.geometry;t.indirect&&(l._indirectBuffer=Gl(e,t.useSharedArrayBuffer),Nl(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),l._indirectBuffer||Ll(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Fl(e),i=t.indirect?za(e):Ia(e);l._roots=i.map(o=>{const r=$l(l,s,o.offset,o.count,t),a=bo(r),c=new n(Xn*a);return Wl(0,r,c),c})}class fe{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let i=0,o=t.length;i<o;i++){const a=t[i][e];n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let i=0,o=e.length;i<o;i++){const r=e[i],a=t.dot(r);n=a<n?a:n,s=a>s?a:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}fe.prototype.setFromBox=function(){const l=new N;return function(e,n){const s=n.min,i=n.max;let o=1/0,r=-1/0;for(let a=0;a<=1;a++)for(let c=0;c<=1;c++)for(let u=0;u<=1;u++){l.x=s.x*a+i.x*(1-a),l.y=s.y*c+i.y*(1-c),l.z=s.z*u+i.z*(1-u);const d=e.dot(l);o=Math.min(d,o),r=Math.max(d,r)}this.min=o,this.max=r}}();const Dl=function(){const l=new N,t=new N,e=new N;return function(s,i,o){const r=s.start,a=l,c=i.start,u=t;e.subVectors(r,c),l.subVectors(s.end,s.start),t.subVectors(i.end,i.start);const d=e.dot(u),h=u.dot(a),f=u.dot(u),p=e.dot(a),g=a.dot(a)*f-h*h;let w,m;g!==0?w=(d*h-p*f)/g:w=0,m=(d+w*h)/f,o.x=w,o.y=m}}(),Fo=function(){const l=new He,t=new N,e=new N;return function(s,i,o,r){Dl(s,i,l);let a=l.x,c=l.y;if(a>=0&&a<=1&&c>=0&&c<=1){s.at(a,o),i.at(c,r);return}else if(a>=0&&a<=1){c<0?i.at(0,r):i.at(1,r),s.closestPointToPoint(r,!0,o);return}else if(c>=0&&c<=1){a<0?s.at(0,o):s.at(1,o),i.closestPointToPoint(o,!0,r);return}else{let u;a<0?u=s.start:u=s.end;let d;c<0?d=i.start:d=i.end;const h=t,f=e;if(s.closestPointToPoint(d,!0,t),i.closestPointToPoint(u,!0,e),h.distanceToSquared(d)<=f.distanceToSquared(u)){o.copy(h),r.copy(d);return}else{o.copy(u),r.copy(f);return}}}}(),Ul=function(){const l=new N,t=new N,e=new Io,n=new Rt;return function(i,o){const{radius:r,center:a}=i,{a:c,b:u,c:d}=o;if(n.start=c,n.end=u,n.closestPointToPoint(a,!0,l).distanceTo(a)<=r||(n.start=c,n.end=d,n.closestPointToPoint(a,!0,l).distanceTo(a)<=r)||(n.start=u,n.end=d,n.closestPointToPoint(a,!0,l).distanceTo(a)<=r))return!0;const x=o.getPlane(e);if(Math.abs(x.distanceToPoint(a))<=r){const w=x.projectPoint(a,t);if(o.containsPoint(w))return!0}return!1}}(),Xl=1e-15;function Di(l){return Math.abs(l)<Xl}class Vt extends xt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new N),this.satBounds=new Array(4).fill().map(()=>new fe),this.points=[this.a,this.b,this.c],this.sphere=new ul,this.plane=new Io,this.needsUpdate=!0}intersectsSphere(t){return Ul(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,i=this.satAxes,o=this.satBounds,r=i[0],a=o[0];this.getNormal(r),a.setFromPoints(r,s);const c=i[1],u=o[1];c.subVectors(t,e),u.setFromPoints(c,s);const d=i[2],h=o[2];d.subVectors(e,n),h.setFromPoints(d,s);const f=i[3],p=o[3];f.subVectors(n,t),p.setFromPoints(f,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,t),this.needsUpdate=!1}}Vt.prototype.closestPointToSegment=function(){const l=new N,t=new N,e=new Rt;return function(s,i=null,o=null){const{start:r,end:a}=s,c=this.points;let u,d=1/0;for(let h=0;h<3;h++){const f=(h+1)%3;e.start.copy(c[h]),e.end.copy(c[f]),Fo(e,s,l,t),u=l.distanceToSquared(t),u<d&&(d=u,i&&i.copy(l),o&&o.copy(t))}return this.closestPointToPoint(r,l),u=r.distanceToSquared(l),u<d&&(d=u,i&&i.copy(l),o&&o.copy(r)),this.closestPointToPoint(a,l),u=a.distanceToSquared(l),u<d&&(d=u,i&&i.copy(l),o&&o.copy(a)),Math.sqrt(d)}}();Vt.prototype.intersectsTriangle=function(){const l=new Vt,t=new Array(3),e=new Array(3),n=new fe,s=new fe,i=new N,o=new N,r=new N,a=new N,c=new N,u=new Rt,d=new Rt,h=new Rt,f=new N;function p(x,g,w){const m=x.points;let v=0,b=-1;for(let A=0;A<3;A++){const{start:S,end:T}=u;S.copy(m[A]),T.copy(m[(A+1)%3]),u.delta(o);const M=Di(g.distanceToPoint(S));if(Di(g.normal.dot(o))&&M){w.copy(u),v=2;break}const B=g.intersectLine(u,f);if(!B&&M&&f.copy(S),(B||M)&&!Di(f.distanceTo(T))){if(v<=1)(v===1?w.start:w.end).copy(f),M&&(b=v);else if(v>=2){(b===1?w.start:w.end).copy(f),v=2;break}if(v++,v===2&&b===-1)break}}return v}return function(g,w=null,m=!1){this.needsUpdate&&this.update(),g.isExtendedTriangle?g.needsUpdate&&g.update():(l.copy(g),l.update(),g=l);const v=this.plane,b=g.plane;if(Math.abs(v.normal.dot(b.normal))>1-1e-10){const A=this.satBounds,S=this.satAxes;e[0]=g.a,e[1]=g.b,e[2]=g.c;for(let B=0;B<4;B++){const C=A[B],z=S[B];if(n.setFromPoints(z,e),C.isSeparated(n))return!1}const T=g.satBounds,M=g.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let B=0;B<4;B++){const C=T[B],z=M[B];if(n.setFromPoints(z,t),C.isSeparated(n))return!1}for(let B=0;B<4;B++){const C=S[B];for(let z=0;z<4;z++){const _=M[z];if(i.crossVectors(C,_),n.setFromPoints(i,t),s.setFromPoints(i,e),n.isSeparated(s))return!1}}return w&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),w.start.set(0,0,0),w.end.set(0,0,0)),!0}else{const A=p(this,b,d);if(A===1&&g.containsPoint(d.end))return w&&(w.start.copy(d.end),w.end.copy(d.end)),!0;if(A!==2)return!1;const S=p(g,v,h);if(S===1&&this.containsPoint(h.end))return w&&(w.start.copy(h.end),w.end.copy(h.end)),!0;if(S!==2)return!1;if(d.delta(r),h.delta(a),r.dot(a)<0){let E=h.start;h.start=h.end,h.end=E}const T=d.start.dot(r),M=d.end.dot(r),B=h.start.dot(r),C=h.end.dot(r),z=M<B,_=T<C;return T!==C&&B!==M&&z===_?!1:(w&&(c.subVectors(d.start,h.start),c.dot(r)>0?w.start.copy(d.start):w.start.copy(h.start),c.subVectors(d.end,h.end),c.dot(r)<0?w.end.copy(d.end):w.end.copy(h.end)),!0)}}}();Vt.prototype.distanceToPoint=function(){const l=new N;return function(e){return this.closestPointToPoint(e,l),e.distanceTo(l)}}();Vt.prototype.distanceToTriangle=function(){const l=new N,t=new N,e=["a","b","c"],n=new Rt,s=new Rt;return function(o,r=null,a=null){const c=r||a?n:null;if(this.intersectsTriangle(o,c))return(r||a)&&(r&&c.getCenter(r),a&&c.getCenter(a)),0;let u=1/0;for(let d=0;d<3;d++){let h;const f=e[d],p=o[f];this.closestPointToPoint(p,l),h=p.distanceToSquared(l),h<u&&(u=h,r&&r.copy(l),a&&a.copy(p));const x=this[f];o.closestPointToPoint(x,l),h=x.distanceToSquared(l),h<u&&(u=h,r&&r.copy(x),a&&a.copy(l))}for(let d=0;d<3;d++){const h=e[d],f=e[(d+1)%3];n.set(this[h],this[f]);for(let p=0;p<3;p++){const x=e[p],g=e[(p+1)%3];s.set(o[x],o[g]),Fo(n,s,l,t);const w=l.distanceToSquared(t);w<u&&(u=w,r&&r.copy(l),a&&a.copy(t))}}return Math.sqrt(u)}}();class ht{constructor(t,e,n){this.isOrientedBox=!0,this.min=new N,this.max=new N,this.matrix=new ee,this.invMatrix=new ee,this.points=new Array(8).fill().map(()=>new N),this.satAxes=new Array(3).fill().map(()=>new N),this.satBounds=new Array(3).fill().map(()=>new fe),this.alignedSatBounds=new Array(3).fill().map(()=>new fe),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}ht.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let c=0;c<=1;c++)for(let u=0;u<=1;u++)for(let d=0;d<=1;d++){const h=1*c|2*u|4*d,f=s[h];f.x=c?n.x:e.x,f.y=u?n.y:e.y,f.z=d?n.z:e.z,f.applyMatrix4(t)}const i=this.satBounds,o=this.satAxes,r=s[0];for(let c=0;c<3;c++){const u=o[c],d=i[c],h=1<<c,f=s[h];u.subVectors(r,f),d.setFromPoints(u,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();ht.prototype.intersectsBox=function(){const l=new fe;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,i=this.satBounds,o=this.satAxes,r=this.alignedSatBounds;if(l.min=n.x,l.max=s.x,r[0].isSeparated(l)||(l.min=n.y,l.max=s.y,r[1].isSeparated(l))||(l.min=n.z,l.max=s.z,r[2].isSeparated(l)))return!1;for(let a=0;a<3;a++){const c=o[a],u=i[a];if(l.setFromBox(c,e),u.isSeparated(l))return!1}return!0}}();ht.prototype.intersectsTriangle=function(){const l=new Vt,t=new Array(3),e=new fe,n=new fe,s=new N;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(l.copy(o),l.update(),o=l);const r=this.satBounds,a=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let h=0;h<3;h++){const f=r[h],p=a[h];if(e.setFromPoints(p,t),f.isSeparated(e))return!1}const c=o.satBounds,u=o.satAxes,d=this.points;for(let h=0;h<3;h++){const f=c[h],p=u[h];if(e.setFromPoints(p,d),f.isSeparated(e))return!1}for(let h=0;h<3;h++){const f=a[h];for(let p=0;p<4;p++){const x=u[p];if(s.crossVectors(f,x),e.setFromPoints(s,t),n.setFromPoints(s,d),e.isSeparated(n))return!1}}return!0}}();ht.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();ht.prototype.distanceToPoint=function(){const l=new N;return function(e){return this.closestPointToPoint(e,l),e.distanceTo(l)}}();ht.prototype.distanceToBox=function(){const l=["x","y","z"],t=new Array(12).fill().map(()=>new Rt),e=new Array(12).fill().map(()=>new Rt),n=new N,s=new N;return function(o,r=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(s),this.closestPointToPoint(s,n),o.closestPointToPoint(n,s),a&&a.copy(n),c&&c.copy(s)),0;const u=r*r,d=o.min,h=o.max,f=this.points;let p=1/0;for(let g=0;g<8;g++){const w=f[g];s.copy(w).clamp(d,h);const m=w.distanceToSquared(s);if(m<p&&(p=m,a&&a.copy(w),c&&c.copy(s),m<u))return Math.sqrt(m)}let x=0;for(let g=0;g<3;g++)for(let w=0;w<=1;w++)for(let m=0;m<=1;m++){const v=(g+1)%3,b=(g+2)%3,A=w<<v|m<<b,S=1<<g|w<<v|m<<b,T=f[A],M=f[S];t[x].set(T,M);const C=l[g],z=l[v],_=l[b],E=e[x],P=E.start,I=E.end;P[C]=d[C],P[z]=w?d[z]:h[z],P[_]=m?d[_]:h[z],I[C]=h[C],I[z]=w?d[z]:h[z],I[_]=m?d[_]:h[z],x++}for(let g=0;g<=1;g++)for(let w=0;w<=1;w++)for(let m=0;m<=1;m++){s.x=g?h.x:d.x,s.y=w?h.y:d.y,s.z=m?h.z:d.z,this.closestPointToPoint(s,n);const v=s.distanceToSquared(n);if(v<p&&(p=v,a&&a.copy(n),c&&c.copy(s),v<u))return Math.sqrt(v)}for(let g=0;g<12;g++){const w=t[g];for(let m=0;m<12;m++){const v=e[m];Fo(w,v,n,s);const b=n.distanceToSquared(s);if(b<p&&(p=b,a&&a.copy(n),c&&c.copy(s),b<u))return Math.sqrt(b)}}return Math.sqrt(p)}}();class Ro{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Yl extends Ro{constructor(){super(()=>new Vt)}}const Ft=new Yl;class Zl{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const Y=new Zl;let _e,fn;const tn=[],As=new Ro(()=>new Xt);function Kl(l,t,e,n,s,i){_e=As.getPrimitive(),fn=As.getPrimitive(),tn.push(_e,fn),Y.setBuffer(l._roots[t]);const o=So(0,l.geometry,e,n,s,i);Y.clearBuffer(),As.releasePrimitive(_e),As.releasePrimitive(fn),tn.pop(),tn.pop();const r=tn.length;return r>0&&(fn=tn[r-1],_e=tn[r-2]),o}function So(l,t,e,n,s=null,i=0,o=0){const{float32Array:r,uint16Array:a,uint32Array:c}=Y;let u=l*2;if(wt(u,a)){const h=vt(l,c),f=It(u,a);return K(l,r,_e),n(h,f,!1,o,i+l,_e)}else{let C=function(_){const{uint16Array:E,uint32Array:P}=Y;let I=_*2;for(;!wt(I,E);)_=Lt(_),I=_*2;return vt(_,P)},z=function(_){const{uint16Array:E,uint32Array:P}=Y;let I=_*2;for(;!wt(I,E);)_=Nt(_,P),I=_*2;return vt(_,P)+It(I,E)};const h=Lt(l),f=Nt(l,c);let p=h,x=f,g,w,m,v;if(s&&(m=_e,v=fn,K(p,r,m),K(x,r,v),g=s(m),w=s(v),w<g)){p=f,x=h;const _=g;g=w,w=_,m=v}m||(m=_e,K(p,r,m));const b=wt(p*2,a),A=e(m,b,g,o+1,i+p);let S;if(A===Ar){const _=C(p),P=z(p)-_;S=n(_,P,!0,o+1,i+p,m)}else S=A&&So(p,t,e,n,s,i,o+1);if(S)return!0;v=fn,K(x,r,v);const T=wt(x*2,a),M=e(v,T,w,o+1,i+x);let B;if(M===Ar){const _=C(x),P=z(x)-_;B=n(_,P,!0,o+1,i+x,v)}else B=M&&So(x,t,e,n,s,i,o+1);return!!B}}const Fn=new N,Ui=new N;function Jl(l,t,e={},n=0,s=1/0){const i=n*n,o=s*s;let r=1/0,a=null;if(l.shapecast({boundsTraverseOrder:u=>(Fn.copy(t).clamp(u.min,u.max),Fn.distanceToSquared(t)),intersectsBounds:(u,d,h)=>h<r&&h<o,intersectsTriangle:(u,d)=>{u.closestPointToPoint(t,Fn);const h=t.distanceToSquared(Fn);return h<r&&(Ui.copy(Fn),r=h,a=d),h<i}}),r===1/0)return null;const c=Math.sqrt(r);return e.point?e.point.copy(Ui):e.point=Ui.clone(),e.distance=c,e.faceIndex=a,e}const en=new N,nn=new N,sn=new N,Ss=new He,Ts=new He,Es=new He,Br=new N,Cr=new N,_r=new N,Ms=new N;function Ql(l,t,e,n,s,i){let o;return i===hl?o=l.intersectTriangle(n,e,t,!0,s):o=l.intersectTriangle(t,e,n,i!==Lo,s),o===null?null:{distance:l.origin.distanceTo(s),point:s.clone()}}function tu(l,t,e,n,s,i,o,r,a){en.fromBufferAttribute(t,i),nn.fromBufferAttribute(t,o),sn.fromBufferAttribute(t,r);const c=Ql(l,en,nn,sn,Ms,a);if(c){n&&(Ss.fromBufferAttribute(n,i),Ts.fromBufferAttribute(n,o),Es.fromBufferAttribute(n,r),c.uv=xt.getInterpolation(Ms,en,nn,sn,Ss,Ts,Es,new He)),s&&(Ss.fromBufferAttribute(s,i),Ts.fromBufferAttribute(s,o),Es.fromBufferAttribute(s,r),c.uv1=xt.getInterpolation(Ms,en,nn,sn,Ss,Ts,Es,new He)),e&&(Br.fromBufferAttribute(e,i),Cr.fromBufferAttribute(e,o),_r.fromBufferAttribute(e,r),c.normal=xt.getInterpolation(Ms,en,nn,sn,Br,Cr,_r,new N),c.normal.dot(l.direction)>0&&c.normal.multiplyScalar(-1));const u={a:i,b:o,c:r,normal:new N,materialIndex:0};xt.getNormal(en,nn,sn,u.normal),c.face=u,c.faceIndex=i}return c}function fi(l,t,e,n,s){const i=n*3;let o=i+0,r=i+1,a=i+2;const c=l.index;l.index&&(o=c.getX(o),r=c.getX(r),a=c.getX(a));const{position:u,normal:d,uv:h,uv1:f}=l.attributes,p=tu(e,u,d,h,f,o,r,a,t);return p?(p.faceIndex=n,s&&s.push(p),p):null}function et(l,t,e,n){const s=l.a,i=l.b,o=l.c;let r=t,a=t+1,c=t+2;e&&(r=e.getX(r),a=e.getX(a),c=e.getX(c)),s.x=n.getX(r),s.y=n.getY(r),s.z=n.getZ(r),i.x=n.getX(a),i.y=n.getY(a),i.z=n.getZ(a),o.x=n.getX(c),o.y=n.getY(c),o.z=n.getZ(c)}function eu(l,t,e,n,s,i){const{geometry:o,_indirectBuffer:r}=l;for(let a=n,c=n+s;a<c;a++)fi(o,t,e,a,i)}function nu(l,t,e,n,s){const{geometry:i,_indirectBuffer:o}=l;let r=1/0,a=null;for(let c=n,u=n+s;c<u;c++){let d;d=fi(i,t,e,c),d&&d.distance<r&&(a=d,r=d.distance)}return a}function su(l,t,e,n,s,i,o){const{geometry:r}=e,{index:a}=r,c=r.attributes.position;for(let u=l,d=t+l;u<d;u++){let h;if(h=u,et(o,h*3,a,c),o.needsUpdate=!0,n(o,h,s,i))return!0}return!1}function iu(l,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=l.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let i,o,r,a,c=0;const u=l._roots;for(let h=0,f=u.length;h<f;h++)i=u[h],o=new Uint32Array(i),r=new Uint16Array(i),a=new Float32Array(i),d(0,c),c+=i.byteLength;function d(h,f,p=!1){const x=h*2;if(r[x+15]===di){const w=o[h+6],m=r[x+14];let v=1/0,b=1/0,A=1/0,S=-1/0,T=-1/0,M=-1/0;for(let B=3*w,C=3*(w+m);B<C;B++){let z=n[B];const _=s.getX(z),E=s.getY(z),P=s.getZ(z);_<v&&(v=_),_>S&&(S=_),E<b&&(b=E),E>T&&(T=E),P<A&&(A=P),P>M&&(M=P)}return a[h+0]!==v||a[h+1]!==b||a[h+2]!==A||a[h+3]!==S||a[h+4]!==T||a[h+5]!==M?(a[h+0]=v,a[h+1]=b,a[h+2]=A,a[h+3]=S,a[h+4]=T,a[h+5]=M,!0):!1}else{const w=h+8,m=o[h+6],v=w+f,b=m+f;let A=p,S=!1,T=!1;t?A||(S=t.has(v),T=t.has(b),A=!S&&!T):(S=!0,T=!0);const M=A||S,B=A||T;let C=!1;M&&(C=d(w,f,A));let z=!1;B&&(z=d(m,f,A));const _=C||z;if(_)for(let E=0;E<3;E++){const P=w+E,I=m+E,L=a[P],j=a[P+3],V=a[I],q=a[I+3];a[h+E]=L<V?L:V,a[h+E+3]=j>q?j:q}return _}}}const Pr=new Xt;function Ie(l,t,e,n){return K(l,t,Pr),e.intersectBox(Pr,n)}function ou(l,t,e,n,s,i){const{geometry:o,_indirectBuffer:r}=l;for(let a=n,c=n+s;a<c;a++){let u=r?r[a]:a;fi(o,t,e,u,i)}}function ru(l,t,e,n,s){const{geometry:i,_indirectBuffer:o}=l;let r=1/0,a=null;for(let c=n,u=n+s;c<u;c++){let d;d=fi(i,t,e,o?o[c]:c),d&&d.distance<r&&(a=d,r=d.distance)}return a}function au(l,t,e,n,s,i,o){const{geometry:r}=e,{index:a}=r,c=r.attributes.position;for(let u=l,d=t+l;u<d;u++){let h;if(h=e.resolveTriangleIndex(u),et(o,h*3,a,c),o.needsUpdate=!0,n(o,h,s,i))return!0}return!1}const zr=new N;function cu(l,t,e,n,s){Y.setBuffer(l._roots[t]),To(0,l,e,n,s),Y.clearBuffer()}function To(l,t,e,n,s){const{float32Array:i,uint16Array:o,uint32Array:r}=Y,a=l*2;if(wt(a,o)){const u=vt(l,r),d=It(a,o);eu(t,e,n,u,d,s)}else{const u=Lt(l);Ie(u,i,n,zr)&&To(u,t,e,n,s);const d=Nt(l,r);Ie(d,i,n,zr)&&To(d,t,e,n,s)}}const Ir=new N,lu=["x","y","z"];function uu(l,t,e,n){Y.setBuffer(l._roots[t]);const s=Eo(0,l,e,n);return Y.clearBuffer(),s}function Eo(l,t,e,n){const{float32Array:s,uint16Array:i,uint32Array:o}=Y;let r=l*2;if(wt(r,i)){const c=vt(l,o),u=It(r,i);return nu(t,e,n,c,u)}else{const c=La(l,o),u=lu[c],h=n.direction[u]>=0;let f,p;h?(f=Lt(l),p=Nt(l,o)):(f=Nt(l,o),p=Lt(l));const g=Ie(f,s,n,Ir)?Eo(f,t,e,n):null;if(g){const v=g.point[u];if(h?v<=s[p+c]:v>=s[p+c+3])return g}const m=Ie(p,s,n,Ir)?Eo(p,t,e,n):null;return g&&m?g.distance<=m.distance?g:m:g||m||null}}const Bs=new Xt,on=new Vt,rn=new Vt,Rn=new ee,Lr=new ht,Cs=new ht;function hu(l,t,e,n){Y.setBuffer(l._roots[t]);const s=Mo(0,l,e,n);return Y.clearBuffer(),s}function Mo(l,t,e,n,s=null){const{float32Array:i,uint16Array:o,uint32Array:r}=Y;let a=l*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Lr.set(e.boundingBox.min,e.boundingBox.max,n),s=Lr),wt(a,o)){const u=t.geometry,d=u.index,h=u.attributes.position,f=e.index,p=e.attributes.position,x=vt(l,r),g=It(a,o);if(Rn.copy(n).invert(),e.boundsTree)return K(l,i,Cs),Cs.matrix.copy(Rn),Cs.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Cs.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let v=x*3,b=(g+x)*3;v<b;v+=3)if(et(rn,v,d,h),rn.needsUpdate=!0,m.intersectsTriangle(rn))return!0;return!1}});for(let w=x*3,m=(g+x)*3;w<m;w+=3){et(on,w,d,h),on.a.applyMatrix4(Rn),on.b.applyMatrix4(Rn),on.c.applyMatrix4(Rn),on.needsUpdate=!0;for(let v=0,b=f.count;v<b;v+=3)if(et(rn,v,f,p),rn.needsUpdate=!0,on.intersectsTriangle(rn))return!0}}else{const u=l+8,d=r[l+6];return K(u,i,Bs),!!(s.intersectsBox(Bs)&&Mo(u,t,e,n,s)||(K(d,i,Bs),s.intersectsBox(Bs)&&Mo(d,t,e,n,s)))}}const _s=new ee,Xi=new ht,Vn=new ht,du=new N,fu=new N,pu=new N,mu=new N;function wu(l,t,e,n={},s={},i=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Xi.set(t.boundingBox.min,t.boundingBox.max,e),Xi.needsUpdate=!0;const r=l.geometry,a=r.attributes.position,c=r.index,u=t.attributes.position,d=t.index,h=Ft.getPrimitive(),f=Ft.getPrimitive();let p=du,x=fu,g=null,w=null;s&&(g=pu,w=mu);let m=1/0,v=null,b=null;return _s.copy(e).invert(),Vn.matrix.copy(_s),l.shapecast({boundsTraverseOrder:A=>Xi.distanceToBox(A),intersectsBounds:(A,S,T)=>T<m&&T<o?(S&&(Vn.min.copy(A.min),Vn.max.copy(A.max),Vn.needsUpdate=!0),!0):!1,intersectsRange:(A,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>Vn.distanceToBox(M),intersectsBounds:(M,B,C)=>C<m&&C<o,intersectsRange:(M,B)=>{for(let C=M,z=M+B;C<z;C++){et(f,3*C,d,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let _=A,E=A+S;_<E;_++){et(h,3*_,c,a),h.needsUpdate=!0;const P=h.distanceToTriangle(f,p,g);if(P<m&&(x.copy(p),w&&w.copy(g),m=P,v=_,b=C),P<i)return!0}}}});{const T=Bn(t);for(let M=0,B=T;M<B;M++){et(f,3*M,d,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let C=A,z=A+S;C<z;C++){et(h,3*C,c,a),h.needsUpdate=!0;const _=h.distanceToTriangle(f,p,g);if(_<m&&(x.copy(p),w&&w.copy(g),m=_,v=C,b=M),_<i)return!0}}}}}),Ft.releasePrimitive(h),Ft.releasePrimitive(f),m===1/0?null:(n.point?n.point.copy(x):n.point=x.clone(),n.distance=m,n.faceIndex=v,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(_s),x.applyMatrix4(_s),s.distance=x.sub(s.point).length(),s.faceIndex=b),n)}function yu(l,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=l.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let i,o,r,a,c=0;const u=l._roots;for(let h=0,f=u.length;h<f;h++)i=u[h],o=new Uint32Array(i),r=new Uint16Array(i),a=new Float32Array(i),d(0,c),c+=i.byteLength;function d(h,f,p=!1){const x=h*2;if(r[x+15]===di){const w=o[h+6],m=r[x+14];let v=1/0,b=1/0,A=1/0,S=-1/0,T=-1/0,M=-1/0;for(let B=w,C=w+m;B<C;B++){const z=3*l.resolveTriangleIndex(B);for(let _=0;_<3;_++){let E=z+_;E=n?n[E]:E;const P=s.getX(E),I=s.getY(E),L=s.getZ(E);P<v&&(v=P),P>S&&(S=P),I<b&&(b=I),I>T&&(T=I),L<A&&(A=L),L>M&&(M=L)}}return a[h+0]!==v||a[h+1]!==b||a[h+2]!==A||a[h+3]!==S||a[h+4]!==T||a[h+5]!==M?(a[h+0]=v,a[h+1]=b,a[h+2]=A,a[h+3]=S,a[h+4]=T,a[h+5]=M,!0):!1}else{const w=h+8,m=o[h+6],v=w+f,b=m+f;let A=p,S=!1,T=!1;t?A||(S=t.has(v),T=t.has(b),A=!S&&!T):(S=!0,T=!0);const M=A||S,B=A||T;let C=!1;M&&(C=d(w,f,A));let z=!1;B&&(z=d(m,f,A));const _=C||z;if(_)for(let E=0;E<3;E++){const P=w+E,I=m+E,L=a[P],j=a[P+3],V=a[I],q=a[I+3];a[h+E]=L<V?L:V,a[h+E+3]=j>q?j:q}return _}}}const Nr=new N;function gu(l,t,e,n,s){Y.setBuffer(l._roots[t]),Bo(0,l,e,n,s),Y.clearBuffer()}function Bo(l,t,e,n,s){const{float32Array:i,uint16Array:o,uint32Array:r}=Y,a=l*2;if(wt(a,o)){const u=vt(l,r),d=It(a,o);ou(t,e,n,u,d,s)}else{const u=Lt(l);Ie(u,i,n,Nr)&&Bo(u,t,e,n,s);const d=Nt(l,r);Ie(d,i,n,Nr)&&Bo(d,t,e,n,s)}}const Fr=new N,xu=["x","y","z"];function vu(l,t,e,n){Y.setBuffer(l._roots[t]);const s=Co(0,l,e,n);return Y.clearBuffer(),s}function Co(l,t,e,n){const{float32Array:s,uint16Array:i,uint32Array:o}=Y;let r=l*2;if(wt(r,i)){const c=vt(l,o),u=It(r,i);return ru(t,e,n,c,u)}else{const c=La(l,o),u=xu[c],h=n.direction[u]>=0;let f,p;h?(f=Lt(l),p=Nt(l,o)):(f=Nt(l,o),p=Lt(l));const g=Ie(f,s,n,Fr)?Co(f,t,e,n):null;if(g){const v=g.point[u];if(h?v<=s[p+c]:v>=s[p+c+3])return g}const m=Ie(p,s,n,Fr)?Co(p,t,e,n):null;return g&&m?g.distance<=m.distance?g:m:g||m||null}}const Ps=new Xt,an=new Vt,cn=new Vt,kn=new ee,Rr=new ht,zs=new ht;function bu(l,t,e,n){Y.setBuffer(l._roots[t]);const s=_o(0,l,e,n);return Y.clearBuffer(),s}function _o(l,t,e,n,s=null){const{float32Array:i,uint16Array:o,uint32Array:r}=Y;let a=l*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Rr.set(e.boundingBox.min,e.boundingBox.max,n),s=Rr),wt(a,o)){const u=t.geometry,d=u.index,h=u.attributes.position,f=e.index,p=e.attributes.position,x=vt(l,r),g=It(a,o);if(kn.copy(n).invert(),e.boundsTree)return K(l,i,zs),zs.matrix.copy(kn),zs.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>zs.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let v=x,b=g+x;v<b;v++)if(et(cn,3*t.resolveTriangleIndex(v),d,h),cn.needsUpdate=!0,m.intersectsTriangle(cn))return!0;return!1}});for(let w=x,m=g+x;w<m;w++){const v=t.resolveTriangleIndex(w);et(an,3*v,d,h),an.a.applyMatrix4(kn),an.b.applyMatrix4(kn),an.c.applyMatrix4(kn),an.needsUpdate=!0;for(let b=0,A=f.count;b<A;b+=3)if(et(cn,b,f,p),cn.needsUpdate=!0,an.intersectsTriangle(cn))return!0}}else{const u=l+8,d=r[l+6];return K(u,i,Ps),!!(s.intersectsBox(Ps)&&_o(u,t,e,n,s)||(K(d,i,Ps),s.intersectsBox(Ps)&&_o(d,t,e,n,s)))}}const Is=new ee,Yi=new ht,qn=new ht,Au=new N,Su=new N,Tu=new N,Eu=new N;function Mu(l,t,e,n={},s={},i=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Yi.set(t.boundingBox.min,t.boundingBox.max,e),Yi.needsUpdate=!0;const r=l.geometry,a=r.attributes.position,c=r.index,u=t.attributes.position,d=t.index,h=Ft.getPrimitive(),f=Ft.getPrimitive();let p=Au,x=Su,g=null,w=null;s&&(g=Tu,w=Eu);let m=1/0,v=null,b=null;return Is.copy(e).invert(),qn.matrix.copy(Is),l.shapecast({boundsTraverseOrder:A=>Yi.distanceToBox(A),intersectsBounds:(A,S,T)=>T<m&&T<o?(S&&(qn.min.copy(A.min),qn.max.copy(A.max),qn.needsUpdate=!0),!0):!1,intersectsRange:(A,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:M=>qn.distanceToBox(M),intersectsBounds:(M,B,C)=>C<m&&C<o,intersectsRange:(M,B)=>{for(let C=M,z=M+B;C<z;C++){const _=T.resolveTriangleIndex(C);et(f,3*_,d,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let E=A,P=A+S;E<P;E++){const I=l.resolveTriangleIndex(E);et(h,3*I,c,a),h.needsUpdate=!0;const L=h.distanceToTriangle(f,p,g);if(L<m&&(x.copy(p),w&&w.copy(g),m=L,v=E,b=C),L<i)return!0}}}})}else{const T=Bn(t);for(let M=0,B=T;M<B;M++){et(f,3*M,d,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let C=A,z=A+S;C<z;C++){const _=l.resolveTriangleIndex(C);et(h,3*_,c,a),h.needsUpdate=!0;const E=h.distanceToTriangle(f,p,g);if(E<m&&(x.copy(p),w&&w.copy(g),m=E,v=C,b=M),E<i)return!0}}}}}),Ft.releasePrimitive(h),Ft.releasePrimitive(f),m===1/0?null:(n.point?n.point.copy(x):n.point=x.clone(),n.distance=m,n.faceIndex=v,s&&(s.point?s.point.copy(w):s.point=w.clone(),s.point.applyMatrix4(Is),x.applyMatrix4(Is),s.distance=x.sub(s.point).length(),s.faceIndex=b),n)}function Bu(){return typeof SharedArrayBuffer<"u"}const Yn=new Y.constructor,Js=new Y.constructor,Be=new Ro(()=>new Xt),ln=new Xt,un=new Xt,Zi=new Xt,Ki=new Xt;let Ji=!1;function Cu(l,t,e,n){if(Ji)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ji=!0;const s=l._roots,i=t._roots;let o,r=0,a=0;const c=new ee().copy(e).invert();for(let u=0,d=s.length;u<d;u++){Yn.setBuffer(s[u]),a=0;const h=Be.getPrimitive();K(0,Yn.float32Array,h),h.applyMatrix4(c);for(let f=0,p=i.length;f<p&&(Js.setBuffer(i[u]),o=$t(0,0,e,c,n,r,a,0,0,h),Js.clearBuffer(),a+=i[f].length,!o);f++);if(Be.releasePrimitive(h),Yn.clearBuffer(),r+=s[u].length,o)break}return Ji=!1,o}function $t(l,t,e,n,s,i=0,o=0,r=0,a=0,c=null,u=!1){let d,h;u?(d=Js,h=Yn):(d=Yn,h=Js);const f=d.float32Array,p=d.uint32Array,x=d.uint16Array,g=h.float32Array,w=h.uint32Array,m=h.uint16Array,v=l*2,b=t*2,A=wt(v,x),S=wt(b,m);let T=!1;if(S&&A)u?T=s(vt(t,w),It(t*2,m),vt(l,p),It(l*2,x),a,o+t,r,i+l):T=s(vt(l,p),It(l*2,x),vt(t,w),It(t*2,m),r,i+l,a,o+t);else if(S){const M=Be.getPrimitive();K(t,g,M),M.applyMatrix4(e);const B=Lt(l),C=Nt(l,p);K(B,f,ln),K(C,f,un);const z=M.intersectsBox(ln),_=M.intersectsBox(un);T=z&&$t(t,B,n,e,s,o,i,a,r+1,M,!u)||_&&$t(t,C,n,e,s,o,i,a,r+1,M,!u),Be.releasePrimitive(M)}else{const M=Lt(t),B=Nt(t,w);K(M,g,Zi),K(B,g,Ki);const C=c.intersectsBox(Zi),z=c.intersectsBox(Ki);if(C&&z)T=$t(l,M,e,n,s,i,o,r,a+1,c,u)||$t(l,B,e,n,s,i,o,r,a+1,c,u);else if(C)if(A)T=$t(l,M,e,n,s,i,o,r,a+1,c,u);else{const _=Be.getPrimitive();_.copy(Zi).applyMatrix4(e);const E=Lt(l),P=Nt(l,p);K(E,f,ln),K(P,f,un);const I=_.intersectsBox(ln),L=_.intersectsBox(un);T=I&&$t(M,E,n,e,s,o,i,a,r+1,_,!u)||L&&$t(M,P,n,e,s,o,i,a,r+1,_,!u),Be.releasePrimitive(_)}else if(z)if(A)T=$t(l,B,e,n,s,i,o,r,a+1,c,u);else{const _=Be.getPrimitive();_.copy(Ki).applyMatrix4(e);const E=Lt(l),P=Nt(l,p);K(E,f,ln),K(P,f,un);const I=_.intersectsBox(ln),L=_.intersectsBox(un);T=I&&$t(B,E,n,e,s,o,i,a,r+1,_,!u)||L&&$t(B,P,n,e,s,o,i,a,r+1,_,!u),Be.releasePrimitive(_)}}return T}const Ls=new ht,Vr=new Xt,_u={strategy:Pa,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Vo{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,i=t._indirectBuffer,o=n.getIndex();let r;return e.cloneBuffers?r={roots:s.map(a=>a.slice()),index:o.array.slice(),indirectBuffer:i?i.slice():null}:r={roots:s,index:o.array,indirectBuffer:i},r}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:s,roots:i,indirectBuffer:o}=t,r=new Vo(e,{...n,[Gi]:!0});if(r._roots=i,r._indirectBuffer=o||null,n.setIndex){const a=e.getIndex();if(a===null){const c=new ci(t.index,1,!1);e.setIndex(c)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({..._u,[Gi]:!1},e),e.useSharedArrayBuffer&&!Bu())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Gi]||(Hl(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Xt)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?s=>n[s]:s=>s}refit(t=null){return(this.indirect?yu:iu)(this,t)}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),i=new Uint16Array(n);o(0);function o(r,a=0){const c=r*2,u=i[c+15]===di;if(u){const d=s[r+6],h=i[c+14];t(a,u,new Float32Array(n,r*4,6),d,h)}else{const d=r+Xn/4,h=s[r+6],f=s[r+7];t(a,u,new Float32Array(n,r*4,6),f)||(o(d,a+1),o(h,a+1))}}}raycast(t,e=wr){const n=this._roots,s=this.geometry,i=[],o=e.isMaterial,r=Array.isArray(e),a=s.groups,c=o?e.side:e,u=this.indirect?gu:cu;for(let d=0,h=n.length;d<h;d++){const f=r?e[a[d].materialIndex].side:c,p=i.length;if(u(this,d,f,t,i),r){const x=a[d].materialIndex;for(let g=p,w=i.length;g<w;g++)i[g].face.materialIndex=x}}return i}raycastFirst(t,e=wr){const n=this._roots,s=this.geometry,i=e.isMaterial,o=Array.isArray(e);let r=null;const a=s.groups,c=i?e.side:e,u=this.indirect?vu:uu;for(let d=0,h=n.length;d<h;d++){const f=o?e[a[d].materialIndex].side:c,p=u(this,d,f,t);p!=null&&(r==null||p.distance<r.distance)&&(r=p,o&&(p.face.materialIndex=a[d].materialIndex))}return r}intersectsGeometry(t,e){let n=!1;const s=this._roots,i=this.indirect?bu:hu;for(let o=0,r=s.length;o<r&&(n=i(this,o,t,e),!n);o++);return n}shapecast(t){const e=Ft.getPrimitive(),n=this.indirect?au:su;let{boundsTraverseOrder:s,intersectsBounds:i,intersectsRange:o,intersectsTriangle:r}=t;if(o&&r){const d=o;o=(h,f,p,x,g)=>d(h,f,p,x,g)?!0:n(h,f,this,r,p,x,e)}else o||(r?o=(d,h,f,p)=>n(d,h,this,r,f,p,e):o=(d,h,f)=>f);let a=!1,c=0;const u=this._roots;for(let d=0,h=u.length;d<h;d++){const f=u[d];if(a=Kl(this,d,i,o,s,c),a)break;c+=f.byteLength}return Ft.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:i}=n;const o=Ft.getPrimitive(),r=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?p=>{const x=this.resolveTriangleIndex(p);et(o,x*3,r,a)}:p=>{et(o,p*3,r,a)},u=Ft.getPrimitive(),d=t.geometry.index,h=t.geometry.attributes.position,f=t.indirect?p=>{const x=t.resolveTriangleIndex(p);et(u,x*3,d,h)}:p=>{et(u,p*3,d,h)};if(i){const p=(x,g,w,m,v,b,A,S)=>{for(let T=w,M=w+m;T<M;T++){f(T),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let B=x,C=x+g;B<C;B++)if(c(B),o.needsUpdate=!0,i(o,u,B,T,v,b,A,S))return!0}return!1};if(s){const x=s;s=function(g,w,m,v,b,A,S,T){return x(g,w,m,v,b,A,S,T)?!0:p(g,w,m,v,b,A,S,T)}}else s=p}return Cu(this,t,e,s)}intersectsBox(t,e){return Ls.set(t.min,t.max,e),Ls.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Ls.intersectsBox(n),intersectsTriangle:n=>Ls.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},i=0,o=1/0){return(this.indirect?Mu:wu)(this,t,e,n,s,i,o)}closestPointToPoint(t,e={},n=0,s=1/0){return Jl(this,t,e,n,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{K(0,new Float32Array(n),Vr),t.union(Vr)}),t}}const Ra=1e-6,Pu=Ra*.5,Va=Math.pow(10,-Math.log10(Ra)),zu=Pu*Va;function te(l){return~~(l*Va+zu)}function Iu(l){return`${te(l.x)},${te(l.y)}`}function kr(l){return`${te(l.x)},${te(l.y)},${te(l.z)}`}function Lu(l){return`${te(l.x)},${te(l.y)},${te(l.z)},${te(l.w)}`}function Nu(l,t,e){e.direction.subVectors(t,l).normalize();const n=l.dot(e.direction);return e.origin.copy(l).addScaledVector(e.direction,-n),e}function ka(){return typeof SharedArrayBuffer<"u"}function Fu(l){if(l.buffer instanceof SharedArrayBuffer)return l;const t=l.constructor,e=l.buffer,n=new SharedArrayBuffer(e.byteLength),s=new Uint8Array(e);return new Uint8Array(n).set(s,0),new t(n)}function Ru(l,t=ArrayBuffer){return l>65535?new Uint32Array(new t(4*l)):new Uint16Array(new t(2*l))}function Vu(l,t){if(!l.index){const e=l.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ru(e,n);l.setIndex(new ci(s,1));for(let i=0;i<e;i++)s[i]=i}}function ku(l){return l.index?l.index.count:l.attributes.position.count}function ko(l){return ku(l)/3}const qu=1e-8,ju=new N;function Ou(l){return~~(l/3)}function Wu(l){return l%3}function qr(l,t){return l.start-t.start}function jr(l,t){return ju.subVectors(t,l.origin).dot(l.direction)}function Gu(l,t,e,n=qu){l.sort(qr),t.sort(qr);for(let r=0;r<l.length;r++){const a=l[r];for(let c=0;c<t.length;c++){const u=t[c];if(!(u.start>a.end)){if(a.end<u.start||u.end<a.start)continue;if(a.start<=u.start&&a.end>=u.end)i(u.end,a.end)||l.splice(r+1,0,{start:u.end,end:a.end,index:a.index}),a.end=u.start,u.start=0,u.end=0;else if(a.start>=u.start&&a.end<=u.end)i(a.end,u.end)||t.splice(c+1,0,{start:a.end,end:u.end,index:u.index}),u.end=a.start,a.start=0,a.end=0;else if(a.start<=u.start&&a.end<=u.end){const d=a.end;a.end=u.start,u.start=d}else if(a.start>=u.start&&a.end>=u.end){const d=u.end;u.end=a.start,a.start=d}else throw new Error}if(e.has(a.index)||e.set(a.index,[]),e.has(u.index)||e.set(u.index,[]),e.get(a.index).push(u.index),e.get(u.index).push(a.index),o(u)&&(t.splice(c,1),c--),o(a)){l.splice(r,1),r--;break}}}s(l),s(t);function s(r){for(let a=0;a<r.length;a++)o(r[a])&&(r.splice(a,1),a--)}function i(r,a){return Math.abs(a-r)<n}function o(r){return Math.abs(r.end-r.start)<n}}const Or=1e-5,Wr=1e-4;class $u{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let s=1/0,i=null;for(let a=0,c=e.length;a<c;a++){const u=e[a];if(o(u,t)&&o(u,n))continue;const d=r(u,t),h=r(u,n),f=Math.min(d,h);f<s&&(s=f,i=u)}return i;function o(a,c){const u=a.origin.distanceTo(c.origin)>Or;return a.direction.angleTo(c.direction)>Wr||u}function r(a,c){const u=a.origin.distanceTo(c.origin),d=a.direction.angleTo(c.direction);return u/Or+d/Wr}}}const Qi=new N,to=new N,Ns=new Ba;function Hu(l,t,e){const n=l.attributes,s=l.index,i=n.position,o=new Map,r=new Map,a=Array.from(t),c=new $u;for(let u=0,d=a.length;u<d;u++){const h=a[u],f=Ou(h),p=Wu(h);let x=3*f+p,g=3*f+(p+1)%3;s&&(x=s.getX(x),g=s.getX(g)),Qi.fromBufferAttribute(i,x),to.fromBufferAttribute(i,g),Nu(Qi,to,Ns);let w,m=c.findClosestRay(Ns);m===null&&(m=Ns.clone(),c.addRay(m)),r.has(m)||r.set(m,{forward:[],reverse:[],ray:m}),w=r.get(m);let v=jr(m,Qi),b=jr(m,to);v>b&&([v,b]=[b,v]),Ns.direction.dot(m.direction)<0?w.reverse.push({start:v,end:b,index:h}):w.forward.push({start:v,end:b,index:h})}return r.forEach(({forward:u,reverse:d},h)=>{Gu(u,d,o,e),u.length===0&&d.length===0&&r.delete(h)}),{disjointConnectivityMap:o,fragmentMap:r}}const Du=new He,eo=new N,Uu=new Ue,no=["","",""];class Xu{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(i=>~~(i/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(i=>i%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:s,degenerateEpsilon:i}=this,o=e?v:m,r=new Map,{attributes:a}=t,c=e?Object.keys(a):null,u=t.index,d=a.position;let h=ko(t);const f=h;let p=0;n&&(p=t.drawRange.start,t.drawRange.count!==1/0&&(h=~~(t.drawRange.count/3)));let x=this.data;(!x||x.length<3*f)&&(x=new Int32Array(3*f)),x.fill(-1);let g=0,w=new Set;for(let b=p,A=h*3+p;b<A;b+=3){const S=b;for(let T=0;T<3;T++){let M=S+T;u&&(M=u.getX(M)),no[T]=o(M)}for(let T=0;T<3;T++){const M=(T+1)%3,B=no[T],C=no[M],z=`${C}_${B}`;if(r.has(z)){const _=S+T,E=r.get(z);x[_]=E,x[E]=_,r.delete(z),g+=2,w.delete(E)}else{const _=`${B}_${C}`,E=S+T;r.set(_,E),w.add(E)}}}if(s){const{fragmentMap:b,disjointConnectivityMap:A}=Hu(t,w,i);w.clear(),b.forEach(({forward:S,reverse:T})=>{S.forEach(({index:M})=>w.add(M)),T.forEach(({index:M})=>w.add(M))}),this.unmatchedDisjointEdges=b,this.disjointConnections=A,g=h*3-w.size}this.matchedEdges=g,this.unmatchedEdges=w.size,this.data=x;function m(b){return eo.fromBufferAttribute(d,b),kr(eo)}function v(b){let A="";for(let S=0,T=c.length;S<T;S++){const M=a[c[S]];let B;switch(M.itemSize){case 1:B=te(M.getX(b));break;case 2:B=Iu(Du.fromBufferAttribute(M,b));break;case 3:B=kr(eo.fromBufferAttribute(M,b));break;case 4:B=Lu(Uu.fromBufferAttribute(M,b));break}A!==""&&(A+="|"),A+=B}return A}}}class At extends G{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new ee,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,s=e.elements;for(let i=0;i<16;i++)if(n[i]!==s[i])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=ka();if(n)for(const s in e){const i=e[s];if(i.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");i.array=Fu(i.array)}if(t.boundsTree||(Vu(t,{useSharedArrayBuffer:n}),t.boundsTree=new Vo(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Xu(t)),!t.groupIndices){const s=ko(t),i=new Uint16Array(s),o=t.groups;for(let r=0,a=o.length;r<a;r++){const{start:c,count:u}=o[r];for(let d=c/3,h=(c+u)/3;d<h;d++)i[d]=r}t.groupIndices=i}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Yu=1e-14,so=new N,Gr=new N,$r=new N;function Ce(l,t=Yu){so.subVectors(l.b,l.a),Gr.subVectors(l.c,l.a),$r.subVectors(l.b,l.c);const e=so.angleTo(Gr),n=so.angleTo($r),s=Math.PI-e-n;return Math.abs(e)<t||Math.abs(n)<t||Math.abs(s)<t||l.a.distanceToSquared(l.b)<t||l.a.distanceToSquared(l.c)<t||l.b.distanceToSquared(l.c)<t}const io=1e-10,jn=1e-10,Zu=1e-10,oe=new Rt,J=new Rt,re=new N,oo=new N,Hr=new N,Fs=new Io,ro=new Vt;class Ku{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new xt),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class Ju{constructor(){this.trianglePool=new Ku,this.triangles=[],this.normal=new N,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:s}=this;if(Array.isArray(t))for(let i=0,o=t.length;i<o;i++){const r=t[i];if(i===0)r.getNormal(s);else if(Math.abs(1-r.getNormal(re).dot(s))>io)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const a=n.getTriangle();a.copy(r),e.push(a)}else{t.getNormal(s);const i=n.getTriangle();i.copy(t),e.push(i)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(oo).normalize(),Math.abs(1-Math.abs(oo.dot(e)))<Zu){this.coplanarTriangleUsed=!0;for(let i=0,o=n.length;i<o;i++){const r=n[i];r.coplanarCount=0}const s=[t.a,t.b,t.c];for(let i=0;i<3;i++){const o=(i+1)%3,r=s[i],a=s[o];re.subVectors(a,r).normalize(),Hr.crossVectors(oo,re),Fs.setFromNormalAndCoplanarPoint(Hr,r),this.splitByPlane(Fs,t)}}else t.getPlane(Fs),this.splitByPlane(Fs,t)}splitByPlane(t,e){const{triangles:n,trianglePool:s}=this;ro.copy(e),ro.needsUpdate=!0;for(let i=0,o=n.length;i<o;i++){const r=n[i];if(!ro.intersectsTriangle(r,oe,!0))continue;const{a,b:c,c:u}=r;let d=0,h=-1,f=!1,p=[],x=[];const g=[a,c,u];for(let w=0;w<3;w++){const m=(w+1)%3;oe.start.copy(g[w]),oe.end.copy(g[m]);const v=t.distanceToPoint(oe.start),b=t.distanceToPoint(oe.end);if(Math.abs(v)<jn&&Math.abs(b)<jn){f=!0;break}if(v>0?p.push(w):x.push(w),Math.abs(v)<jn)continue;let A=!!t.intersectLine(oe,re);!A&&Math.abs(b)<jn&&(re.copy(oe.end),A=!0),A&&!(re.distanceTo(oe.start)<io)&&(re.distanceTo(oe.end)<io&&(h=w),d===0?J.start.copy(re):J.end.copy(re),d++)}if(!f&&d===2&&J.distance()>jn)if(h!==-1){h=(h+1)%3;let w=0;w===h&&(w=(w+1)%3);let m=w+1;m===h&&(m=(m+1)%3);const v=s.getTriangle();v.a.copy(g[m]),v.b.copy(J.end),v.c.copy(J.start),Ce(v)||n.push(v),r.a.copy(g[w]),r.b.copy(J.start),r.c.copy(J.end),Ce(r)&&(n.splice(i,1),i--,o--)}else{const w=p.length>=2?x[0]:p[0];if(w===0){let S=J.start;J.start=J.end,J.end=S}const m=(w+1)%3,v=(w+2)%3,b=s.getTriangle(),A=s.getTriangle();g[m].distanceToSquared(J.start)<g[v].distanceToSquared(J.end)?(b.a.copy(g[m]),b.b.copy(J.start),b.c.copy(J.end),A.a.copy(g[m]),A.b.copy(g[v]),A.c.copy(J.start)):(b.a.copy(g[v]),b.b.copy(J.start),b.c.copy(J.end),A.a.copy(g[m]),A.b.copy(g[v]),A.c.copy(J.end)),r.a.copy(g[w]),r.b.copy(J.end),r.c.copy(J.start),Ce(b)||n.push(b),Ce(A)||n.push(A),Ce(r)&&(n.splice(i,1),i--,o--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function Qu(l){return l=~~l,l+4-l%4}class Dr{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=ka()?SharedArrayBuffer:ArrayBuffer,s=new e(new n(Qu(t*e.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let s=0,i=t.length;s<i;s++)e[n+s]=t[s];this.length+=t.length}clear(){this.length=0}}class th{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let s=0;for(let i=0;i<e;i++){const o=n[i];s+=o[t].length}return s}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const s={};e.push(s);for(const i in n){const o=n[i],r=new Dr(o.type);r.itemSize=o.itemSize,r.normalized=o.normalized,s[i]=r}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,s){const{groupAttributes:i}=this,r=i[0][t];if(r){if(r.type!==e)for(let a=0,c=i.length;a<c;a++){const u=i[a][t];u.setType(e),u.itemSize=n,u.normalized=s}}else for(let a=0,c=i.length;a<c;a++){const u=new Dr(e);u.itemSize=n,u.normalized=s,i[a][t]=u}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const n in e)e[n].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Ur{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:s}=this;n[t]||(n[t]=[],s.push(t)),n[t].push(e)}}const me=0,qo=1,eh=2,nh=3,sh=4,qa=5,ja=6,Pt=new Ba,Xr=new ee,lt=new xt,ae=new N,Yr=new Ue,Zr=new Ue,Kr=new Ue,ao=new Ue,Rs=new Ue,Vs=new Ue,Jr=new Rt,co=new N,lo=1e-8,ih=1e-15,je=-1,Oe=1,Us=-2,Xs=2,Zn=0,Ve=1,jo=2,oh=1e-14;let Ys=null;function Qr(l){Ys=l}function Oa(l,t){l.getMidpoint(Pt.origin),l.getNormal(Pt.direction);const e=t.raycastFirst(Pt,Lo);return!!(e&&Pt.direction.dot(e.face.normal)>0)?je:Oe}function rh(l,t){function e(){return Math.random()-.5}l.getNormal(co),Pt.direction.copy(co),l.getMidpoint(Pt.origin);const n=3;let s=0,i=1/0;for(let o=0;o<n;o++){Pt.direction.x+=e()*lo,Pt.direction.y+=e()*lo,Pt.direction.z+=e()*lo,Pt.direction.multiplyScalar(-1);const r=t.raycastFirst(Pt,Lo);if(!!(r&&Pt.direction.dot(r.face.normal)>0)&&s++,r!==null&&(i=Math.min(i,r.distance)),i<=ih)return r.face.normal.dot(co)>0?Xs:Us;if(s/n>.5||(o-s+1)/n>.5)break}return s/n>.5?je:Oe}function ah(l,t){const e=new Ur,n=new Ur;return Xr.copy(l.matrixWorld).invert().multiply(t.matrixWorld),l.geometry.boundsTree.bvhcast(t.geometry.boundsTree,Xr,{intersectsTriangles(s,i,o,r){if(!Ce(s)&&!Ce(i)){let a=s.intersectsTriangle(i,Jr,!0);if(!a){const c=s.plane,u=i.plane,d=c.normal,h=u.normal;d.dot(h)===1&&Math.abs(c.constant-u.constant)<oh&&(a=!0)}if(a){let c=l.geometry.boundsTree.resolveTriangleIndex(o),u=t.geometry.boundsTree.resolveTriangleIndex(r);e.add(c,u),n.add(u,c),Ys&&(Ys.addEdge(Jr),Ys.addIntersectingTriangles(o,s,r,i))}}return!1}}),{aIntersections:e,bIntersections:n}}function ch(l,t,e,n,s,i,o=!1){const r=e.attributes,a=e.index,c=l*3,u=a.getX(c+0),d=a.getX(c+1),h=a.getX(c+2);for(const f in i){const p=r[f],x=i[f];if(!(f in r))throw new Error(`CSG Operations: Attribute ${f} not available on geometry.`);const g=p.itemSize;f==="position"?(lt.a.fromBufferAttribute(p,u).applyMatrix4(n),lt.b.fromBufferAttribute(p,d).applyMatrix4(n),lt.c.fromBufferAttribute(p,h).applyMatrix4(n),uo(lt.a,lt.b,lt.c,t,3,x,o)):f==="normal"?(lt.a.fromBufferAttribute(p,u).applyNormalMatrix(s),lt.b.fromBufferAttribute(p,d).applyNormalMatrix(s),lt.c.fromBufferAttribute(p,h).applyNormalMatrix(s),o&&(lt.a.multiplyScalar(-1),lt.b.multiplyScalar(-1),lt.c.multiplyScalar(-1)),uo(lt.a,lt.b,lt.c,t,3,x,o,!0)):(Yr.fromBufferAttribute(p,u),Zr.fromBufferAttribute(p,d),Kr.fromBufferAttribute(p,h),uo(Yr,Zr,Kr,t,g,x,o))}}function lh(l,t,e,n,s,i,o,r=!1){ho(l,n,s,i,o,r),ho(r?e:t,n,s,i,o,r),ho(r?t:e,n,s,i,o,r)}function Wa(l,t,e=!1){switch(l){case me:if(t===Oe||t===Xs&&!e)return Ve;break;case qo:if(e){if(t===je)return Zn}else if(t===Oe||t===Us)return Ve;break;case eh:if(e){if(t===Oe||t===Us)return Ve}else if(t===je)return Zn;break;case sh:if(t===je)return Zn;if(t===Oe)return Ve;break;case nh:if(t===je||t===Xs&&!e)return Ve;break;case qa:if(!e&&(t===Oe||t===Us))return Ve;break;case ja:if(!e&&(t===je||t===Xs))return Ve;break;default:throw new Error(`Unrecognized CSG operation enum "${l}".`)}return jo}function uo(l,t,e,n,s,i,o=!1,r=!1){const a=c=>{i.push(c.x),s>1&&i.push(c.y),s>2&&i.push(c.z),s>3&&i.push(c.w)};ao.set(0,0,0,0).addScaledVector(l,n.a.x).addScaledVector(t,n.a.y).addScaledVector(e,n.a.z),Rs.set(0,0,0,0).addScaledVector(l,n.b.x).addScaledVector(t,n.b.y).addScaledVector(e,n.b.z),Vs.set(0,0,0,0).addScaledVector(l,n.c.x).addScaledVector(t,n.c.y).addScaledVector(e,n.c.z),r&&(ao.normalize(),Rs.normalize(),Vs.normalize()),a(ao),o?(a(Vs),a(Rs)):(a(Rs),a(Vs))}function ho(l,t,e,n,s,i=!1){for(const o in s){const r=t[o],a=s[o];if(!(o in t))throw new Error(`CSG Operations: Attribute ${o} no available on geometry.`);const c=r.itemSize;o==="position"?(ae.fromBufferAttribute(r,l).applyMatrix4(e),a.push(ae.x,ae.y,ae.z)):o==="normal"?(ae.fromBufferAttribute(r,l).applyNormalMatrix(n),i&&ae.multiplyScalar(-1),a.push(ae.x,ae.y,ae.z)):(a.push(r.getX(l)),c>1&&a.push(r.getY(l)),c>2&&a.push(r.getZ(l)),c>3&&a.push(r.getW(l)))}}class uh{constructor(t){this.triangle=new xt().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new xt().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class ta{constructor(){this.data={}}addTriangleIntersection(t,e,n,s){const{data:i}=this;i[t]||(i[t]=new uh(e)),i[t].addTriangle(n,s)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const s in e)n.push(e[s].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,s=new Set,i=[],o=r=>{if(n[r])if(e!==null)n[r].intersects[e]&&i.push(n[r].intersects[e]);else{const a=n[r].intersects;for(const c in a)s.has(c)||(s.add(c),i.push(a[c]))}};if(t!==null)o(t);else for(const r in n)o(r);return i}reset(){this.data={}}}class hh{constructor(){this.enabled=!1,this.triangleIntersectsA=new ta,this.triangleIntersectsB=new ta,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,s){const{triangleIntersectsA:i,triangleIntersectsB:o}=this;i.addTriangleIntersection(t,e,n,s),o.addTriangleIntersection(n,s,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Qr(this))}complete(){this.enabled&&Qr(null)}}const Pe=new ee,Qs=new dl,ke=new xt,ks=new xt,Ee=new xt,qs=new xt,Ht=[],$e=[];function dh(l){for(const t of l)return t}function fh(l,t,e,n,s,i={}){const{useGroups:o=!0}=i,{aIntersections:r,bIntersections:a}=ah(l,t),c=[];let u=null,d;return d=o?0:-1,ea(l,t,r,e,!1,n,s,d),na(l,t,r,e,!1,s,d),e.findIndex(f=>f!==ja&&f!==qa)!==-1&&(d=o?l.geometry.groups.length||1:-1,ea(t,l,a,e,!0,n,s,d),na(t,l,a,e,!0,s,d)),Ht.length=0,$e.length=0,{groups:c,materials:u}}function ea(l,t,e,n,s,i,o,r=0){const a=l.matrixWorld.determinant()<0;Pe.copy(t.matrixWorld).invert().multiply(l.matrixWorld),Qs.getNormalMatrix(l.matrixWorld).multiplyScalar(a?-1:1);const c=l.geometry.groupIndices,u=l.geometry.index,d=l.geometry.attributes.position,h=t.geometry.boundsTree,f=t.geometry.index,p=t.geometry.attributes.position,x=e.ids,g=e.intersectionSet;for(let w=0,m=x.length;w<m;w++){const v=x[w],b=r===-1?0:c[v]+r,A=3*v,S=u.getX(A+0),T=u.getX(A+1),M=u.getX(A+2);ke.a.fromBufferAttribute(d,S).applyMatrix4(Pe),ke.b.fromBufferAttribute(d,T).applyMatrix4(Pe),ke.c.fromBufferAttribute(d,M).applyMatrix4(Pe),i.reset(),i.initialize(ke);const B=g[v];for(let z=0,_=B.length;z<_;z++){const E=3*B[z],P=f.getX(E+0),I=f.getX(E+1),L=f.getX(E+2);ks.a.fromBufferAttribute(p,P),ks.b.fromBufferAttribute(p,I),ks.c.fromBufferAttribute(p,L),i.splitByTriangle(ks)}const C=i.triangles;for(let z=0,_=C.length;z<_;z++){const E=C[z],P=i.coplanarTriangleUsed?rh(E,h):Oa(E,h);Ht.length=0,$e.length=0;for(let I=0,L=n.length;I<L;I++){const j=Wa(n[I],P,s);j!==jo&&($e.push(j),Ht.push(o[I].getGroupAttrSet(b)))}if(Ht.length!==0){ke.getBarycoord(E.a,qs.a),ke.getBarycoord(E.b,qs.b),ke.getBarycoord(E.c,qs.c);for(let I=0,L=Ht.length;I<L;I++){const j=Ht[I],q=$e[I]===Zn;ch(v,qs,l.geometry,l.matrixWorld,Qs,j,a!==q)}}}}return x.length}function na(l,t,e,n,s,i,o=0){const r=l.matrixWorld.determinant()<0;Pe.copy(t.matrixWorld).invert().multiply(l.matrixWorld),Qs.getNormalMatrix(l.matrixWorld).multiplyScalar(r?-1:1);const a=t.geometry.boundsTree,c=l.geometry.groupIndices,u=l.geometry.index,d=l.geometry.attributes,h=d.position,f=[],p=l.geometry.halfEdges,x=new Set,g=ko(l.geometry);for(let w=0,m=g;w<m;w++)w in e.intersectionSet||x.add(w);for(;x.size>0;){const w=dh(x);x.delete(w),f.push(w);const m=3*w,v=u.getX(m+0),b=u.getX(m+1),A=u.getX(m+2);Ee.a.fromBufferAttribute(h,v).applyMatrix4(Pe),Ee.b.fromBufferAttribute(h,b).applyMatrix4(Pe),Ee.c.fromBufferAttribute(h,A).applyMatrix4(Pe);const S=Oa(Ee,a);$e.length=0,Ht.length=0;for(let T=0,M=n.length;T<M;T++){const B=Wa(n[T],S,s);B!==jo&&($e.push(B),Ht.push(i[T]))}for(;f.length>0;){const T=f.pop();for(let M=0;M<3;M++){const B=p.getSiblingTriangleIndex(T,M);B!==-1&&x.has(B)&&(f.push(B),x.delete(B))}if(Ht.length!==0){const M=3*T,B=u.getX(M+0),C=u.getX(M+1),z=u.getX(M+2),_=o===-1?0:c[T]+o;if(Ee.a.fromBufferAttribute(h,B),Ee.b.fromBufferAttribute(h,C),Ee.c.fromBufferAttribute(h,z),!Ce(Ee))for(let E=0,P=Ht.length;E<P;E++){const I=$e[E],L=Ht[E].getGroupAttrSet(_),j=I===Zn;lh(B,C,z,d,l.matrixWorld,Qs,L,j!==r)}}}}}function ph(l){for(let t=0;t<l.length-1;t++){const e=l[t],n=l[t+1];if(e.materialIndex===n.materialIndex){const s=e.start,i=n.start+n.count;n.start=s,n.count=i-s,l.splice(t,1),t--}}}function mh(l,t,e,n){e.clear();const s=l.attributes;for(let i=0,o=n.length;i<o;i++){const r=n[i],a=s[r];e.initializeArray(r,a.array.constructor,a.itemSize,a.normalized)}for(const i in e.attributes)n.includes(i)||e.delete(i);for(const i in t.attributes)n.includes(i)||(t.deleteAttribute(i),t.dispose())}function wh(l,t,e){let n=!1,s=-1;const i=l.attributes,o=t.groupAttributes[0];for(const a in o){const c=t.getTotalLength(a),u=t.getType(a),d=t.getItemSize(a),h=t.getNormalized(a);let f=i[a];(!f||f.array.length<c)&&(f=new ci(new u(c),d,h),l.setAttribute(a,f),n=!0);let p=0;for(let x=0,g=Math.min(e.length,t.groupCount);x<g;x++){const w=e[x].index,{array:m,type:v,length:b}=t.groupAttributes[w][a],A=new v(m.buffer,0,b);f.array.set(A,p),p+=A.length}f.needsUpdate=!0,s=c/f.itemSize}if(l.index){const a=l.index.array;if(a.length<s)l.index=null,n=!0;else for(let c=0,u=a.length;c<u;c++)a[c]=c}let r=0;l.clearGroups();for(let a=0,c=Math.min(e.length,t.groupCount);a<c;a++){const{index:u,materialIndex:d}=e[a],h=t.getCount(u);h!==0&&(l.addGroup(r,h,d),r+=h)}l.setDrawRange(0,s),l.boundsTree=null,n&&l.dispose()}function sa(l,t){let e=t;return Array.isArray(t)||(e=[],l.forEach(n=>{e[n.materialIndex]=t})),e}class Ga{constructor(){this.triangleSplitter=new Ju,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new hh}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,n,s=new At){let i=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s],i=!1),s.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:o,attributeData:r,attributes:a,useGroups:c,consolidateGroups:u,debug:d}=this;for(;r.length<s.length;)r.push(new th);s.forEach((w,m)=>{mh(t.geometry,w.geometry,r[m],a)}),d.init(),fh(t,e,n,o,r,{useGroups:c}),d.complete();const h=this.getGroupRanges(t.geometry),f=sa(h,t.material),p=this.getGroupRanges(e.geometry),x=sa(p,e.material);p.forEach(w=>w.materialIndex+=f.length);let g=[...h,...p].map((w,m)=>({...w,index:m}));if(c){const w=[...f,...x];u&&(g=g.map(v=>{const b=w[v.materialIndex];return v.materialIndex=w.indexOf(b),v}).sort((v,b)=>v.materialIndex-b.materialIndex));const m=[];for(let v=0,b=w.length;v<b;v++){let A=!1;for(let S=0,T=g.length;S<T;S++){const M=g[S];M.materialIndex===v&&(A=!0,M.materialIndex=m.length)}A&&m.push(w[v])}s.forEach(v=>{v.material=m})}else g=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach(w=>{w.material=f[0]});return s.forEach((w,m)=>{const v=w.geometry;wh(v,r[m],g),u&&ph(v.groups)}),i?s:s[0]}evaluateHierarchy(t,e=new At){t.updateMatrixWorld(!0);const n=(i,o)=>{const r=i.children;for(let a=0,c=r.length;a<c;a++){const u=r[a];u.isOperationGroup?n(u,o):o(u)}},s=i=>{const o=i.children;let r=!1;for(let c=0,u=o.length;c<u;c++){const d=o[c];r=s(d)||r}const a=i.isDirty();if(a&&i.markUpdated(),r&&!i.isOperationGroup){let c;return n(i,u=>{c?c=this.evaluate(c,u,u.operation):c=this.evaluate(i,u,u.operation)}),i._cachedGeometry=c.geometry,i._cachedMaterials=c.material,!0}else return r||a};return s(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const St=!1,$={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},ut={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},yh=Ne({title:"Shelf Texture"}),Cn=new Tn(yh),Qn=Cn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_COL_1K_METALNESS.png");Qn.colorSpace=Jn;const ts=Cn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_NRM_1K_METALNESS.png"),es=Cn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_AO_1K_METALNESS.png"),ns=Cn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_ROUGHNESS_1K_METALNESS.png"),ss=Cn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_METALNESS_1K_METALNESS.png"),is=Cn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_DISP_1K_METALNESS.png");Qn.wrapS=Qn.wrapT=ts.wrapS=ts.wrapT=es.wrapS=es.wrapT=ns.wrapS=ns.wrapT=ss.wrapS=ss.wrapT=is.wrapS=is.wrapT=H;const kt=.3;Qn.repeat.set(kt,kt);ts.repeat.set(kt,kt);es.repeat.set(kt,kt);ns.repeat.set(kt,kt);ss.repeat.set(kt,kt);is.repeat.set(kt,kt);const gh=Ne({title:"Window texture"}),_n=new Tn(gh),Oo=_n.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-albedo.png");Oo.colorSpace=Jn;const pi=_n.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Normal-dx.png"),mi=_n.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-ao.png"),wi=_n.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Roughness.png"),yi=_n.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Metallic.png"),Wo=_n.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Height.png");Oo.wrapS=H;Oo.wrapT=H;pi.wrapS=H;pi.wrapT=H;mi.wrapS=H;mi.wrapT=H;wi.wrapS=H;wi.wrapT=H;yi.wrapS=H;yi.wrapT=H;Wo.wrapS=H;Wo.wrapT=H;const{frameThickness:Go,frameWidthOuter:$a,frameHeightOuter:Ha,slatWidth:pn,x:xh,y:vh,frameWidthInner:Da,frameHeightInner:Ua}=ut,jt=new bt({roughness:.1,metalness:.6,wireframe:St,color:16777215}),Xa=new At(new Le($a,Ha,Go),jt);Xa.updateMatrixWorld();const Ya=new At(new Le(Da,Ua,Go),jt);Ya.updateMatrixWorld();const ds=new Ga,bh=ds.evaluate(Xa,Ya,qo),$o=new At(new W(Da+1,pn*2,pn*2,$.roundSegments,$.roundRadius/2),jt);$o.position.set(0,-2.2,0);$o.updateMatrixWorld();const Ho=new At(new W(.6,Ua+1,.6,$.roundSegments,$.roundRadius/2),jt);Ho.position.set(0,0,0);Ho.updateMatrixWorld();let os=ds.evaluate($o,Ho,me);const Do=new At(new W(pn,13.4,pn,$.roundSegments,$.roundRadius/2),jt);Do.position.set(-8.2,4.6,0);Do.updateMatrixWorld();os=ds.evaluate(os,Do,me);const Uo=new At(new W(pn,13.4,pn,$.roundSegments,$.roundRadius/2),jt);Uo.position.set(8.2,4.6,0);Uo.updateMatrixWorld();os=ds.evaluate(os,Uo,me);const Xo=ds.evaluate(bh,os,me);Xo.position.set($a/2+xh,Ha/2+vh,-($.wallThickness-Go/2));Xo.updateMatrixWorld();jt.normalMap=pi;jt.aoMap=mi;jt.roughnessMap=wi;jt.metalnessMap=yi;jt.displacementMap=Wo;jt.displacementScale=.01;const{floorXLength:Ot,floorZLength:Wt,wallHeight:we,wallThickness:Z,roundRadius:Xe,roundSegments:Ye,ny:Ah}=$,fs=new Ga,Sh=Ne({title:"Wall texture"}),Yo=new Tn(Sh),ti=Yo.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_albedo.png"),ei=Yo.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_normal-ogl.png"),ni=Yo.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_ao.png");ti.repeat.set(2,2);ei.repeat.set(2,2);ni.repeat.set(2,2);ti.wrapS=ti.wrapT=H;ei.wrapS=ei.wrapT=H;ni.wrapS=ni.wrapT=H;const Pn=new bt({roughness:1,metalness:0,wireframe:St});Pn.map=ti;Pn.normalMap=ei;Pn.aoMap=ni;const Zo=new bt({roughness:1,metalness:0,wireframe:St,transparent:!0,opacity:0}),Th=new W(Ot+1,Z,Wt+1,Ye,Xe),Eh=Ne({title:"Floor texture"}),gi=new Tn(Eh),Mh=new bt({roughness:1,metalness:0,wireframe:St});let rs=new At(Th,Mh);rs.position.set(Ot/2-1/2,-Z/2,Wt/2-1/2);rs.updateMatrixWorld();const Bh=new W(Ot+1,.4,Wt+1,Ye,Xe),as=gi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DIFFUSE-1K.png"),cs=gi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-NORMALS16_OPENGL-1K.png"),ls=gi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DISPLACEMENT16-1K.png"),us=gi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-ROUGHNESS-1K.png");as.wrapS=as.wrapT=cs.wrapS=cs.wrapT=ls.wrapS=ls.wrapT=us.wrapS=us.wrapT=H;as.rotation=cs.rotation=ls.rotation=us.rotation=Math.PI/2;as.repeat.set(1.3,1.3);cs.repeat.set(1.3,1.3);ls.repeat.set(1.3,1.3);us.repeat.set(1.3,1.3);const Ch=new bt({wireframe:St,map:as,normalMap:cs,displacementMap:ls,displacementScale:.001,roughnessMap:us}),Ko=new At(Bh,Ch);Ko.position.set(Ot/2-1/2,-.199,Wt/2-1/2);Ko.updateMatrixWorld();rs=fs.evaluate(Ko,rs,me);const _h=new W(Z,we,Wt+1,Ye,Xe),Jo=new At(_h,Pn);Jo.position.set(-Z/2,we/2-Z,Wt/2-1/2);Jo.updateMatrixWorld();const Ph=new W(Ot+Z,we,Z,Ye,Xe),Qo=new At(Ph,Pn);Qo.position.set(Ot/2-Z/2,we/2-Z,-Z/2);Qo.updateMatrixWorld();const zh=new Le(ut.frameWidthOuter,ut.frameHeightOuter,Z),tr=new At(zh,Pn);tr.position.set(ut.frameWidthOuter/2+ut.x,ut.frameHeightOuter/2+ut.y,-Z/2);tr.updateMatrixWorld();const Za=fs.evaluate(Qo,tr,qo);Za.updateMatrixWorld();const xi=fs.evaluate(Za,Xo,me);xi.receiveShadow=!0;xi.castShadow=!0;xi.updateMatrixWorld();const Ih=new W(Ot+Z+.1,we,.1,Ye,Xe),vi=new G(Ih,Zo);vi.position.set(Ot/2-Z/2,we/2-Z,Wt-.19);vi.receiveShadow=!0;vi.castShadow=!0;const Lh=new W(.1,we,Wt+Z,Ye,Xe),bi=new G(Lh,Zo);bi.position.set(Ot+.1/2,we/2-Z,Wt/2-Z/2);bi.receiveShadow=!0;bi.castShadow=!0;const Nh=new W(Ot+Z+.1,Z,Wt+Z+.1,Ye,Xe),Ai=new G(Nh,Zo);Ai.position.set(Ot/2-Z/2,we-Z/2,Wt/2-Z/2);Ai.receiveShadow=!0;Ai.castShadow=!0;const Ze=new pe;Ze.position.set(-Ot/2,-Ah,-Wt/2);let mn=fs.evaluate(Jo,xi,me);mn.updateMatrixWorld();mn=fs.evaluate(mn,rs,me);mn.castShadow=!0;mn.receiveShadow=!0;Ze.add(mn);Ze.add(vi);Ze.add(bi);Ze.add(Ai);O.add(Ze);const er=new No(Ze);er.visible=!1;O.add(er);class Dt{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new y);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new y);const n=this.elements,s=t.x,i=t.y,o=t.z;return e.x=n[0]*s+n[1]*i+n[2]*o,e.y=n[3]*s+n[4]*i+n[5]*o,e.z=n[6]*s+n[7]*i+n[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new Dt);const n=this.elements,s=t.elements,i=e.elements,o=n[0],r=n[1],a=n[2],c=n[3],u=n[4],d=n[5],h=n[6],f=n[7],p=n[8],x=s[0],g=s[1],w=s[2],m=s[3],v=s[4],b=s[5],A=s[6],S=s[7],T=s[8];return i[0]=o*x+r*m+a*A,i[1]=o*g+r*v+a*S,i[2]=o*w+r*b+a*T,i[3]=c*x+u*m+d*A,i[4]=c*g+u*v+d*S,i[5]=c*w+u*b+d*T,i[6]=h*x+f*m+p*A,i[7]=h*g+f*v+p*S,i[8]=h*w+f*b+p*T,e}scale(t,e){e===void 0&&(e=new Dt);const n=this.elements,s=e.elements;for(let i=0;i!==3;i++)s[3*i+0]=t.x*n[3*i+0],s[3*i+1]=t.y*n[3*i+1],s[3*i+2]=t.z*n[3*i+2];return e}solve(t,e){e===void 0&&(e=new y);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=t.x,i[3+4*1]=t.y,i[3+4*2]=t.z;let a=3;const c=a;let u;const d=4;let h;do{if(o=c-a,i[o+s*o]===0){for(r=o+1;r<c;r++)if(i[o+s*r]!==0){u=d;do h=d-u,i[h+s*o]+=i[h+s*r];while(--u);break}}if(i[o+s*o]!==0)for(r=o+1;r<c;r++){const f=i[o+s*r]/i[o+s*o];u=d;do h=d-u,i[h+s*r]=h<=o?0:i[h+s*r]-i[h+s*o]*f;while(--u)}}while(--a);if(e.z=i[2*s+3]/i[2*s+2],e.y=(i[1*s+3]-i[1*s+2]*e.z)/i[1*s+1],e.x=(i[0*s+3]-i[0*s+2]*e.z-i[0*s+1]*e.y)/i[0*s+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,n){if(n===void 0)return this.elements[e+3*t];this.elements[e+3*t]=n}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let n=0;n<9;n++)t+=this.elements[n]+e;return t}reverse(t){t===void 0&&(t=new Dt);const e=3,n=6,s=Fh;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const a=r;let c;const u=n;let d;do{if(i=a-r,s[i+n*i]===0){for(o=i+1;o<a;o++)if(s[i+n*o]!==0){c=u;do d=u-c,s[d+n*i]+=s[d+n*o];while(--c);break}}if(s[i+n*i]!==0)for(o=i+1;o<a;o++){const h=s[i+n*o]/s[i+n*i];c=u;do d=u-c,s[d+n*o]=d<=i?0:s[d+n*o]-s[d+n*i]*h;while(--c)}}while(--r);i=2;do{o=i-1;do{const h=s[i+n*o]/s[i+n*i];c=n;do d=n-c,s[d+n*o]=s[d+n*o]-s[d+n*i]*h;while(--c)}while(o--)}while(--i);i=2;do{const h=1/s[i+n*i];c=n;do d=n-c,s[d+n*i]=s[d+n*i]*h;while(--c)}while(i--);i=2;do{o=2;do{if(d=s[e+o+n*i],isNaN(d)||d===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,o,d)}while(o--)}while(i--);return t}setRotationFromQuaternion(t){const e=t.x,n=t.y,s=t.z,i=t.w,o=e+e,r=n+n,a=s+s,c=e*o,u=e*r,d=e*a,h=n*r,f=n*a,p=s*a,x=i*o,g=i*r,w=i*a,m=this.elements;return m[3*0+0]=1-(h+p),m[3*0+1]=u-w,m[3*0+2]=d+g,m[3*1+0]=u+w,m[3*1+1]=1-(c+p),m[3*1+2]=f-x,m[3*2+0]=d-g,m[3*2+1]=f+x,m[3*2+2]=1-(c+h),this}transpose(t){t===void 0&&(t=new Dt);const e=this.elements,n=t.elements;let s;return n[0]=e[0],n[4]=e[4],n[8]=e[8],s=e[1],n[1]=e[3],n[3]=s,s=e[2],n[2]=e[6],n[6]=s,s=e[5],n[5]=e[7],n[7]=s,t}}const Fh=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class y{constructor(t,e,n){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),this.x=t,this.y=e,this.z=n}cross(t,e){e===void 0&&(e=new y);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z;return e.x=r*i-a*s,e.y=a*n-o*i,e.z=o*s-r*n,e}set(t,e,n){return this.x=t,this.y=e,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new y(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new y(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new Dt([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,n=this.z,s=Math.sqrt(t*t+e*e+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(t){t===void 0&&(t=new y);const e=this.x,n=this.y,s=this.z;let i=Math.sqrt(e*e+n*n+s*s);return i>0?(i=1/i,t.x=e*i,t.y=n*i,t.z=s*i):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,n=this.z;return Math.sqrt(t*t+e*e+n*n)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return Math.sqrt((i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return(i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s)}scale(t,e){e===void 0&&(e=new y);const n=this.x,s=this.y,i=this.z;return e.x=t*n,e.y=t*s,e.z=t*i,e}vmul(t,e){return e===void 0&&(e=new y),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,n){return n===void 0&&(n=new y),n.x=this.x+t*e.x,n.y=this.y+t*e.y,n.z=this.z+t*e.z,n}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new y),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const n=this.length();if(n>0){const s=Rh,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=Vh;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,t)):(o.set(0,1,0),s.cross(o,t)),s.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,n){const s=this.x,i=this.y,o=this.z;n.x=s+(t.x-s)*e,n.y=i+(t.y-i)*e,n.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(ia),ia.almostEquals(t,e)}clone(){return new y(this.x,this.y,this.z)}}y.ZERO=new y(0,0,0);y.UNIT_X=new y(1,0,0);y.UNIT_Y=new y(0,1,0);y.UNIT_Z=new y(0,0,1);const Rh=new y,Vh=new y,ia=new y;class Tt{constructor(t){t===void 0&&(t={}),this.lowerBound=new y,this.upperBound=new y,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(t[0]),r&&r.vmult(i,i),o.copy(i);for(let a=1;a<t.length;a++){let c=t[a];r&&(r.vmult(c,oa),c=oa),c.x>o.x&&(o.x=c.x),c.x<i.x&&(i.x=c.x),c.y>o.y&&(o.y=c.y),c.y<i.y&&(i.y=c.y),c.z>o.z&&(o.z=c.z),c.z<i.z&&(i.z=c.z)}return e&&(e.vadd(i,i),e.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new Tt().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound,o=s.x<=n.x&&n.x<=i.x||e.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||e.y<=i.y&&i.y<=n.y,a=s.z<=n.z&&n.z<=i.z||e.z<=i.z&&i.z<=n.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound;return e.x<=s.x&&n.x>=i.x&&e.y<=s.y&&n.y>=i.y&&e.z<=s.z&&n.z>=i.z}getCorners(t,e,n,s,i,o,r,a){const c=this.lowerBound,u=this.upperBound;t.copy(c),e.set(u.x,c.y,c.z),n.set(u.x,u.y,c.z),s.set(c.x,u.y,u.z),i.set(u.x,c.y,u.z),o.set(c.x,u.y,c.z),r.set(c.x,c.y,u.z),a.copy(u)}toLocalFrame(t,e){const n=ra,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],u=n[6],d=n[7];this.getCorners(s,i,o,r,a,c,u,d);for(let h=0;h!==8;h++){const f=n[h];t.pointToLocal(f,f)}return e.setFromPoints(n)}toWorldFrame(t,e){const n=ra,s=n[0],i=n[1],o=n[2],r=n[3],a=n[4],c=n[5],u=n[6],d=n[7];this.getCorners(s,i,o,r,a,c,u,d);for(let h=0;h!==8;h++){const f=n[h];t.pointToWorld(f,f)}return e.setFromPoints(n)}overlapsRay(t){const{direction:e,from:n}=t,s=1/e.x,i=1/e.y,o=1/e.z,r=(this.lowerBound.x-n.x)*s,a=(this.upperBound.x-n.x)*s,c=(this.lowerBound.y-n.y)*i,u=(this.upperBound.y-n.y)*i,d=(this.lowerBound.z-n.z)*o,h=(this.upperBound.z-n.z)*o,f=Math.max(Math.max(Math.min(r,a),Math.min(c,u)),Math.min(d,h)),p=Math.min(Math.min(Math.max(r,a),Math.max(c,u)),Math.max(d,h));return!(p<0||f>p)}}const oa=new y,ra=[new y,new y,new y,new y,new y,new y,new y,new y];class aa{constructor(){this.matrix=[]}get(t,e){let{index:n}=t,{index:s}=e;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(t,e,n){let{index:s}=t,{index:i}=e;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class Ka{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[t]===void 0&&(n[t]=[]),n[t].includes(e)||n[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[t]!==void 0&&n[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const n=this._listeners;if(n[t]===void 0)return this;const s=n[t].indexOf(e);return s!==-1&&n[t].splice(s,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const n=this._listeners[t.type];if(n!==void 0){t.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,t)}return this}}class tt{constructor(t,e,n,s){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=t,this.y=e,this.z=n,this.w=s}set(t,e,n,s){return this.x=t,this.y=e,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const n=Math.sin(e*.5);return this.x=t.x*n,this.y=t.y*n,this.z=t.z*n,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new y),this.normalize();const e=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/n,t.y=this.y/n,t.z=this.z/n),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const n=kh,s=qh;t.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=t.cross(e);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new tt);const n=this.x,s=this.y,i=this.z,o=this.w,r=t.x,a=t.y,c=t.z,u=t.w;return e.x=n*u+o*r+s*c-i*a,e.y=s*u+o*a+i*r-n*c,e.z=i*u+o*c+n*a-s*r,e.w=o*u-n*r-s*a-i*c,e}inverse(t){t===void 0&&(t=new tt);const e=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(t);const o=1/(e*e+n*n+s*s+i*i);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new tt),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new y);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,a=this.z,c=this.w,u=c*n+r*i-a*s,d=c*s+a*n-o*i,h=c*i+o*s-r*n,f=-o*n-r*s-a*i;return e.x=u*c+f*-o+d*-a-h*-r,e.y=d*c+f*-r+h*-o-u*-a,e.z=h*c+f*-a+u*-r-d*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let n,s,i;const o=this.x,r=this.y,a=this.z,c=this.w;switch(e){case"YZX":const u=o*r+a*c;if(u>.499&&(n=2*Math.atan2(o,c),s=Math.PI/2,i=0),u<-.499&&(n=-2*Math.atan2(o,c),s=-Math.PI/2,i=0),n===void 0){const d=o*o,h=r*r,f=a*a;n=Math.atan2(2*r*c-2*o*a,1-2*h-2*f),s=Math.asin(2*u),i=Math.atan2(2*o*c-2*r*a,1-2*d-2*f)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=n,t.z=s,t.x=i}setFromEuler(t,e,n,s){s===void 0&&(s="XYZ");const i=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(n/2),a=Math.sin(t/2),c=Math.sin(e/2),u=Math.sin(n/2);return s==="XYZ"?(this.x=a*o*r+i*c*u,this.y=i*c*r-a*o*u,this.z=i*o*u+a*c*r,this.w=i*o*r-a*c*u):s==="YXZ"?(this.x=a*o*r+i*c*u,this.y=i*c*r-a*o*u,this.z=i*o*u-a*c*r,this.w=i*o*r+a*c*u):s==="ZXY"?(this.x=a*o*r-i*c*u,this.y=i*c*r+a*o*u,this.z=i*o*u+a*c*r,this.w=i*o*r-a*c*u):s==="ZYX"?(this.x=a*o*r-i*c*u,this.y=i*c*r+a*o*u,this.z=i*o*u-a*c*r,this.w=i*o*r+a*c*u):s==="YZX"?(this.x=a*o*r+i*c*u,this.y=i*c*r+a*o*u,this.z=i*o*u-a*c*r,this.w=i*o*r-a*c*u):s==="XZY"&&(this.x=a*o*r-i*c*u,this.y=i*c*r-a*o*u,this.z=i*o*u+a*c*r,this.w=i*o*r+a*c*u),this}clone(){return new tt(this.x,this.y,this.z,this.w)}slerp(t,e,n){n===void 0&&(n=new tt);const s=this.x,i=this.y,o=this.z,r=this.w;let a=t.x,c=t.y,u=t.z,d=t.w,h,f,p,x,g;return f=s*a+i*c+o*u+r*d,f<0&&(f=-f,a=-a,c=-c,u=-u,d=-d),1-f>1e-6?(h=Math.acos(f),p=Math.sin(h),x=Math.sin((1-e)*h)/p,g=Math.sin(e*h)/p):(x=1-e,g=e),n.x=x*s+g*a,n.y=x*i+g*c,n.z=x*o+g*u,n.w=x*r+g*d,n}integrate(t,e,n,s){s===void 0&&(s=new tt);const i=t.x*n.x,o=t.y*n.y,r=t.z*n.z,a=this.x,c=this.y,u=this.z,d=this.w,h=e*.5;return s.x+=h*(i*d+o*u-r*c),s.y+=h*(o*d+r*a-i*u),s.z+=h*(r*d+i*c-o*a),s.w+=h*(-i*a-o*c-r*u),s}}const kh=new y,qh=new y,jh={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class R{constructor(t){t===void 0&&(t={}),this.id=R.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}R.idCounter=0;R.types=jh;class D{constructor(t){t===void 0&&(t={}),this.position=new y,this.quaternion=new tt,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return D.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return D.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new y),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,n,s){return s===void 0&&(s=new y),n.vsub(t,s),e.conjugate(ca),ca.vmult(s,s),s}static pointToWorldFrame(t,e,n,s){return s===void 0&&(s=new y),e.vmult(n,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,n){return n===void 0&&(n=new y),t.vmult(e,n),n}static vectorToLocalFrame(t,e,n,s){return s===void 0&&(s=new y),e.w*=-1,e.vmult(n,s),e.w*=-1,s}}const ca=new tt;class Kn extends R{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=t;super({type:R.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,n=this.uniqueEdges;n.length=0;const s=new y;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let a=0;a!==r;a++){const c=(a+1)%r;e[o[a]].vsub(e[o[c]],s),s.normalize();let u=!1;for(let d=0;d!==n.length;d++)if(n[d].almostEquals(s)||n[d].almostEquals(s)){u=!0;break}u||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const e=this.faceNormals[t]||new y;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const n=this.vertices[this.faces[t][0]];if(e.dot(n)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,e){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];Kn.computeNormal(s,i,o,e)}static computeNormal(t,e,n,s){const i=new y,o=new y;e.vsub(t,o),n.vsub(e,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,n,s,i,o,r,a,c){const u=new y;let d=-1,h=-Number.MAX_VALUE;for(let p=0;p<n.faces.length;p++){u.copy(n.faceNormals[p]),i.vmult(u,u);const x=u.dot(o);x>h&&(h=x,d=p)}const f=[];for(let p=0;p<n.faces[d].length;p++){const x=n.vertices[n.faces[d][p]],g=new y;g.copy(x),i.vmult(g,g),s.vadd(g,g),f.push(g)}d>=0&&this.clipFaceAgainstHull(o,t,e,f,r,a,c)}findSeparatingAxis(t,e,n,s,i,o,r,a){const c=new y,u=new y,d=new y,h=new y,f=new y,p=new y;let x=Number.MAX_VALUE;const g=this;if(g.uniqueAxes)for(let w=0;w!==g.uniqueAxes.length;w++){n.vmult(g.uniqueAxes[w],c);const m=g.testSepAxis(c,t,e,n,s,i);if(m===!1)return!1;m<x&&(x=m,o.copy(c))}else{const w=r?r.length:g.faces.length;for(let m=0;m<w;m++){const v=r?r[m]:m;c.copy(g.faceNormals[v]),n.vmult(c,c);const b=g.testSepAxis(c,t,e,n,s,i);if(b===!1)return!1;b<x&&(x=b,o.copy(c))}}if(t.uniqueAxes)for(let w=0;w!==t.uniqueAxes.length;w++){i.vmult(t.uniqueAxes[w],u);const m=g.testSepAxis(u,t,e,n,s,i);if(m===!1)return!1;m<x&&(x=m,o.copy(u))}else{const w=a?a.length:t.faces.length;for(let m=0;m<w;m++){const v=a?a[m]:m;u.copy(t.faceNormals[v]),i.vmult(u,u);const b=g.testSepAxis(u,t,e,n,s,i);if(b===!1)return!1;b<x&&(x=b,o.copy(u))}}for(let w=0;w!==g.uniqueEdges.length;w++){n.vmult(g.uniqueEdges[w],h);for(let m=0;m!==t.uniqueEdges.length;m++)if(i.vmult(t.uniqueEdges[m],f),h.cross(f,p),!p.almostZero()){p.normalize();const v=g.testSepAxis(p,t,e,n,s,i);if(v===!1)return!1;v<x&&(x=v,o.copy(p))}}return s.vsub(e,d),d.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,n,s,i,o){const r=this;Kn.project(r,t,n,s,fo),Kn.project(e,t,i,o,po);const a=fo[0],c=fo[1],u=po[0],d=po[1];if(a<d||u<c)return!1;const h=a-d,f=u-c;return h<f?h:f}calculateLocalInertia(t,e){const n=new y,s=new y;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*i*2*i+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],n=this.faceNormals[t],s=this.vertices[e[0]];return-n.dot(s)}clipFaceAgainstHull(t,e,n,s,i,o,r){const a=new y,c=new y,u=new y,d=new y,h=new y,f=new y,p=new y,x=new y,g=this,w=[],m=s,v=w;let b=-1,A=Number.MAX_VALUE;for(let C=0;C<g.faces.length;C++){a.copy(g.faceNormals[C]),n.vmult(a,a);const z=a.dot(t);z<A&&(A=z,b=C)}if(b<0)return;const S=g.faces[b];S.connectedFaces=[];for(let C=0;C<g.faces.length;C++)for(let z=0;z<g.faces[C].length;z++)S.indexOf(g.faces[C][z])!==-1&&C!==b&&S.connectedFaces.indexOf(C)===-1&&S.connectedFaces.push(C);const T=S.length;for(let C=0;C<T;C++){const z=g.vertices[S[C]],_=g.vertices[S[(C+1)%T]];z.vsub(_,c),u.copy(c),n.vmult(u,u),e.vadd(u,u),d.copy(this.faceNormals[b]),n.vmult(d,d),e.vadd(d,d),u.cross(d,h),h.negate(h),f.copy(z),n.vmult(f,f),e.vadd(f,f);const E=S.connectedFaces[C];p.copy(this.faceNormals[E]);const P=this.getPlaneConstantOfFace(E);x.copy(p),n.vmult(x,x);const I=P-x.dot(e);for(this.clipFaceAgainstPlane(m,v,x,I);m.length;)m.shift();for(;v.length;)m.push(v.shift())}p.copy(this.faceNormals[b]);const M=this.getPlaneConstantOfFace(b);x.copy(p),n.vmult(x,x);const B=M-x.dot(e);for(let C=0;C<m.length;C++){let z=x.dot(m[C])+B;if(z<=i&&(console.log(`clamped: depth=${z} to minDist=${i}`),z=i),z<=o){const _=m[C];if(z<=1e-6){const E={point:_,normal:x,depth:z};r.push(E)}}}}clipFaceAgainstPlane(t,e,n,s){let i,o;const r=t.length;if(r<2)return e;let a=t[t.length-1],c=t[0];i=n.dot(a)+s;for(let u=0;u<r;u++){if(c=t[u],o=n.dot(c)+s,i<0)if(o<0){const d=new y;d.copy(c),e.push(d)}else{const d=new y;a.lerp(c,i/(i-o),d),e.push(d)}else if(o<0){const d=new y;a.lerp(c,i/(i-o),d),e.push(d),e.push(c)}a=c,i=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new y);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(n[i],s[i]),t.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const n=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<t.x?t.x=i.x:i.x>e.x&&(e.x=i.x),i.y<t.y?t.y=i.y:i.y>e.y&&(e.y=i.y),i.z<t.z?t.z=i.z:i.z>e.z&&(e.z=i.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new y);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let n=0;n!==e.length;n++){const s=e[n].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,n,s){const i=this.vertices;let o,r,a,c,u,d,h=new y;for(let f=0;f<i.length;f++){h.copy(i[f]),e.vmult(h,h),t.vadd(h,h);const p=h;(o===void 0||p.x<o)&&(o=p.x),(c===void 0||p.x>c)&&(c=p.x),(r===void 0||p.y<r)&&(r=p.y),(u===void 0||p.y>u)&&(u=p.y),(a===void 0||p.z<a)&&(a=p.z),(d===void 0||p.z>d)&&(d=p.z)}n.set(o,r,a),s.set(c,u,d)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new y);const e=this.vertices;for(let n=0;n<e.length;n++)t.vadd(e[n],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const n=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<n;i++){const o=s[i];e.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];e.vmult(o,o)}}if(t)for(let i=0;i<n;i++){const o=s[i];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,n=this.faces,s=this.faceNormals,i=null,o=new y;this.getAveragePointLocal(o);for(let r=0;r<this.faces.length;r++){let a=s[r];const c=e[n[r][0]],u=new y;t.vsub(c,u);const d=a.dot(u),h=new y;o.vsub(c,h);const f=a.dot(h);if(d<0&&f>0||d>0&&f<0)return!1}return i?1:-1}static project(t,e,n,s,i){const o=t.vertices.length,r=Oh;let a=0,c=0;const u=Wh,d=t.vertices;u.setZero(),D.vectorToLocalFrame(n,s,e,r),D.pointToLocalFrame(n,s,u,u);const h=u.dot(r);c=a=d[0].dot(r);for(let f=1;f<o;f++){const p=d[f].dot(r);p>a&&(a=p),p<c&&(c=p)}if(c-=h,a-=h,c>a){const f=c;c=a,a=f}i[0]=a,i[1]=c}}const fo=[],po=[];new y;const Oh=new y,Wh=new y;class nr extends R{constructor(t){super({type:R.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,n=this.halfExtents.z,s=y,i=[new s(-t,-e,-n),new s(t,-e,-n),new s(t,e,-n),new s(-t,e,-n),new s(-t,-e,n),new s(t,-e,n),new s(t,e,n),new s(-t,e,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],a=new Kn({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new y),nr.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,n){const s=t;n.x=1/12*e*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*e*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*e*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(t,e){const n=t,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),e!==void 0)for(let i=0;i!==n.length;i++)e.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)Me.set(i[o][0],i[o][1],i[o][2]),e.vmult(Me,Me),t.vadd(Me,Me),n(Me.x,Me.y,Me.z)}calculateWorldAABB(t,e,n,s){const i=this.halfExtents;Kt[0].set(i.x,i.y,i.z),Kt[1].set(-i.x,i.y,i.z),Kt[2].set(-i.x,-i.y,i.z),Kt[3].set(-i.x,-i.y,-i.z),Kt[4].set(i.x,-i.y,-i.z),Kt[5].set(i.x,i.y,-i.z),Kt[6].set(-i.x,i.y,-i.z),Kt[7].set(i.x,-i.y,i.z);const o=Kt[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const a=Kt[r];e.vmult(a,a),t.vadd(a,a);const c=a.x,u=a.y,d=a.z;c>s.x&&(s.x=c),u>s.y&&(s.y=u),d>s.z&&(s.z=d),c<n.x&&(n.x=c),u<n.y&&(n.y=u),d<n.z&&(n.z=d)}}}const Me=new y,Kt=[new y,new y,new y,new y,new y,new y,new y,new y],sr={DYNAMIC:1,STATIC:2,KINEMATIC:4},ir={AWAKE:0,SLEEPY:1,SLEEPING:2};class F extends Ka{constructor(t){t===void 0&&(t={}),super(),this.id=F.idCounter++,this.index=-1,this.world=null,this.vlambda=new y,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new y,this.previousPosition=new y,this.interpolatedPosition=new y,this.initPosition=new y,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new y,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new y,this.force=new y;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?F.STATIC:F.DYNAMIC,typeof t.type==typeof F.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=F.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new y,this.quaternion=new tt,this.initQuaternion=new tt,this.previousQuaternion=new tt,this.interpolatedQuaternion=new tt,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new y,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new y,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new y,this.invInertia=new y,this.invInertiaWorld=new Dt,this.invMassSolve=0,this.invInertiaSolve=new y,this.invInertiaWorldSolve=new Dt,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new y(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new y(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new Tt,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new y,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=F.AWAKE,this.wakeUpAfterNarrowphase=!1,t===F.SLEEPING&&this.dispatchEvent(F.wakeupEvent)}sleep(){this.sleepState=F.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===F.AWAKE&&n<s?(this.sleepState=F.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(F.sleepyEvent)):e===F.SLEEPY&&n>s?this.wakeUp():e===F.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(F.sleepEvent))}}updateSolveMassProperties(){this.sleepState===F.SLEEPING||this.type===F.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new y),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new y),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new y),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new y),this.quaternion.vmult(t,e),e}addShape(t,e,n){const s=new y,i=new tt;return e&&s.copy(e),n&&i.copy(n),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,n=t.length;let s=0;for(let i=0;i!==n;i++){const o=t[i];o.updateBoundingSphereRadius();const r=e[i].length(),a=o.boundingSphereRadius;r+a>s&&(s=r+a)}this.boundingRadius=s}updateAABB(){const t=this.shapes,e=this.shapeOffsets,n=this.shapeOrientations,s=t.length,i=Gh,o=$h,r=this.quaternion,a=this.aabb,c=Hh;for(let u=0;u!==s;u++){const d=t[u];r.vmult(e[u],i),i.vadd(this.position,i),r.mult(n[u],o),d.calculateWorldAABB(i,o,c.lowerBound,c.upperBound),u===0?a.copy(c):a.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const n=Dh,s=Uh;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(e,n),n.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new y),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=Xh;e.cross(t,n),this.force.vadd(t,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new y),this.type!==F.DYNAMIC)return;const n=Yh,s=Zh;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyForce(n,s)}applyTorque(t){this.type===F.DYNAMIC&&(this.sleepState===F.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new y),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=e,s=Kh;s.copy(t),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=Jh;n.cross(t,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new y),this.type!==F.DYNAMIC)return;const n=Qh,s=td;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyImpulse(n,s)}updateMassProperties(){const t=ed;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,n=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),nr.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!n?1/e.x:0,e.y>0&&!n?1/e.y:0,e.z>0&&!n?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const n=new y;return t.vsub(this.position,n),this.angularVelocity.cross(n,e),this.velocity.vadd(e,e),e}integrate(t,e,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===F.DYNAMIC||this.type===F.KINEMATIC)||this.sleepState===F.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,a=this.torque,c=this.quaternion,u=this.invMass,d=this.invInertiaWorld,h=this.linearFactor,f=u*t;s.x+=r.x*f*h.x,s.y+=r.y*f*h.y,s.z+=r.z*f*h.z;const p=d.elements,x=this.angularFactor,g=a.x*x.x,w=a.y*x.y,m=a.z*x.z;i.x+=t*(p[0]*g+p[1]*w+p[2]*m),i.y+=t*(p[3]*g+p[4]*w+p[5]*m),i.z+=t*(p[6]*g+p[7]*w+p[8]*m),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,c.integrate(this.angularVelocity,t,this.angularFactor,c),e&&(n?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}F.idCounter=0;F.COLLIDE_EVENT_NAME="collide";F.DYNAMIC=sr.DYNAMIC;F.STATIC=sr.STATIC;F.KINEMATIC=sr.KINEMATIC;F.AWAKE=ir.AWAKE;F.SLEEPY=ir.SLEEPY;F.SLEEPING=ir.SLEEPING;F.wakeupEvent={type:"wakeup"};F.sleepyEvent={type:"sleepy"};F.sleepEvent={type:"sleep"};const Gh=new y,$h=new tt,Hh=new Tt,Dh=new Dt,Uh=new Dt;new Dt;const Xh=new y,Yh=new y,Zh=new y,Kh=new y,Jh=new y,Qh=new y,td=new y,ed=new y;class nd{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!(!(t.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&t.collisionFilterMask)||(t.type&F.STATIC||t.sleepState===F.SLEEPING)&&(e.type&F.STATIC||e.sleepState===F.SLEEPING))}intersectionTest(t,e,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,n,s):this.doBoundingSphereBroadphase(t,e,n,s)}doBoundingSphereBroadphase(t,e,n,s){const i=sd;e.position.vsub(t.position,i);const o=(t.boundingRadius+e.boundingRadius)**2;i.lengthSquared()<o&&(n.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,n,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(n.push(t),s.push(e))}makePairsUnique(t,e){const n=id,s=od,i=rd,o=t.length;for(let r=0;r!==o;r++)s[r]=t[r],i[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const a=s[r].id,c=i[r].id,u=a<c?`${a},${c}`:`${c},${a}`;n[u]=r,n.keys.push(u)}for(let r=0;r!==n.keys.length;r++){const a=n.keys.pop(),c=n[a];t.push(s[c]),e.push(i[c]),delete n[a]}}setWorld(t){}static boundingSphereCheck(t,e){const n=new y;t.position.vsub(e.position,n);const s=t.shapes[0],i=e.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(t,e,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const sd=new y;new y;new tt;new y;const id={keys:[]},od=[],rd=[];new y;new y;new y;class ad extends nd{constructor(){super()}collisionPairs(t,e,n){const s=t.bodies,i=s.length;let o,r;for(let a=0;a!==i;a++)for(let c=0;c!==a;c++)o=s[a],r=s[c],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,n)}aabbQuery(t,e,n){n===void 0&&(n=[]);for(let s=0;s<t.bodies.length;s++){const i=t.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(e)&&n.push(i)}return n}}class si{constructor(){this.rayFromWorld=new y,this.rayToWorld=new y,this.hitNormalWorld=new y,this.hitPointWorld=new y,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,n,s,i,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let Ja,Qa,tc,ec,nc,sc,ic;const or={CLOSEST:1,ANY:2,ALL:4};Ja=R.types.SPHERE;Qa=R.types.PLANE;tc=R.types.BOX;ec=R.types.CYLINDER;nc=R.types.CONVEXPOLYHEDRON;sc=R.types.HEIGHTFIELD;ic=R.types.TRIMESH;class Q{get[Ja](){return this._intersectSphere}get[Qa](){return this._intersectPlane}get[tc](){return this._intersectBox}get[ec](){return this._intersectConvex}get[nc](){return this._intersectConvex}get[sc](){return this._intersectHeightfield}get[ic](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new y),e===void 0&&(e=new y),this.from=t.clone(),this.to=e.clone(),this.direction=new y,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Q.ANY,this.result=new si,this.hasHit=!1,this.callback=n=>{}}intersectWorld(t,e){return this.mode=e.mode||Q.ANY,this.result=e.result||new si,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(la),mo.length=0,t.broadphase.aabbQuery(t,la,mo),this.intersectBodies(mo),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!t.collisionResponse||!(this.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&this.collisionFilterMask))return;const s=cd,i=ld;for(let o=0,r=t.shapes.length;o<r;o++){const a=t.shapes[o];if(!(n&&!a.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],i),t.quaternion.vmult(t.shapeOffsets[o],s),s.vadd(t.position,s),this.intersectShape(a,i,s,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let n=0,s=t.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(t[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,n,s){const i=this.from;if(Sd(i,this.direction,n)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,n,s,t)}_intersectBox(t,e,n,s,i){return this._intersectConvex(t.convexPolyhedronRepresentation,e,n,s,i)}_intersectPlane(t,e,n,s,i){const o=this.from,r=this.to,a=this.direction,c=new y(0,0,1);e.vmult(c,c);const u=new y;o.vsub(n,u);const d=u.dot(c);r.vsub(n,u);const h=u.dot(c);if(d*h>0||o.distanceTo(r)<d)return;const f=c.dot(a);if(Math.abs(f)<this.precision)return;const p=new y,x=new y,g=new y;o.vsub(n,p);const w=-c.dot(p)/f;a.scale(w,x),o.vadd(x,g),this.reportIntersection(c,g,i,s,-1)}getAABB(t){const{lowerBound:e,upperBound:n}=t,s=this.to,i=this.from;e.x=Math.min(s.x,i.x),e.y=Math.min(s.y,i.y),e.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(t,e,n,s,i){t.data,t.elementSize;const o=ud;o.from.copy(this.from),o.to.copy(this.to),D.pointToLocalFrame(n,e,o.from,o.from),D.pointToLocalFrame(n,e,o.to,o.to),o.updateDirection();const r=hd;let a,c,u,d;a=c=0,u=d=t.data.length-1;const h=new Tt;o.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,r,!0),a=Math.max(a,r[0]),c=Math.max(c,r[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,r,!0),u=Math.min(u,r[0]+1),d=Math.min(d,r[1]+1);for(let f=a;f<u;f++)for(let p=c;p<d;p++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(f,p,h),!!h.overlapsRay(o)){if(t.getConvexTrianglePillar(f,p,!1),D.pointToWorldFrame(n,e,t.pillarOffset,js),this._intersectConvex(t.pillarConvex,e,js,s,i,ua),this.result.shouldStop)return;t.getConvexTrianglePillar(f,p,!0),D.pointToWorldFrame(n,e,t.pillarOffset,js),this._intersectConvex(t.pillarConvex,e,js,s,i,ua)}}}_intersectSphere(t,e,n,s,i){const o=this.from,r=this.to,a=t.radius,c=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,u=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),d=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-a**2,h=u**2-4*c*d,f=dd,p=fd;if(!(h<0))if(h===0)o.lerp(r,h,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1);else{const x=(-u-Math.sqrt(h))/(2*c),g=(-u+Math.sqrt(h))/(2*c);if(x>=0&&x<=1&&(o.lerp(r,x,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1)),this.result.shouldStop)return;g>=0&&g<=1&&(o.lerp(r,g,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1))}}_intersectConvex(t,e,n,s,i,o){const r=pd,a=ha,c=o&&o.faceList||null,u=t.faces,d=t.vertices,h=t.faceNormals,f=this.direction,p=this.from,x=this.to,g=p.distanceTo(x),w=c?c.length:u.length,m=this.result;for(let v=0;!m.shouldStop&&v<w;v++){const b=c?c[v]:v,A=u[b],S=h[b],T=e,M=n;a.copy(d[A[0]]),T.vmult(a,a),a.vadd(M,a),a.vsub(p,a),T.vmult(S,r);const B=f.dot(r);if(Math.abs(B)<this.precision)continue;const C=r.dot(a)/B;if(!(C<0)){f.scale(C,mt),mt.vadd(p,mt),Gt.copy(d[A[0]]),T.vmult(Gt,Gt),M.vadd(Gt,Gt);for(let z=1;!m.shouldStop&&z<A.length-1;z++){Jt.copy(d[A[z]]),Qt.copy(d[A[z+1]]),T.vmult(Jt,Jt),T.vmult(Qt,Qt),M.vadd(Jt,Jt),M.vadd(Qt,Qt);const _=mt.distanceTo(p);!(Q.pointInTriangle(mt,Gt,Jt,Qt)||Q.pointInTriangle(mt,Jt,Gt,Qt))||_>g||this.reportIntersection(r,mt,i,s,b)}}}}_intersectTrimesh(t,e,n,s,i,o){const r=md,a=bd,c=Ad,u=ha,d=wd,h=yd,f=gd,p=vd,x=xd,g=t.indices;t.vertices;const w=this.from,m=this.to,v=this.direction;c.position.copy(n),c.quaternion.copy(e),D.vectorToLocalFrame(n,e,v,d),D.pointToLocalFrame(n,e,w,h),D.pointToLocalFrame(n,e,m,f),f.x*=t.scale.x,f.y*=t.scale.y,f.z*=t.scale.z,h.x*=t.scale.x,h.y*=t.scale.y,h.z*=t.scale.z,f.vsub(h,d),d.normalize();const b=h.distanceSquared(f);t.tree.rayQuery(this,c,a);for(let A=0,S=a.length;!this.result.shouldStop&&A!==S;A++){const T=a[A];t.getNormal(T,r),t.getVertex(g[T*3],Gt),Gt.vsub(h,u);const M=d.dot(r),B=r.dot(u)/M;if(B<0)continue;d.scale(B,mt),mt.vadd(h,mt),t.getVertex(g[T*3+1],Jt),t.getVertex(g[T*3+2],Qt);const C=mt.distanceSquared(h);!(Q.pointInTriangle(mt,Jt,Gt,Qt)||Q.pointInTriangle(mt,Gt,Jt,Qt))||C>b||(D.vectorToWorldFrame(e,r,x),D.pointToWorldFrame(n,e,mt,p),this.reportIntersection(x,p,i,s,T))}a.length=0}reportIntersection(t,e,n,s,i){const o=this.from,r=this.to,a=o.distanceTo(e),c=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(c.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case Q.ALL:this.hasHit=!0,c.set(o,r,t,e,n,s,a),c.hasHit=!0,this.callback(c);break;case Q.CLOSEST:(a<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a));break;case Q.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,r,t,e,n,s,a),c.shouldStop=!0;break}}static pointInTriangle(t,e,n,s){s.vsub(e,We),n.vsub(e,On),t.vsub(e,wo);const i=We.dot(We),o=We.dot(On),r=We.dot(wo),a=On.dot(On),c=On.dot(wo);let u,d;return(u=a*r-o*c)>=0&&(d=i*c-o*r)>=0&&u+d<i*a-o*o}}Q.CLOSEST=or.CLOSEST;Q.ANY=or.ANY;Q.ALL=or.ALL;const la=new Tt,mo=[],On=new y,wo=new y,cd=new y,ld=new tt,mt=new y,Gt=new y,Jt=new y,Qt=new y;new y;new si;const ua={faceList:[0]},js=new y,ud=new Q,hd=[],dd=new y,fd=new y,pd=new y;new y;new y;const ha=new y,md=new y,wd=new y,yd=new y,gd=new y,xd=new y,vd=new y;new Tt;const bd=[],Ad=new D,We=new y,Os=new y;function Sd(l,t,e){e.vsub(l,We);const n=We.dot(t);return t.scale(n,Os),Os.vadd(l,Os),e.distanceTo(Os)}class Td{static defaults(t,e){t===void 0&&(t={});for(let n in e)n in t||(t[n]=e[n]);return t}}class da{constructor(){this.spatial=new y,this.rotational=new y}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class ps{constructor(t,e,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=ps.idCounter++,this.minForce=n,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new da,this.jacobianElementB=new da,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,n){const s=e,i=t,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(t,e,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*t-s*e-o*n}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return t.spatial.dot(i)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,a=s.angularVelocity;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,a=s.wlambda;return t.multiplyVectors(i,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,a=s.torque,c=n.invMassSolve,u=s.invMassSolve;return i.scale(c,fa),r.scale(u,pa),n.invInertiaWorldSolve.vmult(o,ma),s.invInertiaWorldSolve.vmult(a,wa),t.multiplyVectors(fa,ma)+e.multiplyVectors(pa,wa)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,a=s.invInertiaWorldSolve;let c=i+o;return r.vmult(t.rotational,Ws),c+=Ws.dot(t.rotational),a.vmult(e.rotational,Ws),c+=Ws.dot(e.rotational),c}addToWlambda(t){const e=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=Ed;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*t,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,o),s.wlambda.addScaledVector(t,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}ps.idCounter=0;const fa=new y,pa=new y,ma=new y,wa=new y,Ws=new y,Ed=new y;class Md extends ps{constructor(t,e,n){n===void 0&&(n=1e6),super(t,e,0,n),this.restitution=0,this.ri=new y,this.rj=new y,this.ni=new y}computeB(t){const e=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,a=Bd,c=Cd,u=s.velocity,d=s.angularVelocity;s.force,s.torque;const h=i.velocity,f=i.angularVelocity;i.force,i.torque;const p=_d,x=this.jacobianElementA,g=this.jacobianElementB,w=this.ni;o.cross(w,a),r.cross(w,c),w.negate(x.spatial),a.negate(x.rotational),g.spatial.copy(w),g.rotational.copy(c),p.copy(i.position),p.vadd(r,p),p.vsub(s.position,p),p.vsub(o,p);const m=w.dot(p),v=this.restitution+1,b=v*h.dot(w)-v*u.dot(w)+f.dot(c)-d.dot(a),A=this.computeGiMf();return-m*e-b*n-t*A}getImpactVelocityAlongNormal(){const t=Pd,e=zd,n=Id,s=Ld,i=Nd;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,t),this.bj.getVelocityAtWorldPoint(s,e),t.vsub(e,i),this.ni.dot(i)}}const Bd=new y,Cd=new y,_d=new y,Pd=new y,zd=new y,Id=new y,Ld=new y,Nd=new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;class ya extends ps{constructor(t,e,n){super(t,e,-n,n),this.ri=new y,this.rj=new y,this.t=new y}computeB(t){this.a;const e=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=Fd,o=Rd,r=this.t;n.cross(r,i),s.cross(r,o);const a=this.jacobianElementA,c=this.jacobianElementB;r.negate(a.spatial),i.negate(a.rotational),c.spatial.copy(r),c.rotational.copy(o);const u=this.computeGW(),d=this.computeGiMf();return-u*e-t*d}}const Fd=new y,Rd=new y;class Si{constructor(t,e,n){n=Td.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Si.idCounter++,this.materials=[t,e],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}Si.idCounter=0;class Ti{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=Ti.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}Ti.idCounter=0;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new Q;new y;new y;new y;new y(1,0,0),new y(0,1,0),new y(0,0,1);new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new y;new Tt;new y;new Tt;new y;new y;new y;new y;new y;new y;new y;new Tt;new y;new D;new Tt;class Vd{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,n=e.indexOf(t);n!==-1&&e.splice(n,1)}removeAllEquations(){this.equations.length=0}}class kd extends Vd{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=e.bodies,c=a.length,u=t;let d,h,f,p,x,g;if(r!==0)for(let b=0;b!==c;b++)a[b].updateSolveMassProperties();const w=jd,m=Od,v=qd;w.length=r,m.length=r,v.length=r;for(let b=0;b!==r;b++){const A=o[b];v[b]=0,m[b]=A.computeB(u),w[b]=1/A.computeC()}if(r!==0){for(let S=0;S!==c;S++){const T=a[S],M=T.vlambda,B=T.wlambda;M.set(0,0,0),B.set(0,0,0)}for(n=0;n!==s;n++){p=0;for(let S=0;S!==r;S++){const T=o[S];d=m[S],h=w[S],g=v[S],x=T.computeGWlambda(),f=h*(d-x-T.eps*g),g+f<T.minForce?f=T.minForce-g:g+f>T.maxForce&&(f=T.maxForce-g),v[S]+=f,p+=f>0?f:-f,T.addToWlambda(f)}if(p*p<i)break}for(let S=0;S!==c;S++){const T=a[S],M=T.velocity,B=T.angularVelocity;T.vlambda.vmul(T.linearFactor,T.vlambda),M.vadd(T.vlambda,M),T.wlambda.vmul(T.angularFactor,T.wlambda),B.vadd(T.wlambda,B)}let b=o.length;const A=1/u;for(;b--;)o[b].multiplier=v[b]*A}return n}}const qd=[],jd=[],Od=[];F.STATIC;class Wd{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class Gd extends Wd{constructor(){super(...arguments),this.type=y}constructObject(){return new y}}const X={sphereSphere:R.types.SPHERE,spherePlane:R.types.SPHERE|R.types.PLANE,boxBox:R.types.BOX|R.types.BOX,sphereBox:R.types.SPHERE|R.types.BOX,planeBox:R.types.PLANE|R.types.BOX,convexConvex:R.types.CONVEXPOLYHEDRON,sphereConvex:R.types.SPHERE|R.types.CONVEXPOLYHEDRON,planeConvex:R.types.PLANE|R.types.CONVEXPOLYHEDRON,boxConvex:R.types.BOX|R.types.CONVEXPOLYHEDRON,sphereHeightfield:R.types.SPHERE|R.types.HEIGHTFIELD,boxHeightfield:R.types.BOX|R.types.HEIGHTFIELD,convexHeightfield:R.types.CONVEXPOLYHEDRON|R.types.HEIGHTFIELD,sphereParticle:R.types.PARTICLE|R.types.SPHERE,planeParticle:R.types.PLANE|R.types.PARTICLE,boxParticle:R.types.BOX|R.types.PARTICLE,convexParticle:R.types.PARTICLE|R.types.CONVEXPOLYHEDRON,cylinderCylinder:R.types.CYLINDER,sphereCylinder:R.types.SPHERE|R.types.CYLINDER,planeCylinder:R.types.PLANE|R.types.CYLINDER,boxCylinder:R.types.BOX|R.types.CYLINDER,convexCylinder:R.types.CONVEXPOLYHEDRON|R.types.CYLINDER,heightfieldCylinder:R.types.HEIGHTFIELD|R.types.CYLINDER,particleCylinder:R.types.PARTICLE|R.types.CYLINDER,sphereTrimesh:R.types.SPHERE|R.types.TRIMESH,planeTrimesh:R.types.PLANE|R.types.TRIMESH};class $d{get[X.sphereSphere](){return this.sphereSphere}get[X.spherePlane](){return this.spherePlane}get[X.boxBox](){return this.boxBox}get[X.sphereBox](){return this.sphereBox}get[X.planeBox](){return this.planeBox}get[X.convexConvex](){return this.convexConvex}get[X.sphereConvex](){return this.sphereConvex}get[X.planeConvex](){return this.planeConvex}get[X.boxConvex](){return this.boxConvex}get[X.sphereHeightfield](){return this.sphereHeightfield}get[X.boxHeightfield](){return this.boxHeightfield}get[X.convexHeightfield](){return this.convexHeightfield}get[X.sphereParticle](){return this.sphereParticle}get[X.planeParticle](){return this.planeParticle}get[X.boxParticle](){return this.boxParticle}get[X.convexParticle](){return this.convexParticle}get[X.cylinderCylinder](){return this.convexConvex}get[X.sphereCylinder](){return this.sphereConvex}get[X.planeCylinder](){return this.planeConvex}get[X.boxCylinder](){return this.boxConvex}get[X.convexCylinder](){return this.convexConvex}get[X.heightfieldCylinder](){return this.heightfieldCylinder}get[X.particleCylinder](){return this.particleCylinder}get[X.sphereTrimesh](){return this.sphereTrimesh}get[X.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Gd,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new Md(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&n.collisionResponse&&s.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const c=n.material||t.material,u=s.material||e.material;return c&&u&&c.restitution>=0&&u.restitution>=0&&(r.restitution=c.restitution*u.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){const n=t.bi,s=t.bj,i=t.si,o=t.sj,r=this.world,a=this.currentContactMaterial;let c=a.friction;const u=i.material||n.material,d=o.material||s.material;if(u&&d&&u.friction>=0&&d.friction>=0&&(c=u.friction*d.friction),c>0){const h=c*(r.frictionGravity||r.gravity).length();let f=n.invMass+s.invMass;f>0&&(f=1/f);const p=this.frictionEquationPool,x=p.length?p.pop():new ya(n,s,h*f),g=p.length?p.pop():new ya(n,s,h*f);return x.bi=g.bi=n,x.bj=g.bj=s,x.minForce=g.minForce=-h*f,x.maxForce=g.maxForce=h*f,x.ri.copy(t.ri),x.rj.copy(t.rj),g.ri.copy(t.ri),g.rj.copy(t.rj),t.ni.tangents(x.t,g.t),x.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),g.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),x.enabled=g.enabled=t.enabled,e.push(x,g),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];qe.setZero(),hn.setZero(),dn.setZero();const i=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==i?(qe.vadd(e.ni,qe),hn.vadd(e.ri,hn),dn.vadd(e.rj,dn)):(qe.vsub(e.ni,qe),hn.vadd(e.rj,hn),dn.vadd(e.ri,dn));const o=1/t;hn.scale(o,n.ri),dn.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),qe.normalize(),qe.tangents(n.t,s.t)}getContacts(t,e,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const a=Ud,c=Xd,u=Hd,d=Dd;for(let h=0,f=t.length;h!==f;h++){const p=t[h],x=e[h];let g=null;p.material&&x.material&&(g=n.getContactMaterial(p.material,x.material)||null);const w=p.type&F.KINEMATIC&&x.type&F.STATIC||p.type&F.STATIC&&x.type&F.KINEMATIC||p.type&F.KINEMATIC&&x.type&F.KINEMATIC;for(let m=0;m<p.shapes.length;m++){p.quaternion.mult(p.shapeOrientations[m],a),p.quaternion.vmult(p.shapeOffsets[m],u),u.vadd(p.position,u);const v=p.shapes[m];for(let b=0;b<x.shapes.length;b++){x.quaternion.mult(x.shapeOrientations[b],c),x.quaternion.vmult(x.shapeOffsets[b],d),d.vadd(x.position,d);const A=x.shapes[b];if(!(v.collisionFilterMask&A.collisionFilterGroup&&A.collisionFilterMask&v.collisionFilterGroup)||u.distanceTo(d)>v.boundingSphereRadius+A.boundingSphereRadius)continue;let S=null;v.material&&A.material&&(S=n.getContactMaterial(v.material,A.material)||null),this.currentContactMaterial=S||g||n.defaultContactMaterial;const T=v.type|A.type,M=this[T];if(M){let B=!1;v.type<A.type?B=M.call(this,v,A,u,d,a,c,p,x,v,A,w):B=M.call(this,A,v,d,u,c,a,x,p,v,A,w),B&&w&&(n.shapeOverlapKeeper.set(v.id,A.id),n.bodyOverlapKeeper.set(p.id,x.id))}}}}}sphereSphere(t,e,n,s,i,o,r,a,c,u,d){if(d)return n.distanceSquared(s)<(t.radius+e.radius)**2;const h=this.createContactEquation(r,a,t,e,c,u);s.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(t.radius,h.ri),h.rj.scale(-e.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(r.position,h.ri),h.rj.vadd(s,h.rj),h.rj.vsub(a.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(t,e,n,s,i,o,r,a,c,u,d){const h=this.createContactEquation(r,a,t,e,c,u);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(t.radius,h.ri),n.vsub(s,Gs),h.ni.scale(h.ni.dot(Gs),ga),Gs.vsub(ga,h.rj),-Gs.dot(h.ni)<=t.radius){if(d)return!0;const f=h.ri,p=h.rj;f.vadd(n,f),f.vsub(r.position,f),p.vadd(s,p),p.vsub(a.position,p),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(t,e,n,s,i,o,r,a,c,u,d){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,d)}sphereBox(t,e,n,s,i,o,r,a,c,u,d){const h=this.v3pool,f=bf;n.vsub(s,$s),e.getSideNormals(f,o);const p=t.radius;let x=!1;const g=Sf,w=Tf,m=Ef;let v=null,b=0,A=0,S=0,T=null;for(let L=0,j=f.length;L!==j&&x===!1;L++){const V=gf;V.copy(f[L]);const q=V.length();V.normalize();const pt=$s.dot(V);if(pt<q+p&&pt>0){const ct=xf,k=vf;ct.copy(f[(L+1)%3]),k.copy(f[(L+2)%3]);const Je=ct.length(),ys=k.length();ct.normalize(),k.normalize();const Ri=$s.dot(ct),Vi=$s.dot(k);if(Ri<Je&&Ri>-Je&&Vi<ys&&Vi>-ys){const dr=Math.abs(pt-q-p);if((T===null||dr<T)&&(T=dr,A=Ri,S=Vi,v=q,g.copy(V),w.copy(ct),m.copy(k),b++,d))return!0}}}if(b){x=!0;const L=this.createContactEquation(r,a,t,e,c,u);g.scale(-p,L.ri),L.ni.copy(g),L.ni.negate(L.ni),g.scale(v,g),w.scale(A,w),g.vadd(w,g),m.scale(S,m),g.vadd(m,L.rj),L.ri.vadd(n,L.ri),L.ri.vsub(r.position,L.ri),L.rj.vadd(s,L.rj),L.rj.vsub(a.position,L.rj),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}let M=h.get();const B=Af;for(let L=0;L!==2&&!x;L++)for(let j=0;j!==2&&!x;j++)for(let V=0;V!==2&&!x;V++)if(M.set(0,0,0),L?M.vadd(f[0],M):M.vsub(f[0],M),j?M.vadd(f[1],M):M.vsub(f[1],M),V?M.vadd(f[2],M):M.vsub(f[2],M),s.vadd(M,B),B.vsub(n,B),B.lengthSquared()<p*p){if(d)return!0;x=!0;const q=this.createContactEquation(r,a,t,e,c,u);q.ri.copy(B),q.ri.normalize(),q.ni.copy(q.ri),q.ri.scale(p,q.ri),q.rj.copy(M),q.ri.vadd(n,q.ri),q.ri.vsub(r.position,q.ri),q.rj.vadd(s,q.rj),q.rj.vsub(a.position,q.rj),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult)}h.release(M),M=null;const C=h.get(),z=h.get(),_=h.get(),E=h.get(),P=h.get(),I=f.length;for(let L=0;L!==I&&!x;L++)for(let j=0;j!==I&&!x;j++)if(L%3!==j%3){f[j].cross(f[L],C),C.normalize(),f[L].vadd(f[j],z),_.copy(n),_.vsub(z,_),_.vsub(s,_);const V=_.dot(C);C.scale(V,E);let q=0;for(;q===L%3||q===j%3;)q++;P.copy(n),P.vsub(E,P),P.vsub(z,P),P.vsub(s,P);const pt=Math.abs(V),ct=P.length();if(pt<f[q].length()&&ct<p){if(d)return!0;x=!0;const k=this.createContactEquation(r,a,t,e,c,u);z.vadd(E,k.rj),k.rj.copy(k.rj),P.negate(k.ni),k.ni.normalize(),k.ri.copy(k.rj),k.ri.vadd(s,k.ri),k.ri.vsub(n,k.ri),k.ri.normalize(),k.ri.scale(p,k.ri),k.ri.vadd(n,k.ri),k.ri.vsub(r.position,k.ri),k.rj.vadd(s,k.rj),k.rj.vsub(a.position,k.rj),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult)}}h.release(C,z,_,E,P)}planeBox(t,e,n,s,i,o,r,a,c,u,d){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,n,s,i,o,r,a,t,e,d)}convexConvex(t,e,n,s,i,o,r,a,c,u,d,h,f){const p=jf;if(!(n.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,n,i,s,o,p,h,f)){const x=[],g=Of;t.clipAgainstHull(n,i,e,s,o,p,-100,100,x);let w=0;for(let m=0;m!==x.length;m++){if(d)return!0;const v=this.createContactEquation(r,a,t,e,c,u),b=v.ri,A=v.rj;p.negate(v.ni),x[m].normal.negate(g),g.scale(x[m].depth,g),x[m].point.vadd(g,b),A.copy(x[m].point),b.vsub(n,b),A.vsub(s,A),b.vadd(n,b),b.vsub(r.position,b),A.vadd(s,A),A.vsub(a.position,A),this.result.push(v),w++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(v,this.frictionResult)}this.enableFrictionReduction&&w&&this.createFrictionFromAverage(w)}}sphereConvex(t,e,n,s,i,o,r,a,c,u,d){const h=this.v3pool;n.vsub(s,Mf);const f=e.faceNormals,p=e.faces,x=e.vertices,g=t.radius;let w=!1;for(let m=0;m!==x.length;m++){const v=x[m],b=Pf;o.vmult(v,b),s.vadd(b,b);const A=_f;if(b.vsub(n,A),A.lengthSquared()<g*g){if(d)return!0;w=!0;const S=this.createContactEquation(r,a,t,e,c,u);S.ri.copy(A),S.ri.normalize(),S.ni.copy(S.ri),S.ri.scale(g,S.ri),b.vsub(s,S.rj),S.ri.vadd(n,S.ri),S.ri.vsub(r.position,S.ri),S.rj.vadd(s,S.rj),S.rj.vsub(a.position,S.rj),this.result.push(S),this.createFrictionEquationsFromContact(S,this.frictionResult);return}}for(let m=0,v=p.length;m!==v&&w===!1;m++){const b=f[m],A=p[m],S=zf;o.vmult(b,S);const T=If;o.vmult(x[A[0]],T),T.vadd(s,T);const M=Lf;S.scale(-g,M),n.vadd(M,M);const B=Nf;M.vsub(T,B);const C=B.dot(S),z=Ff;if(n.vsub(T,z),C<0&&z.dot(S)>0){const _=[];for(let E=0,P=A.length;E!==P;E++){const I=h.get();o.vmult(x[A[E]],I),s.vadd(I,I),_.push(I)}if(yf(_,S,n)){if(d)return!0;w=!0;const E=this.createContactEquation(r,a,t,e,c,u);S.scale(-g,E.ri),S.negate(E.ni);const P=h.get();S.scale(-C,P);const I=h.get();S.scale(-g,I),n.vsub(s,E.rj),E.rj.vadd(I,E.rj),E.rj.vadd(P,E.rj),E.rj.vadd(s,E.rj),E.rj.vsub(a.position,E.rj),E.ri.vadd(n,E.ri),E.ri.vsub(r.position,E.ri),h.release(P),h.release(I),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult);for(let L=0,j=_.length;L!==j;L++)h.release(_[L]);return}else for(let E=0;E!==A.length;E++){const P=h.get(),I=h.get();o.vmult(x[A[(E+1)%A.length]],P),o.vmult(x[A[(E+2)%A.length]],I),s.vadd(P,P),s.vadd(I,I);const L=Bf;I.vsub(P,L);const j=Cf;L.unit(j);const V=h.get(),q=h.get();n.vsub(P,q);const pt=q.dot(j);j.scale(pt,V),V.vadd(P,V);const ct=h.get();if(V.vsub(n,ct),pt>0&&pt*pt<L.lengthSquared()&&ct.lengthSquared()<g*g){if(d)return!0;const k=this.createContactEquation(r,a,t,e,c,u);V.vsub(s,k.rj),V.vsub(n,k.ni),k.ni.normalize(),k.ni.scale(g,k.ri),k.rj.vadd(s,k.rj),k.rj.vsub(a.position,k.rj),k.ri.vadd(n,k.ri),k.ri.vsub(r.position,k.ri),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult);for(let Je=0,ys=_.length;Je!==ys;Je++)h.release(_[Je]);h.release(P),h.release(I),h.release(V),h.release(ct),h.release(q);return}h.release(P),h.release(I),h.release(V),h.release(ct),h.release(q)}for(let E=0,P=_.length;E!==P;E++)h.release(_[E])}}}planeConvex(t,e,n,s,i,o,r,a,c,u,d){const h=Rf,f=Vf;f.set(0,0,1),i.vmult(f,f);let p=0;const x=kf;for(let g=0;g!==e.vertices.length;g++)if(h.copy(e.vertices[g]),o.vmult(h,h),s.vadd(h,h),h.vsub(n,x),f.dot(x)<=0){if(d)return!0;const m=this.createContactEquation(r,a,t,e,c,u),v=qf;f.scale(f.dot(x),v),h.vsub(v,v),v.vsub(n,m.ri),m.ni.copy(f),h.vsub(s,m.rj),m.ri.vadd(n,m.ri),m.ri.vsub(r.position,m.ri),m.rj.vadd(s,m.rj),m.rj.vsub(a.position,m.rj),this.result.push(m),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(m,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(t,e,n,s,i,o,r,a,c,u,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,d)}sphereHeightfield(t,e,n,s,i,o,r,a,c,u,d){const h=e.data,f=t.radius,p=e.elementSize,x=Qf,g=Jf;D.pointToLocalFrame(s,o,n,g);let w=Math.floor((g.x-f)/p)-1,m=Math.ceil((g.x+f)/p)+1,v=Math.floor((g.y-f)/p)-1,b=Math.ceil((g.y+f)/p)+1;if(m<0||b<0||w>h.length||v>h[0].length)return;w<0&&(w=0),m<0&&(m=0),v<0&&(v=0),b<0&&(b=0),w>=h.length&&(w=h.length-1),m>=h.length&&(m=h.length-1),b>=h[0].length&&(b=h[0].length-1),v>=h[0].length&&(v=h[0].length-1);const A=[];e.getRectMinMax(w,v,m,b,A);const S=A[0],T=A[1];if(g.z-f>T||g.z+f<S)return;const M=this.result;for(let B=w;B<m;B++)for(let C=v;C<b;C++){const z=M.length;let _=!1;if(e.getConvexTrianglePillar(B,C,!1),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,n,x,i,o,r,a,t,e,d)),d&&_||(e.getConvexTrianglePillar(B,C,!0),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,n,x,i,o,r,a,t,e,d)),d&&_))return!0;if(M.length-z>2)return}}boxHeightfield(t,e,n,s,i,o,r,a,c,u,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,d)}convexHeightfield(t,e,n,s,i,o,r,a,c,u,d){const h=e.data,f=e.elementSize,p=t.boundingSphereRadius,x=Zf,g=Kf,w=Yf;D.pointToLocalFrame(s,o,n,w);let m=Math.floor((w.x-p)/f)-1,v=Math.ceil((w.x+p)/f)+1,b=Math.floor((w.y-p)/f)-1,A=Math.ceil((w.y+p)/f)+1;if(v<0||A<0||m>h.length||b>h[0].length)return;m<0&&(m=0),v<0&&(v=0),b<0&&(b=0),A<0&&(A=0),m>=h.length&&(m=h.length-1),v>=h.length&&(v=h.length-1),A>=h[0].length&&(A=h[0].length-1),b>=h[0].length&&(b=h[0].length-1);const S=[];e.getRectMinMax(m,b,v,A,S);const T=S[0],M=S[1];if(!(w.z-p>M||w.z+p<T))for(let B=m;B<v;B++)for(let C=b;C<A;C++){let z=!1;if(e.getConvexTrianglePillar(B,C,!1),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(z=this.convexConvex(t,e.pillarConvex,n,x,i,o,r,a,null,null,d,g,null)),d&&z||(e.getConvexTrianglePillar(B,C,!0),D.pointToWorldFrame(s,o,e.pillarOffset,x),n.distanceTo(x)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(z=this.convexConvex(t,e.pillarConvex,n,x,i,o,r,a,null,null,d,g,null)),d&&z))return!0}}sphereParticle(t,e,n,s,i,o,r,a,c,u,d){const h=Hf;if(h.set(0,0,1),s.vsub(n,h),h.lengthSquared()<=t.radius*t.radius){if(d)return!0;const p=this.createContactEquation(a,r,e,t,c,u);h.normalize(),p.rj.copy(h),p.rj.scale(t.radius,p.rj),p.ni.copy(h),p.ni.negate(p.ni),p.ri.set(0,0,0),this.result.push(p),this.createFrictionEquationsFromContact(p,this.frictionResult)}}planeParticle(t,e,n,s,i,o,r,a,c,u,d){const h=Wf;h.set(0,0,1),r.quaternion.vmult(h,h);const f=Gf;if(s.vsub(r.position,f),h.dot(f)<=0){if(d)return!0;const x=this.createContactEquation(a,r,e,t,c,u);x.ni.copy(h),x.ni.negate(x.ni),x.ri.set(0,0,0);const g=$f;h.scale(h.dot(s),g),s.vsub(g,g),x.rj.copy(g),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}}boxParticle(t,e,n,s,i,o,r,a,c,u,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,n,s,i,o,r,a,t,e,d)}convexParticle(t,e,n,s,i,o,r,a,c,u,d){let h=-1;const f=Uf,p=Xf;let x=null;const g=Df;if(g.copy(s),g.vsub(n,g),i.conjugate(xa),xa.vmult(g,g),t.pointIsInside(g)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(n,i),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(i);for(let w=0,m=t.faces.length;w!==m;w++){const v=[t.worldVertices[t.faces[w][0]]],b=t.worldFaceNormals[w];s.vsub(v[0],va);const A=-b.dot(va);if(x===null||Math.abs(A)<Math.abs(x)){if(d)return!0;x=A,h=w,f.copy(b)}}if(h!==-1){const w=this.createContactEquation(a,r,e,t,c,u);f.scale(x,p),p.vadd(s,p),p.vsub(n,p),w.rj.copy(p),f.negate(w.ni),w.ri.set(0,0,0);const m=w.ri,v=w.rj;m.vadd(s,m),m.vsub(a.position,m),v.vadd(n,v),v.vsub(r.position,v),this.result.push(w),this.createFrictionEquationsFromContact(w,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,n,s,i,o,r,a,c,u,d){return this.convexHeightfield(e,t,s,n,o,i,a,r,c,u,d)}particleCylinder(t,e,n,s,i,o,r,a,c,u,d){return this.convexParticle(e,t,s,n,o,i,a,r,c,u,d)}sphereTrimesh(t,e,n,s,i,o,r,a,c,u,d){const h=nf,f=sf,p=of,x=rf,g=af,w=cf,m=df,v=ef,b=Qd,A=ff;D.pointToLocalFrame(s,o,n,g);const S=t.radius;m.lowerBound.set(g.x-S,g.y-S,g.z-S),m.upperBound.set(g.x+S,g.y+S,g.z+S),e.getTrianglesInAABB(m,A);const T=tf,M=t.radius*t.radius;for(let E=0;E<A.length;E++)for(let P=0;P<3;P++)if(e.getVertex(e.indices[A[E]*3+P],T),T.vsub(g,b),b.lengthSquared()<=M){if(v.copy(T),D.pointToWorldFrame(s,o,v,T),T.vsub(n,b),d)return!0;let I=this.createContactEquation(r,a,t,e,c,u);I.ni.copy(b),I.ni.normalize(),I.ri.copy(I.ni),I.ri.scale(t.radius,I.ri),I.ri.vadd(n,I.ri),I.ri.vsub(r.position,I.ri),I.rj.copy(T),I.rj.vsub(a.position,I.rj),this.result.push(I),this.createFrictionEquationsFromContact(I,this.frictionResult)}for(let E=0;E<A.length;E++)for(let P=0;P<3;P++){e.getVertex(e.indices[A[E]*3+P],h),e.getVertex(e.indices[A[E]*3+(P+1)%3],f),f.vsub(h,p),g.vsub(f,w);const I=w.dot(p);g.vsub(h,w);let L=w.dot(p);if(L>0&&I<0&&(g.vsub(h,w),x.copy(p),x.normalize(),L=w.dot(x),x.scale(L,w),w.vadd(h,w),w.distanceTo(g)<t.radius)){if(d)return!0;const V=this.createContactEquation(r,a,t,e,c,u);w.vsub(g,V.ni),V.ni.normalize(),V.ni.scale(t.radius,V.ri),V.ri.vadd(n,V.ri),V.ri.vsub(r.position,V.ri),D.pointToWorldFrame(s,o,w,w),w.vsub(a.position,V.rj),D.vectorToWorldFrame(o,V.ni,V.ni),D.vectorToWorldFrame(o,V.ri,V.ri),this.result.push(V),this.createFrictionEquationsFromContact(V,this.frictionResult)}}const B=lf,C=uf,z=hf,_=Jd;for(let E=0,P=A.length;E!==P;E++){e.getTriangleVertices(A[E],B,C,z),e.getNormal(A[E],_),g.vsub(B,w);let I=w.dot(_);if(_.scale(I,w),g.vsub(w,w),I=w.distanceTo(g),Q.pointInTriangle(w,B,C,z)&&I<t.radius){if(d)return!0;let L=this.createContactEquation(r,a,t,e,c,u);w.vsub(g,L.ni),L.ni.normalize(),L.ni.scale(t.radius,L.ri),L.ri.vadd(n,L.ri),L.ri.vsub(r.position,L.ri),D.pointToWorldFrame(s,o,w,w),w.vsub(a.position,L.rj),D.vectorToWorldFrame(o,L.ni,L.ni),D.vectorToWorldFrame(o,L.ri,L.ri),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}}A.length=0}planeTrimesh(t,e,n,s,i,o,r,a,c,u,d){const h=new y,f=Yd;f.set(0,0,1),i.vmult(f,f);for(let p=0;p<e.vertices.length/3;p++){e.getVertex(p,h);const x=new y;x.copy(h),D.pointToWorldFrame(s,o,x,h);const g=Zd;if(h.vsub(n,g),f.dot(g)<=0){if(d)return!0;const m=this.createContactEquation(r,a,t,e,c,u);m.ni.copy(f);const v=Kd;f.scale(g.dot(f),v),h.vsub(v,v),m.ri.copy(v),m.ri.vsub(r.position,m.ri),m.rj.copy(h),m.rj.vsub(a.position,m.rj),this.result.push(m),this.createFrictionEquationsFromContact(m,this.frictionResult)}}}}const qe=new y,hn=new y,dn=new y,Hd=new y,Dd=new y,Ud=new tt,Xd=new tt,Yd=new y,Zd=new y,Kd=new y,Jd=new y,Qd=new y;new y;const tf=new y,ef=new y,nf=new y,sf=new y,of=new y,rf=new y,af=new y,cf=new y,lf=new y,uf=new y,hf=new y,df=new Tt,ff=[],Gs=new y,ga=new y,pf=new y,mf=new y,wf=new y;function yf(l,t,e){let n=null;const s=l.length;for(let i=0;i!==s;i++){const o=l[i],r=pf;l[(i+1)%s].vsub(o,r);const a=mf;r.cross(t,a);const c=wf;e.vsub(o,c);const u=a.dot(c);if(n===null||u>0&&n===!0||u<=0&&n===!1){n===null&&(n=u>0);continue}else return!1}return!0}const $s=new y,gf=new y,xf=new y,vf=new y,bf=[new y,new y,new y,new y,new y,new y],Af=new y,Sf=new y,Tf=new y,Ef=new y,Mf=new y,Bf=new y,Cf=new y,_f=new y,Pf=new y,zf=new y,If=new y,Lf=new y,Nf=new y,Ff=new y;new y;new y;const Rf=new y,Vf=new y,kf=new y,qf=new y,jf=new y,Of=new y,Wf=new y,Gf=new y,$f=new y,Hf=new y,xa=new tt,Df=new y;new y;const Uf=new y,va=new y,Xf=new y,Yf=new y,Zf=new y,Kf=[0],Jf=new y,Qf=new y;class ba{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const n=e;e=t,t=n}return t<<16|e}set(t,e){const n=this.getKey(t,e),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let a=0;a<i;a++){let c=!1;const u=n[a];for(;u>s[r];)r++;c=u===s[r],c||Aa(t,u)}r=0;for(let a=0;a<o;a++){let c=!1;const u=s[a];for(;u>n[r];)r++;c=n[r]===u,c||Aa(e,u)}}}function Aa(l,t){l.push((t&4294901760)>>16,t&65535)}const yo=(l,t)=>l<t?`${l}-${t}`:`${t}-${l}`;class tp{constructor(){this.data={keys:[]}}get(t,e){const n=yo(t,e);return this.data[n]}set(t,e,n){const s=yo(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=n}delete(t,e){const n=yo(t,e),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const n=e.pop();delete t[n]}}}class ep extends Ka{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new y,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new y,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new ad,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new kd,this.constraints=[],this.narrowphase=new $d(this),this.collisionMatrix=new aa,this.collisionMatrixPrevious=new aa,this.bodyOverlapKeeper=new ba,this.shapeOverlapKeeper=new ba,this.contactmaterials=[],this.contactMaterialTable=new tp,this.defaultMaterial=new Ti("default"),this.defaultContactMaterial=new Si(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,n){n instanceof si?this.raycastClosest(t,e,{skipBackfaces:!0},n):this.raycastAll(t,e,{skipBackfaces:!0},n)}raycastAll(t,e,n,s){return n===void 0&&(n={}),n.mode=Q.ALL,n.from=t,n.to=e,n.callback=s,go.intersectWorld(this,n)}raycastAny(t,e,n,s){return n===void 0&&(n={}),n.mode=Q.ANY,n.from=t,n.to=e,n.result=s,go.intersectWorld(this,n)}raycastClosest(t,e,n,s){return n===void 0&&(n={}),n.mode=Q.CLOSEST,n.from=t,n.to=e,n.result=s,go.intersectWorld(this,n)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof F&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,n=this.bodies,s=n.indexOf(t);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const n=st.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const s=n-this.lastCallTime;this.step(t,s,e)}this.lastCallTime=n}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const s=st.now();let i=0;for(;this.accumulator>=t&&i<n&&(this.internalStep(t),this.accumulator-=t,i++,!(st.now()-s>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,n=rp,s=ap,i=this.bodies.length,o=this.bodies,r=this.solver,a=this.gravity,c=this.doProfiling,u=this.profile,d=F.DYNAMIC;let h=-1/0;const f=this.constraints,p=op;a.length();const x=a.x,g=a.y,w=a.z;let m=0;for(c&&(h=st.now()),m=0;m!==i;m++){const E=o[m];if(E.type===d){const P=E.force,I=E.mass;P.x+=I*x,P.y+=I*g,P.z+=I*w}}for(let E=0,P=this.subsystems.length;E!==P;E++)this.subsystems[E].update();c&&(h=st.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),c&&(u.broadphase=st.now()-h);let v=f.length;for(m=0;m!==v;m++){const E=f[m];if(!E.collideConnected)for(let P=n.length-1;P>=0;P-=1)(E.bodyA===n[P]&&E.bodyB===s[P]||E.bodyB===n[P]&&E.bodyA===s[P])&&(n.splice(P,1),s.splice(P,1))}this.collisionMatrixTick(),c&&(h=st.now());const b=ip,A=e.length;for(m=0;m!==A;m++)b.push(e[m]);e.length=0;const S=this.frictionEquations.length;for(m=0;m!==S;m++)p.push(this.frictionEquations[m]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,e,b,this.frictionEquations,p),c&&(u.narrowphase=st.now()-h),c&&(h=st.now()),m=0;m<this.frictionEquations.length;m++)r.addEquation(this.frictionEquations[m]);const T=e.length;for(let E=0;E!==T;E++){const P=e[E],I=P.bi,L=P.bj,j=P.si,V=P.sj;let q;if(I.material&&L.material?q=this.getContactMaterial(I.material,L.material)||this.defaultContactMaterial:q=this.defaultContactMaterial,q.friction,I.material&&L.material&&(I.material.friction>=0&&L.material.friction>=0&&I.material.friction*L.material.friction,I.material.restitution>=0&&L.material.restitution>=0&&(P.restitution=I.material.restitution*L.material.restitution)),r.addEquation(P),I.allowSleep&&I.type===F.DYNAMIC&&I.sleepState===F.SLEEPING&&L.sleepState===F.AWAKE&&L.type!==F.STATIC){const pt=L.velocity.lengthSquared()+L.angularVelocity.lengthSquared(),ct=L.sleepSpeedLimit**2;pt>=ct*2&&(I.wakeUpAfterNarrowphase=!0)}if(L.allowSleep&&L.type===F.DYNAMIC&&L.sleepState===F.SLEEPING&&I.sleepState===F.AWAKE&&I.type!==F.STATIC){const pt=I.velocity.lengthSquared()+I.angularVelocity.lengthSquared(),ct=I.sleepSpeedLimit**2;pt>=ct*2&&(L.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(I,L,!0),this.collisionMatrixPrevious.get(I,L)||(Wn.body=L,Wn.contact=P,I.dispatchEvent(Wn),Wn.body=I,L.dispatchEvent(Wn)),this.bodyOverlapKeeper.set(I.id,L.id),this.shapeOverlapKeeper.set(j.id,V.id)}for(this.emitContactEvents(),c&&(u.makeContactConstraints=st.now()-h,h=st.now()),m=0;m!==i;m++){const E=o[m];E.wakeUpAfterNarrowphase&&(E.wakeUp(),E.wakeUpAfterNarrowphase=!1)}for(v=f.length,m=0;m!==v;m++){const E=f[m];E.update();for(let P=0,I=E.equations.length;P!==I;P++){const L=E.equations[P];r.addEquation(L)}}r.solve(t,this),c&&(u.solve=st.now()-h),r.removeAllEquations();const M=Math.pow;for(m=0;m!==i;m++){const E=o[m];if(E.type&d){const P=M(1-E.linearDamping,t),I=E.velocity;I.scale(P,I);const L=E.angularVelocity;if(L){const j=M(1-E.angularDamping,t);L.scale(j,L)}}}this.dispatchEvent(sp),c&&(h=st.now());const C=this.stepnumber%(this.quatNormalizeSkip+1)===0,z=this.quatNormalizeFast;for(m=0;m!==i;m++)o[m].integrate(t,C,z);this.clearForces(),this.broadphase.dirty=!0,c&&(u.integrate=st.now()-h),this.stepnumber+=1,this.dispatchEvent(np);let _=!0;if(this.allowSleep)for(_=!1,m=0;m!==i;m++){const E=o[m];E.sleepTick(this.time),E.sleepState!==F.SLEEPING&&(_=!0)}this.hasActiveBodies=_}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(ce,le),t){for(let i=0,o=ce.length;i<o;i+=2)Gn.bodyA=this.getBodyById(ce[i]),Gn.bodyB=this.getBodyById(ce[i+1]),this.dispatchEvent(Gn);Gn.bodyA=Gn.bodyB=null}if(e){for(let i=0,o=le.length;i<o;i+=2)$n.bodyA=this.getBodyById(le[i]),$n.bodyB=this.getBodyById(le[i+1]),this.dispatchEvent($n);$n.bodyA=$n.bodyB=null}ce.length=le.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(ce,le),n){for(let i=0,o=ce.length;i<o;i+=2){const r=this.getShapeById(ce[i]),a=this.getShapeById(ce[i+1]);ue.shapeA=r,ue.shapeB=a,r&&(ue.bodyA=r.body),a&&(ue.bodyB=a.body),this.dispatchEvent(ue)}ue.bodyA=ue.bodyB=ue.shapeA=ue.shapeB=null}if(s){for(let i=0,o=le.length;i<o;i+=2){const r=this.getShapeById(le[i]),a=this.getShapeById(le[i+1]);he.shapeA=r,he.shapeB=a,r&&(he.bodyA=r.body),a&&(he.bodyB=a.body),this.dispatchEvent(he)}he.bodyA=he.bodyB=he.shapeA=he.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let n=0;n!==e;n++){const s=t[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new Tt;const go=new Q,st=globalThis.performance||{};if(!st.now){let l=Date.now();st.timing&&st.timing.navigationStart&&(l=st.timing.navigationStart),st.now=()=>Date.now()-l}new y;const np={type:"postStep"},sp={type:"preStep"},Wn={type:F.COLLIDE_EVENT_NAME,body:null,contact:null},ip=[],op=[],rp=[],ap=[],ce=[],le=[],Gn={type:"beginContact",bodyA:null,bodyB:null},$n={type:"endContact",bodyA:null,bodyB:null},ue={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},he={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},rr=new ep;rr.gravity.set(0,-9.82,0);rr.allowSleep=!0;const qt=ut.frameWidthInner/2+.1,zn=.8,ar=zn-.04,cp=.03,oc=Math.ceil(ut.frameHeightInner/ar),{floorXLength:lp,floorZLength:up,ny:hp}=$,Ei=new pe;Ei.position.set(-lp/2+qt/2+3.5,-hp+ar*oc+.5,-up/2-.3);const dp=new W(qt,cp,zn,2,.4),fp=new bt({wireframe:St,roughness:.6,metalness:.8}),it=[];for(let l=0;l<oc;l++){const t=new G(dp,fp);t.position.set(0,-l*ar,0),t.receiveShadow=!0,t.castShadow=!0,t.rotation.set(zt(15),0,0),it.push(t)}Ei.add(...it);O.add(Ei);const rc=new No(Ei);rc.visible=!1;O.add(rc);const Hn=1,Sa=.15;let wn=!1,yn=!1,gn=!1,xn=!1,xo=!0,Zs=!0;const pp=()=>{Zs&&(xo?(ac(),xo=!1):(cc(),xo=!0))},mp=()=>{Zs?(lc(),Zs=!1):(uc(),Zs=!0)},ac=()=>{wn=!0,yn=!1,gn=!1,xn=!1},cc=()=>{yn=!0,wn=!1,gn=!1,xn=!1},lc=()=>{gn=!0,wn=!1,yn=!1,xn=!1},uc=()=>{xn=!0,wn=!1,yn=!1,gn=!1},wp=l=>{wn?it[0].rotation.x>zt(-88)?it.forEach(t=>{t.rotation.x-=l*Hn}):wn=!1:yn?it[0].rotation.x<zt(15)?it.forEach(t=>{t.rotation.x+=l*Hn}):yn=!1:gn?it[0].rotation.x>zt(2)?it.forEach(t=>{t.rotation.x-=l*Hn}):it[0].rotation.x<zt(-2)?it.forEach(t=>{t.rotation.x+=l*Hn}):it[it.length-1].position.y<-1?it.forEach((t,e)=>{t.position.y+=l*Sa*e}):gn=!1:xn&&(it[it.length-1].position.y>-21.27?(it.forEach((t,e)=>{t.position.y-=l*Sa*e}),it[0].rotation.x<zt(15)&&it.forEach(t=>{t.rotation.x+=l*Hn})):xn=!1)},Po=ut.frameWidthInner/2+.1,hc=.8,cr=hc-.04,yp=.03,dc=Math.ceil(ut.frameHeightInner/cr),{floorXLength:gp,floorZLength:xp,ny:vp}=$,Mi=new pe;Mi.position.set(-gp/2+Po+Po/2+3.6,-vp+cr*dc+.5,-xp/2-.3);const bp=new W(Po,yp,hc,2,.4),Ap=new bt({wireframe:St,roughness:.6,metalness:.8}),ot=[];for(let l=0;l<dc;l++){const t=new G(bp,Ap);t.position.set(0,-l*cr,0),t.receiveShadow=!0,t.castShadow=!0,t.rotation.set(zt(15),0,0),t.name="blind2",ot.push(t)}Mi.add(...ot);O.add(Mi);const fc=new No(Mi);fc.visible=!1;O.add(fc);const Dn=1,Ta=.15;let vn=!1,bn=!1,An=!1,Sn=!1,vo=!0,Ks=!0;const Sp=()=>{Ks&&(vo?(pc(),vo=!1):(mc(),vo=!0))},Tp=()=>{Ks?(wc(),Ks=!1):(yc(),Ks=!0)},pc=()=>{vn=!0,bn=!1,An=!1,Sn=!1},mc=()=>{bn=!0,vn=!1,An=!1,Sn=!1},wc=()=>{An=!0,vn=!1,bn=!1,Sn=!1},yc=()=>{Sn=!0,vn=!1,bn=!1,An=!1},Ep=l=>{vn?ot[0].rotation.x>zt(-88)?ot.forEach(t=>{t.rotation.x-=l*Dn}):vn=!1:bn?ot[0].rotation.x<zt(15)?ot.forEach(t=>{t.rotation.x+=l*Dn}):bn=!1:An?ot[0].rotation.x>zt(2)?ot.forEach(t=>{t.rotation.x-=l*Dn}):ot[0].rotation.x<zt(-2)?ot.forEach(t=>{t.rotation.x+=l*Dn}):ot[ot.length-1].position.y<-1?ot.forEach((t,e)=>{t.position.y+=l*Ta*e}):An=!1:Sn&&(ot[ot.length-1].position.y>-21.27?(ot.forEach((t,e)=>{t.position.y-=l*Ta*e}),ot[0].rotation.x<zt(15)&&ot.forEach(t=>{t.rotation.x+=l*Dn})):Sn=!1)},{floorXLength:Bi,floorZLength:Ci,ny:_i}=$,Pi=0,zi=new G(new Le(qt,ut.frameHeightInner/2+4,zn),new li({color:65280,transparent:!0,opacity:Pi,wireframe:!0}));zi.position.set(-Bi/2+qt/2+3.5,-_i+8+.5,-Ci/2-.3);zi.name="windowBlind1Area";O.add(zi);const Ii=new G(new Le(qt,ut.frameHeightInner/2-3.5,zn),new li({color:65280,transparent:!0,opacity:Pi,wireframe:!0}));Ii.position.set(-Bi/2+qt/2+3.5,-_i+20.5,-Ci/2-.3);Ii.name="windowBlind1AreaUp";O.add(Ii);const Li=new G(new Le(qt,ut.frameHeightInner/2+4,zn),new li({color:65280,transparent:!0,opacity:Pi,wireframe:!0}));Li.position.set(-Bi/2+qt/2+3.6+qt,-_i+8+.5,-Ci/2-.3);Li.name="windowBlind2Area";O.add(Li);const Ni=new G(new Le(qt,ut.frameHeightInner/2-3.5,zn),new li({color:65280,transparent:!0,opacity:Pi,wireframe:!0}));Ni.position.set(-Bi/2+qt/2+3.6+qt,-_i+20.5,-Ci/2-.3);Ni.name="windowBlind2AreaUp";O.add(Ni);const Hs=l=>{let t=document.querySelector("#cursorTip");t||(t=document.createElement("div"),t.id="cursorTip",t.style.position="fixed",t.style.top="0",t.style.left="0",t.style.pointerEvents="none",t.style.zIndex="-100",t.style.color="white",t.style.fontSize="13px",t.style.padding="6px 10px",t.style.borderRadius="5px",t.style.backgroundColor="rgba(0, 0, 0, 0.5)",t.style.fontFamily="sans-serif",t.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.7)",t.textContent=l),t.textContent=l,document.body.appendChild(t),document.addEventListener("mousemove",e=>{t.style.transform=`translate(${e.clientX+10}px, ${e.clientY+10}px)`,t.style.zIndex="100"})},Mp=()=>{const l=document.querySelector("#cursorTip");l&&document.body.removeChild(l)},Bp=[zi,Li,Ii,Ni],gc=new fl,ze={x:null,y:null};window.addEventListener("mousemove",l=>{ze.x=l.clientX/ne.width*2-1,ze.y=-(l.clientY/ne.height)*2+1});let Ge=null;const Cp=()=>{ze.x&&ze.y&&gc.setFromCamera({x:ze.x,y:ze.y},De)};window.addEventListener("click",l=>{});let xc=0;window.addEventListener("mousedown",()=>{xc=+Date.now()});window.addEventListener("mouseup",l=>{if(+Date.now()-xc<300&&(ze.x=l.clientX/ne.width*2-1,ze.y=-(l.clientY/ne.height)*2+1,Ge))switch(Ge.object.name){case"windowBlind1Area":pp();break;case"windowBlind2Area":Sp();break;case"windowBlind1AreaUp":mp();break;case"windowBlind2AreaUp":Tp();break}});const _p=()=>{const l=gc.intersectObjects(Bp);if(l.length){if(!Ge||Ge.object!==l[0].object)switch(document.documentElement.style.cursor="pointer",l[0].object.name){case"windowBlind1Area":Hs("Click here to open/close blinds 1");break;case"windowBlind2Area":Hs("Click here to open/close blinds 2");break;case"windowBlind1AreaUp":Hs("Click here to lift/drop blinds 1");break;case"windowBlind2AreaUp":Hs("Click here to lift/drop blinds 2");break}[Ge]=l}else Ge&&(document.documentElement.style.cursor="auto",Mp()),Ge=null},Pp=new pl,vc=()=>{yr.begin(),Ut.clear(),er.update(),Mn.update(),rr.fixedStep();const l=Pp.getDelta();Oi.animating&&Oi.update(l),wp(l),Ep(l),Cp(),_p(),Ut.render(O,De),Oi.render(Ut),yr.end(),requestAnimationFrame(vc)},bc=new ml("#ffffff",.2);O.add(bc);const dt=new wl("#ffffff",2);dt.position.set(20,20,-30);dt.castShadow=!0;dt.shadow.mapSize.width=1024;dt.shadow.mapSize.height=1024;dt.shadow.camera.near=1;dt.shadow.camera.far=200;dt.shadow.camera.top=50;dt.shadow.camera.right=50;dt.shadow.camera.bottom=-50;dt.shadow.camera.left=-50;dt.shadow.normalBias=.2;O.add(dt);const Ac=new yl(dt,10);O.add(Ac);Ac.visible=!1;const Sc=new En(dt.shadow.camera);O.add(Sc);Sc.visible=!1;const ie=new gl(16777215,30,40,1);ie.position.set($.wallThickness,2,$.wallThickness);ie.castShadow=!0;ie.shadow.camera.near=1;ie.shadow.camera.far=30;ie.shadow.normalBias=.7;ie.shadow.radius=5;O.add(ie);const Tc=new xl(ie,10);O.add(Tc);Tc.visible=!1;const Ec=new En(ie.shadow.camera);O.add(Ec);Ec.visible=!1;const ye=new ui(16777215,30,60,Math.PI*.11,.6,1);ye.position.set($.floorXLength/2-3,6,-6);ye.target.position.set($.floorXLength/2-3,-$.ny,-6);ye.castShadow=!0;ye.shadow.camera.near=1;ye.shadow.camera.far=30;O.add(ye);const Mc=new hi(ye,16776960);O.add(Mc);Mc.visible=!1;const Bc=new En(ye.shadow.camera);O.add(Bc);Bc.visible=!1;const ge=new ui(16777215,30,60,Math.PI*.11,.6,1);ge.position.set($.floorXLength/2-3,6,6);ge.target.position.set($.floorXLength/2-3,-$.ny,6);ge.castShadow=!0;ge.shadow.camera.near=1;ge.shadow.camera.far=30;O.add(ge);const Cc=new hi(ge,16776960);O.add(Cc);Cc.visible=!1;const _c=new En(ge.shadow.camera);O.add(_c);_c.visible=!1;const xe=new ui(16777215,30,60,Math.PI*.19,.6,1.5);xe.position.set(-($.floorXLength/2-1),6.8,6);xe.target.position.set(-($.floorXLength/2),-$.ny,6);xe.castShadow=!0;xe.shadow.camera.near=1;xe.shadow.camera.far=30;O.add(xe);const Pc=new hi(xe,16776960);O.add(Pc);Pc.visible=!1;const zc=new En(xe.shadow.camera);O.add(zc);zc.visible=!1;const ve=new ui(16777215,30,60,Math.PI*.19,.6,1.5);ve.position.set(-($.floorXLength/2-1),6.8,-6);ve.target.position.set(-($.floorXLength/2),-$.ny,-6);ve.castShadow=!0;ve.shadow.camera.near=1;ve.shadow.camera.far=30;O.add(ve);const Ic=new hi(ve,16776960);O.add(Ic);Ic.visible=!1;const Lc=new En(ve.shadow.camera);O.add(Lc);Lc.visible=!1;const Nc=[ye,ge,xe,ve],zp=()=>{Nc.forEach(l=>{l.visible=!1})},Ip=()=>{Nc.forEach(l=>{l.visible=!0})},{floorXLength:Lp,floorZLength:Np,ny:Fp}=$,lr=new vl(42);lr.position.set(-Lp/2,-Fp,-Np/2);lr.visible=!1;O.add(lr);const{floorXLength:Rp,floorZLength:Vp,ny:kp}=$,ur=new pe;ur.position.set(-Rp/2,-kp,-Vp/2);const qp=Ne({title:"Sofa"}),jp=new Ca(qp);jp.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/ikeaSofa.obj",l=>{l.scale.set(10,10,10),l.rotation.y=-Math.PI/2,l.position.set(33,0,15);const e=l.children[0],n=l.children[1];Ea(e),Ea(n);const s=Ne({title:"Sofa texture",onLoad:()=>{const f=new bt({map:o,normalMap:r,aoMap:a,roughnessMap:c,wireframe:St});e.material=f;const p=new bt({map:u,normalMap:d,aoMap:h,color:5093036,wireframe:St});n.material=p,ur.add(l)}}),i=new Tn(s),o=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Color.jpg");o.colorSpace=Jn,o.wrapS=H,o.wrapT=H;const r=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_NormalGL.jpg");r.wrapS=H,r.wrapT=H;const a=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_AmbientOcclusion.jpg");a.wrapS=H,a.wrapT=H;const c=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Roughness.jpg");c.wrapS=H,c.wrapT=H;const u=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_b.png");u.colorSpace=Jn,u.wrapS=H,u.wrapT=H;const d=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_n.png");d.wrapS=H,d.wrapT=H;const h=i.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_o.png");h.wrapS=H,h.wrapT=H});const Ea=l=>{l.castShadow=!0,l.receiveShadow=!0};O.add(ur);const{floorXLength:Op,floorZLength:Wp,ny:Gp}=$,hr=new pe;hr.position.set(-Op/2,-Gp,-Wp/2);const $p=new W(22,.2,26,2,.5),Hp=Ne({title:"Rug Texture"}),ms=new Tn(Hp),hs=ms.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_COLOR2.png");hs.colorSpace=Jn;const ii=ms.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_DISP.png"),oi=ms.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_NRM.jpg"),ri=ms.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_OCC.jpg"),ai=ms.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_ROUGH.jpg");hs.wrapS=hs.wrapT=ii.wrapS=ii.wrapT=oi.wrapS=oi.wrapT=ri.wrapS=ri.wrapT=ai.wrapS=ai.wrapT=H;const se=.44;hs.repeat.set(se,se);ii.repeat.set(se,se);oi.repeat.set(se,se);ri.repeat.set(se,se);ai.repeat.set(se,se);const Fc=new bt({wireframe:St,map:hs,displacementMap:ii,displacementScale:.005,normalMap:oi,aoMap:ri,roughnessMap:ai});Fc.normalScale.set(1.2,1.2);const Fi=new G($p,Fc);Fi.position.set(28,.01,15);Fi.receiveShadow=!0;Fi.castShadow=!0;hr.add(Fi);O.add(hr);const yt=18.2,Et=18.2,gt=3.3,U=.37,at=.24,Yt=3.3,Mt=3,Bt=.05,Dp={shelfWidth:yt,shelfHeight:Et,shelfDepth:gt,shelfBorderBoardThickness:U,shelfBoardThickness:at,shelfInnerWidth:Yt,roundSegments:Mt,roundRadius:Bt},{floorXLength:Up,floorZLength:Xp,ny:Yp}=$,ft=new pe;ft.position.set(-Up/2+gt/2,-Yp+U/2+.1,-Xp/2+yt/2+2);const nt=new bt({wireframe:St,map:Qn,normalMap:ts,aoMap:es,roughnessMap:ns,metalnessMap:ss,displacementMap:is,displacementScale:.006}),Rc=new G(new W(gt,Et,U,Mt,Bt),nt);Rc.position.set(0,Et/2-U/2,-yt/2+U/2);const Zp=new G(new W(gt,U,yt,Mt,Bt),nt),Vc=new G(new W(gt,at,yt,Mt,Bt),nt);Vc.position.set(0,U+Yt,0);const kc=new G(new W(gt,at,yt,Mt,Bt),nt);kc.position.set(0,U+Yt*2+at,0);const qc=new G(new W(gt,at,yt,Mt,Bt),nt);qc.position.set(0,U+Yt*3+at*2,0);const jc=new G(new W(gt,at,yt,Mt,Bt),nt);jc.position.set(0,U+Yt*4+at*3,0);const Oc=new G(new W(gt,U,yt,Mt,Bt),nt);Oc.position.set(0,U+Yt*5+at*4,0);const Wc=new G(new W(gt,Et,at,Mt,Bt),nt);Wc.position.set(0,Et/2-U/2,-yt/2+U/2+U+Yt);const Gc=new G(new W(gt,Et,at,Mt,Bt),nt);Gc.position.set(0,Et/2-U/2,-yt/2+U/2+U+Yt*2+at);const $c=new G(new W(gt,Et,at,Mt,Bt),nt);$c.position.set(0,Et/2-U/2,-yt/2+U/2+U+Yt*3+at*2);const Hc=new G(new W(gt,Et,at,Mt,Bt),nt);Hc.position.set(0,Et/2-U/2,-yt/2+U/2+U+Yt*4+at*3);const Dc=new G(new W(gt,Et,U,Mt,Bt),nt);Dc.position.set(0,Et/2-U/2,-yt/2+U/2+U+Yt*5+at*4);ft.add(Zp);ft.add(Vc);ft.add(kc);ft.add(qc);ft.add(jc);ft.add(Oc);ft.add(Rc);ft.add(Wc);ft.add(Gc);ft.add($c);ft.add(Hc);ft.add(Dc);ft.children.forEach(l=>{l.castShadow=!0,l.receiveShadow=!0});O.add(ft);const{shelfWidth:Kp,shelfDepth:be,shelfBorderBoardThickness:rt,shelfBoardThickness:Ae,shelfInnerWidth:Ke,roundSegments:Fe,roundRadius:Re}=Dp,Se=Ke*2+Ae+rt*2,In=Ke*4+Ae*3+rt*2,{floorXLength:Jp,floorZLength:Qp,ny:tm}=$,Zt=new pe;Zt.position.set(-Jp/2+be/2,-tm+rt/2+.1,-Qp/2+Se/2+2+Kp);const em=new G(new W(be,rt,Se,Fe,Re),nt),Uc=new G(new W(be,Ae,Se,Fe,Re),nt);Uc.position.set(0,rt+Ke,0);const Xc=new G(new W(be,Ae,Se,Fe,Re),nt);Xc.position.set(0,rt+Ke*2+Ae,0);const Yc=new G(new W(be,Ae,Se,Fe,Re),nt);Yc.position.set(0,rt+Ke*3+Ae*2,0);const Zc=new G(new W(be,rt,Se,Fe,Re),nt);Zc.position.set(0,rt+Ke*4+Ae*3,0);const Kc=new G(new W(be,In,rt,Fe,Re),nt);Kc.position.set(0,In/2-rt/2,-Se/2+rt/2);const Jc=new G(new W(be,In,rt,Fe,Re),nt);Jc.position.set(0,In/2-rt/2,Se/2-rt/2);const Qc=new G(new W(be,In,Ae,Fe,Re),nt);Qc.position.set(0,In/2-rt/2,-Se/2+rt/2+rt+Ke);Zt.add(em);Zt.add(Uc);Zt.add(Xc);Zt.add(Yc);Zt.add(Zc);Zt.add(Kc);Zt.add(Jc);Zt.add(Qc);Zt.children.forEach(l=>{l.castShadow=!0,l.receiveShadow=!0});O.add(Zt);const{floorXLength:nm,floorZLength:sm,ny:im}=$,zo=new pe;zo.position.set(-nm/2,-im,-sm/2);const om=Ne({title:"Table"}),rm=new Ca(om),Ma=new bt({wireframe:St,color:16777215,normalMap:ts,aoMap:es,roughnessMap:ns,metalnessMap:ss,displacementMap:is,displacementScale:.002}),am=new bt({wireframe:St,color:16777215,normalMap:pi,aoMap:mi,roughnessMap:wi,metalnessMap:yi});rm.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/table/ikea Kvistbro storage.obj",l=>{l.scale.set(12,10,12),l.position.set(22,0,15),l.children[73].material=Ma,l.children[72].material=Ma,l.children[73].castShadow=!0,l.children[73].receiveShadow=!0,l.children[72].castShadow=!0,l.children[72].receiveShadow=!0;for(let e=0;e<72;e++){const n=l.children[e];n.castShadow=!0,n.receiveShadow=!0,n.material=am}zo.add(l),O.add(zo)});const ws=new bl,cm={spotLight:!0,closeBlind1:()=>{ac()},openBlind1:()=>{cc()},liftBlind1:()=>{lc()},dropBlind1:()=>{uc()},closeBlind2:()=>{pc()},openBlind2:()=>{mc()},liftBlind2:()=>{wc()},dropBlind2:()=>{yc()}};ws.add(dt,"visible").name("directionalLight");ws.add(ie,"visible").name("pointLight");ws.add(bc,"visible").name("ambientLight");ws.add(cm,"spotLight").name("spotLight").onChange(l=>{l?Ip():zp()});ws.add(Mn,"autoRotate");vc();Al(ne,De,Ut);

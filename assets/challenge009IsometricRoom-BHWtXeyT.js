import"./modulepreload-polyfill-B5Qt9EMX.js";import{v as C,aP as Xs,G as qs,P as Ws,W as js,aQ as Zs,O as Ys,S as Ks,c as Js,B as Ue,V as Et,aR as Bn,aS as J,aT as O,aq as Qs,u as ct,ap as st,aU as ti,X as Pn,aj as Dn,aV as Ss,aW as Ct,M as qt,aX as ei,a as _n,a3 as ni,aY as si,s as kn,b as ii,aZ as ri,p as oi,a_ as ci,a$ as ai,A as li,l as ui}from"./OrbitControls-DZXoXUOl.js";const jt=new C;function q(n,t,e,s,i,o){const a=2*Math.PI*i/4,c=Math.max(o-2*i,0),r=Math.PI/4;jt.copy(t),jt[s]=0,jt.normalize();const u=.5*a/(a+c),l=1-jt.angleTo(n)/r;return Math.sign(jt[e])===1?l*u:c/(a+c)+u+u*(1-l)}class zt extends Xs{constructor(t=1,e=1,s=1,i=2,o=.1){if(i=i*2+1,o=Math.min(t/2,e/2,s/2,o),super(1,1,1,i,i,i),i===1)return;const a=this.toNonIndexed();this.index=null,this.attributes.position=a.attributes.position,this.attributes.normal=a.attributes.normal,this.attributes.uv=a.attributes.uv;const c=new C,r=new C,u=new C(t,e,s).divideScalar(2).subScalar(o),l=this.attributes.position.array,p=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,y=new C,T=.5/i;for(let w=0,d=0;w<l.length;w+=3,d+=2)switch(c.fromArray(l,w),r.copy(c),r.x-=Math.sign(r.x)*T,r.y-=Math.sign(r.y)*T,r.z-=Math.sign(r.z)*T,r.normalize(),l[w+0]=u.x*Math.sign(c.x)+r.x*o,l[w+1]=u.y*Math.sign(c.y)+r.y*o,l[w+2]=u.z*Math.sign(c.z)+r.z*o,p[w+0]=r.x,p[w+1]=r.y,p[w+2]=r.z,Math.floor(w/h)){case 0:y.set(1,0,0),f[d+0]=q(y,r,"z","y",o,s),f[d+1]=1-q(y,r,"y","z",o,e);break;case 1:y.set(-1,0,0),f[d+0]=1-q(y,r,"z","y",o,s),f[d+1]=1-q(y,r,"y","z",o,e);break;case 2:y.set(0,1,0),f[d+0]=1-q(y,r,"x","z",o,t),f[d+1]=q(y,r,"z","x",o,s);break;case 3:y.set(0,-1,0),f[d+0]=1-q(y,r,"x","z",o,t),f[d+1]=1-q(y,r,"z","x",o,s);break;case 4:y.set(0,0,1),f[d+0]=1-q(y,r,"x","y",o,t),f[d+1]=1-q(y,r,"y","x",o,e);break;case 5:y.set(0,0,-1),f[d+0]=q(y,r,"x","y",o,t),f[d+1]=1-q(y,r,"y","x",o,e);break}}}const fi=new qs,oe={width:window.innerWidth,height:window.innerHeight},ce=new Ws(20,oe.width/oe.height,.1,1e5);ce.position.set(120,60,120);const Bs=document.querySelector("canvas.webgl");if(Bs===null)throw new Error("Cannot find the canvas element");const nt=new js({canvas:Bs,antialias:!0});nt.setSize(oe.width,oe.height);nt.setPixelRatio(Math.min(window.devicePixelRatio,2));nt.autoClear=!1;nt.shadowMap.enabled=!0;nt.shadowMap.type=Zs;const Mn=new Ys(ce,nt.domElement);Mn.enableDamping=!0;const Tt=new Ks,Ge=Js(ce,nt.domElement),Ps=0,pi=1,di=2,$n=2,Oe=1.25,Hn=1,se=6*4+4+4,ve=65535,hi=Math.pow(2,-24),Xe=Symbol("SKIP_GENERATION");function yi(n){return n.index?n.index.count:n.attributes.position.count}function Wt(n){return yi(n)/3}function gi(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function mi(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=gi(e,s);n.setIndex(new Ue(i,1));for(let o=0;o<e;o++)i[o]=o}}function _s(n){const t=Wt(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,o=Math.max(0,s),a=Math.min(t,i)-o;return[{offset:Math.floor(o),count:Math.floor(a)}]}function Ms(n){if(!n.groups||!n.groups.length)return _s(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,o=(s.start+s.count)/3;for(const c of n.groups){const r=c.start/3,u=(c.start+c.count)/3;e.add(Math.max(i,r)),e.add(Math.min(o,u))}const a=Array.from(e.values()).sort((c,r)=>c-r);for(let c=0;c<a.length-1;c++){const r=a[c],u=a[c+1];t.push({offset:Math.floor(r),count:Math.floor(u-r)})}return t}function wi(n){if(n.groups.length===0)return!1;const t=Wt(n),e=Ms(n).sort((o,a)=>o.offset-a.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:o})=>i+=o),t!==i}function qe(n,t,e,s,i){let o=1/0,a=1/0,c=1/0,r=-1/0,u=-1/0,l=-1/0,p=1/0,f=1/0,h=1/0,y=-1/0,T=-1/0,w=-1/0;for(let d=t*6,m=(t+e)*6;d<m;d+=6){const g=n[d+0],A=n[d+1],x=g-A,S=g+A;x<o&&(o=x),S>r&&(r=S),g<p&&(p=g),g>y&&(y=g);const b=n[d+2],B=n[d+3],P=b-B,M=b+B;P<a&&(a=P),M>u&&(u=M),b<f&&(f=b),b>T&&(T=b);const E=n[d+4],_=n[d+5],I=E-_,z=E+_;I<c&&(c=I),z>l&&(l=z),E<h&&(h=E),E>w&&(w=E)}s[0]=o,s[1]=a,s[2]=c,s[3]=r,s[4]=u,s[5]=l,i[0]=p,i[1]=f,i[2]=h,i[3]=y,i[4]=T,i[5]=w}function xi(n,t=null,e=null,s=null){const i=n.attributes.position,o=n.index?n.index.array:null,a=Wt(n),c=i.normalized;let r;t===null?(r=new Float32Array(a*6*4),e=0,s=a):(r=t,e=e||0,s=s||a);const u=i.array,l=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+s;h++){const y=h*3,T=h*6;let w=y+0,d=y+1,m=y+2;o&&(w=o[w],d=o[d],m=o[m]),c||(w=w*p+l,d=d*p+l,m=m*p+l);for(let g=0;g<3;g++){let A,x,S;c?(A=i[f[g]](w),x=i[f[g]](d),S=i[f[g]](m)):(A=u[w+g],x=u[d+g],S=u[m+g]);let b=A;x<b&&(b=x),S<b&&(b=S);let B=A;x>B&&(B=x),S>B&&(B=S);const P=(B-b)/2,M=g*2;r[T+M+0]=b+P,r[T+M+1]=P+(Math.abs(b)+P)*hi}}return r}function v(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Gn(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function On(n,t){t.set(n)}function Xn(n,t,e){let s,i;for(let o=0;o<3;o++){const a=o+3;s=n[o],i=t[o],e[o]=s<i?s:i,s=n[a],i=t[a],e[a]=s>i?s:i}}function ae(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],o=t[n+2*s+1],a=i-o,c=i+o;a<e[s]&&(e[s]=a),c>e[s+3]&&(e[s+3]=c)}}function Zt(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const ft=32,Ai=(n,t)=>n.candidate-t.candidate,yt=new Array(ft).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),le=new Float32Array(6);function bi(n,t,e,s,i,o){let a=-1,c=0;if(o===Ps)a=Gn(t),a!==-1&&(c=(t[a]+t[a+3])/2);else if(o===pi)a=Gn(n),a!==-1&&(c=Ti(e,s,i,a));else if(o===di){const r=Zt(n);let u=Oe*i;const l=s*6,p=(s+i)*6;for(let f=0;f<3;f++){const h=t[f],w=(t[f+3]-h)/ft;if(i<ft/4){const d=[...yt];d.length=i;let m=0;for(let A=l;A<p;A+=6,m++){const x=d[m];x.candidate=e[A+2*f],x.count=0;const{bounds:S,leftCacheBounds:b,rightCacheBounds:B}=x;for(let P=0;P<3;P++)B[P]=1/0,B[P+3]=-1/0,b[P]=1/0,b[P+3]=-1/0,S[P]=1/0,S[P+3]=-1/0;ae(A,e,S)}d.sort(Ai);let g=i;for(let A=0;A<g;A++){const x=d[A];for(;A+1<g&&d[A+1].candidate===x.candidate;)d.splice(A+1,1),g--}for(let A=l;A<p;A+=6){const x=e[A+2*f];for(let S=0;S<g;S++){const b=d[S];x>=b.candidate?ae(A,e,b.rightCacheBounds):(ae(A,e,b.leftCacheBounds),b.count++)}}for(let A=0;A<g;A++){const x=d[A],S=x.count,b=i-x.count,B=x.leftCacheBounds,P=x.rightCacheBounds;let M=0;S!==0&&(M=Zt(B)/r);let E=0;b!==0&&(E=Zt(P)/r);const _=Hn+Oe*(M*S+E*b);_<u&&(a=f,u=_,c=x.candidate)}}else{for(let g=0;g<ft;g++){const A=yt[g];A.count=0,A.candidate=h+w+g*w;const x=A.bounds;for(let S=0;S<3;S++)x[S]=1/0,x[S+3]=-1/0}for(let g=l;g<p;g+=6){let S=~~((e[g+2*f]-h)/w);S>=ft&&(S=ft-1);const b=yt[S];b.count++,ae(g,e,b.bounds)}const d=yt[ft-1];On(d.bounds,d.rightCacheBounds);for(let g=ft-2;g>=0;g--){const A=yt[g],x=yt[g+1];Xn(A.bounds,x.rightCacheBounds,A.rightCacheBounds)}let m=0;for(let g=0;g<ft-1;g++){const A=yt[g],x=A.count,S=A.bounds,B=yt[g+1].rightCacheBounds;x!==0&&(m===0?On(S,le):Xn(S,le,le)),m+=x;let P=0,M=0;m!==0&&(P=Zt(le)/r);const E=i-m;E!==0&&(M=Zt(B)/r);const _=Hn+Oe*(P*m+M*E);_<u&&(a=f,u=_,c=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:a,pos:c}}function Ti(n,t,e,s){let i=0;for(let o=t,a=t+e;o<a;o++)i+=n[o*6+s*2];return i/e}class We{constructor(){this.boundingData=new Float32Array(6)}}function Si(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;a<=c&&e[a*6+u]<r;)a++;for(;a<=c&&e[c*6+u]>=r;)c--;if(a<c){for(let l=0;l<3;l++){let p=t[a*3+l];t[a*3+l]=t[c*3+l],t[c*3+l]=p}for(let l=0;l<6;l++){let p=e[a*6+l];e[a*6+l]=e[c*6+l],e[c*6+l]=p}a++,c--}else return a}}function Bi(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;a<=c&&e[a*6+u]<r;)a++;for(;a<=c&&e[c*6+u]>=r;)c--;if(a<c){let l=n[a];n[a]=n[c],n[c]=l;for(let p=0;p<6;p++){let f=e[a*6+p];e[a*6+p]=e[c*6+p],e[c*6+p]=f}a++,c--}else return a}}function H(n,t){return t[n+15]===65535}function X(n,t){return t[n+6]}function j(n,t){return t[n+14]}function Z(n){return n+8}function Y(n,t){return t[n+6]}function Is(n,t){return t[n+7]}let Es,ne,Ie,Cs;const Pi=Math.pow(2,32);function yn(n){return"count"in n?1:1+yn(n.left)+yn(n.right)}function _i(n,t,e){return Es=new Float32Array(e),ne=new Uint32Array(e),Ie=new Uint16Array(e),Cs=new Uint8Array(e),gn(n,t)}function gn(n,t){const e=n/4,s=n/2,i="count"in t,o=t.boundingData;for(let a=0;a<6;a++)Es[e+a]=o[a];if(i)if(t.buffer){const a=t.buffer;Cs.set(new Uint8Array(a),n);for(let c=n,r=n+a.byteLength;c<r;c+=se){const u=c/2;H(u,Ie)||(ne[c/4+6]+=e)}return n+a.byteLength}else{const a=t.offset,c=t.count;return ne[e+6]=a,Ie[s+14]=c,Ie[s+15]=ve,n+se}else{const a=t.left,c=t.right,r=t.splitAxis;let u;if(u=gn(n+se,a),u/4>Pi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return ne[e+6]=u/4,u=gn(u,c),ne[e+7]=r,u}}function Mi(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),a=s?new Uint32Array(o):new Uint16Array(o);for(let c=0,r=a.length;c<r;c++)a[c]=c;return a}function Ii(n,t,e,s,i){const{maxDepth:o,verbose:a,maxLeafTris:c,strategy:r,onProgress:u,indirect:l}=i,p=n._indirectBuffer,f=n.geometry,h=f.index?f.index.array:null,y=l?Bi:Si,T=Wt(f),w=new Float32Array(6);let d=!1;const m=new We;return qe(t,e,s,m.boundingData,w),A(m,e,s,w),m;function g(x){u&&u(x/T)}function A(x,S,b,B=null,P=0){if(!d&&P>=o&&(d=!0,a&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),b<=c||P>=o)return g(S+b),x.offset=S,x.count=b,x;const M=bi(x.boundingData,B,t,S,b,r);if(M.axis===-1)return g(S+b),x.offset=S,x.count=b,x;const E=y(p,h,t,S,b,M);if(E===S||E===S+b)g(S+b),x.offset=S,x.count=b;else{x.splitAxis=M.axis;const _=new We,I=S,z=E-S;x.left=_,qe(t,I,z,_.boundingData,w),A(_,I,z,w,P+1);const L=new We,N=E,D=b-z;x.right=L,qe(t,N,D,L.boundingData,w),A(L,N,D,w,P+1)}return x}}function Ei(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=Mi(e,t.useSharedArrayBuffer),wi(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||mi(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=xi(e),o=t.indirect?_s(e):Ms(e);n._roots=o.map(a=>{const c=Ii(n,i,a.offset,a.count,t),r=yn(c),u=new s(se*r);return _i(0,c,u),u})}class pt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let o=0,a=t.length;o<a;o++){const r=t[o][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let o=0,a=e.length;o<a;o++){const c=e[o],r=t.dot(c);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}pt.prototype.setFromBox=function(){const n=new C;return function(e,s){const i=s.min,o=s.max;let a=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){n.x=i.x*r+o.x*(1-r),n.y=i.y*u+o.y*(1-u),n.z=i.z*l+o.z*(1-l);const p=e.dot(n);a=Math.min(p,a),c=Math.max(p,c)}this.min=a,this.max=c}}();const Ci=function(){const n=new C,t=new C,e=new C;return function(i,o,a){const c=i.start,r=n,u=o.start,l=t;e.subVectors(c,u),n.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const p=e.dot(l),f=l.dot(r),h=l.dot(l),y=e.dot(r),w=r.dot(r)*h-f*f;let d,m;w!==0?d=(p*f-y*h)/w:d=0,m=(p+d*f)/h,a.x=d,a.y=m}}(),In=function(){const n=new Et,t=new C,e=new C;return function(i,o,a,c){Ci(i,o,n);let r=n.x,u=n.y;if(r>=0&&r<=1&&u>=0&&u<=1){i.at(r,a),o.at(u,c);return}else if(r>=0&&r<=1){u<0?o.at(0,c):o.at(1,c),i.closestPointToPoint(c,!0,a);return}else if(u>=0&&u<=1){r<0?i.at(0,a):i.at(1,a),o.closestPointToPoint(a,!0,c);return}else{let l;r<0?l=i.start:l=i.end;let p;u<0?p=o.start:p=o.end;const f=t,h=e;if(i.closestPointToPoint(p,!0,t),o.closestPointToPoint(l,!0,e),f.distanceToSquared(p)<=h.distanceToSquared(l)){a.copy(f),c.copy(p);return}else{a.copy(l),c.copy(h);return}}}}(),zi=function(){const n=new C,t=new C,e=new Bn,s=new J;return function(o,a){const{radius:c,center:r}=o,{a:u,b:l,c:p}=a;if(s.start=u,s.end=l,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c||(s.start=u,s.end=p,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c)||(s.start=l,s.end=p,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c))return!0;const T=a.getPlane(e);if(Math.abs(T.distanceToPoint(r))<=c){const d=T.projectPoint(r,t);if(a.containsPoint(d))return!0}return!1}}(),Li=1e-15;function je(n){return Math.abs(n)<Li}class Q extends O{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new C),this.satBounds=new Array(4).fill().map(()=>new pt),this.points=[this.a,this.b,this.c],this.sphere=new Qs,this.plane=new Bn,this.needsUpdate=!0}intersectsSphere(t){return zi(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,o=this.satAxes,a=this.satBounds,c=o[0],r=a[0];this.getNormal(c),r.setFromPoints(c,i);const u=o[1],l=a[1];u.subVectors(t,e),l.setFromPoints(u,i);const p=o[2],f=a[2];p.subVectors(e,s),f.setFromPoints(p,i);const h=o[3],y=a[3];h.subVectors(s,t),y.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}Q.prototype.closestPointToSegment=function(){const n=new C,t=new C,e=new J;return function(i,o=null,a=null){const{start:c,end:r}=i,u=this.points;let l,p=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),In(e,i,n,t),l=n.distanceToSquared(t),l<p&&(p=l,o&&o.copy(n),a&&a.copy(t))}return this.closestPointToPoint(c,n),l=c.distanceToSquared(n),l<p&&(p=l,o&&o.copy(n),a&&a.copy(c)),this.closestPointToPoint(r,n),l=r.distanceToSquared(n),l<p&&(p=l,o&&o.copy(n),a&&a.copy(r)),Math.sqrt(p)}}();Q.prototype.intersectsTriangle=function(){const n=new Q,t=new Array(3),e=new Array(3),s=new pt,i=new pt,o=new C,a=new C,c=new C,r=new C,u=new C,l=new J,p=new J,f=new J,h=new C;function y(T,w,d){const m=T.points;let g=0,A=-1;for(let x=0;x<3;x++){const{start:S,end:b}=l;S.copy(m[x]),b.copy(m[(x+1)%3]),l.delta(a);const B=je(w.distanceToPoint(S));if(je(w.normal.dot(a))&&B){d.copy(l),g=2;break}const P=w.intersectLine(l,h);if(!P&&B&&h.copy(S),(P||B)&&!je(h.distanceTo(b))){if(g<=1)(g===1?d.start:d.end).copy(h),B&&(A=g);else if(g>=2){(A===1?d.start:d.end).copy(h),g=2;break}if(g++,g===2&&A===-1)break}}return g}return function(w,d=null,m=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(n.copy(w),n.update(),w=n);const g=this.plane,A=w.plane;if(Math.abs(g.normal.dot(A.normal))>1-1e-10){const x=this.satBounds,S=this.satAxes;e[0]=w.a,e[1]=w.b,e[2]=w.c;for(let P=0;P<4;P++){const M=x[P],E=S[P];if(s.setFromPoints(E,e),M.isSeparated(s))return!1}const b=w.satBounds,B=w.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const M=b[P],E=B[P];if(s.setFromPoints(E,t),M.isSeparated(s))return!1}for(let P=0;P<4;P++){const M=S[P];for(let E=0;E<4;E++){const _=B[E];if(o.crossVectors(M,_),s.setFromPoints(o,t),i.setFromPoints(o,e),s.isSeparated(i))return!1}}return d&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const x=y(this,A,p);if(x===1&&w.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(x!==2)return!1;const S=y(w,g,f);if(S===1&&this.containsPoint(f.end))return d&&(d.start.copy(f.end),d.end.copy(f.end)),!0;if(S!==2)return!1;if(p.delta(c),f.delta(r),c.dot(r)<0){let I=f.start;f.start=f.end,f.end=I}const b=p.start.dot(c),B=p.end.dot(c),P=f.start.dot(c),M=f.end.dot(c),E=B<P,_=b<M;return b!==M&&P!==B&&E===_?!1:(d&&(u.subVectors(p.start,f.start),u.dot(c)>0?d.start.copy(p.start):d.start.copy(f.start),u.subVectors(p.end,f.end),u.dot(c)<0?d.end.copy(p.end):d.end.copy(f.end)),!0)}}}();Q.prototype.distanceToPoint=function(){const n=new C;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();Q.prototype.distanceToTriangle=function(){const n=new C,t=new C,e=["a","b","c"],s=new J,i=new J;return function(a,c=null,r=null){const u=c||r?s:null;if(this.intersectsTriangle(a,u))return(c||r)&&(c&&u.getCenter(c),r&&u.getCenter(r)),0;let l=1/0;for(let p=0;p<3;p++){let f;const h=e[p],y=a[h];this.closestPointToPoint(y,n),f=y.distanceToSquared(n),f<l&&(l=f,c&&c.copy(n),r&&r.copy(y));const T=this[h];a.closestPointToPoint(T,n),f=T.distanceToSquared(n),f<l&&(l=f,c&&c.copy(T),r&&r.copy(n))}for(let p=0;p<3;p++){const f=e[p],h=e[(p+1)%3];s.set(this[f],this[h]);for(let y=0;y<3;y++){const T=e[y],w=e[(y+1)%3];i.set(a[T],a[w]),In(s,i,n,t);const d=n.distanceToSquared(t);d<l&&(l=d,c&&c.copy(n),r&&r.copy(t))}}return Math.sqrt(l)}}();class ${constructor(t,e,s){this.isOrientedBox=!0,this.min=new C,this.max=new C,this.matrix=new ct,this.invMatrix=new ct,this.points=new Array(8).fill().map(()=>new C),this.satAxes=new Array(3).fill().map(()=>new C),this.satBounds=new Array(3).fill().map(()=>new pt),this.alignedSatBounds=new Array(3).fill().map(()=>new pt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}$.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const f=1*u|2*l|4*p,h=i[f];h.x=u?s.x:e.x,h.y=l?s.y:e.y,h.z=p?s.z:e.z,h.applyMatrix4(t)}const o=this.satBounds,a=this.satAxes,c=i[0];for(let u=0;u<3;u++){const l=a[u],p=o[u],f=1<<u,h=i[f];l.subVectors(c,h),p.setFromPoints(l,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();$.prototype.intersectsBox=function(){const n=new pt;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,o=this.satBounds,a=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const u=a[r],l=o[r];if(n.setFromBox(u,e),l.isSeparated(n))return!1}return!0}}();$.prototype.intersectsTriangle=function(){const n=new Q,t=new Array(3),e=new pt,s=new pt,i=new C;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(n.copy(a),n.update(),a=n);const c=this.satBounds,r=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let f=0;f<3;f++){const h=c[f],y=r[f];if(e.setFromPoints(y,t),h.isSeparated(e))return!1}const u=a.satBounds,l=a.satAxes,p=this.points;for(let f=0;f<3;f++){const h=u[f],y=l[f];if(e.setFromPoints(y,p),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=r[f];for(let y=0;y<4;y++){const T=l[y];if(i.crossVectors(h,T),e.setFromPoints(i,t),s.setFromPoints(i,p),e.isSeparated(s))return!1}}return!0}}();$.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();$.prototype.distanceToPoint=function(){const n=new C;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();$.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new J),e=new Array(12).fill().map(()=>new J),s=new C,i=new C;return function(a,c=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(r||u)&&(a.getCenter(i),this.closestPointToPoint(i,s),a.closestPointToPoint(s,i),r&&r.copy(s),u&&u.copy(i)),0;const l=c*c,p=a.min,f=a.max,h=this.points;let y=1/0;for(let w=0;w<8;w++){const d=h[w];i.copy(d).clamp(p,f);const m=d.distanceToSquared(i);if(m<y&&(y=m,r&&r.copy(d),u&&u.copy(i),m<l))return Math.sqrt(m)}let T=0;for(let w=0;w<3;w++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){const g=(w+1)%3,A=(w+2)%3,x=d<<g|m<<A,S=1<<w|d<<g|m<<A,b=h[x],B=h[S];t[T].set(b,B);const M=n[w],E=n[g],_=n[A],I=e[T],z=I.start,L=I.end;z[M]=p[M],z[E]=d?p[E]:f[E],z[_]=m?p[_]:f[E],L[M]=f[M],L[E]=d?p[E]:f[E],L[_]=m?p[_]:f[E],T++}for(let w=0;w<=1;w++)for(let d=0;d<=1;d++)for(let m=0;m<=1;m++){i.x=w?f.x:p.x,i.y=d?f.y:p.y,i.z=m?f.z:p.z,this.closestPointToPoint(i,s);const g=i.distanceToSquared(s);if(g<y&&(y=g,r&&r.copy(s),u&&u.copy(i),g<l))return Math.sqrt(g)}for(let w=0;w<12;w++){const d=t[w];for(let m=0;m<12;m++){const g=e[m];In(d,g,s,i);const A=s.distanceToSquared(i);if(A<y&&(y=A,r&&r.copy(s),u&&u.copy(i),A<l))return Math.sqrt(A)}}return Math.sqrt(y)}}();class En{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Ni extends En{constructor(){super(()=>new Q)}}const K=new Ni;class Ri{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const U=new Ri;let xt,Xt;const Ut=[],ue=new En(()=>new st);function Ui(n,t,e,s,i,o){xt=ue.getPrimitive(),Xt=ue.getPrimitive(),Ut.push(xt,Xt),U.setBuffer(n._roots[t]);const a=mn(0,n.geometry,e,s,i,o);U.clearBuffer(),ue.releasePrimitive(xt),ue.releasePrimitive(Xt),Ut.pop(),Ut.pop();const c=Ut.length;return c>0&&(Xt=Ut[c-1],xt=Ut[c-2]),a}function mn(n,t,e,s,i=null,o=0,a=0){const{float32Array:c,uint16Array:r,uint32Array:u}=U;let l=n*2;if(H(l,r)){const f=X(n,u),h=j(l,r);return v(n,c,xt),s(f,h,!1,a,o+n,xt)}else{let M=function(_){const{uint16Array:I,uint32Array:z}=U;let L=_*2;for(;!H(L,I);)_=Z(_),L=_*2;return X(_,z)},E=function(_){const{uint16Array:I,uint32Array:z}=U;let L=_*2;for(;!H(L,I);)_=Y(_,z),L=_*2;return X(_,z)+j(L,I)};const f=Z(n),h=Y(n,u);let y=f,T=h,w,d,m,g;if(i&&(m=xt,g=Xt,v(y,c,m),v(T,c,g),w=i(m),d=i(g),d<w)){y=h,T=f;const _=w;w=d,d=_,m=g}m||(m=xt,v(y,c,m));const A=H(y*2,r),x=e(m,A,w,a+1,o+y);let S;if(x===$n){const _=M(y),z=E(y)-_;S=s(_,z,!0,a+1,o+y,m)}else S=x&&mn(y,t,e,s,i,o,a+1);if(S)return!0;g=Xt,v(T,c,g);const b=H(T*2,r),B=e(g,b,d,a+1,o+T);let P;if(B===$n){const _=M(T),z=E(T)-_;P=s(_,z,!0,a+1,o+T,g)}else P=B&&mn(T,t,e,s,i,o,a+1);return!!P}}const Yt=new C,Ze=new C;function vi(n,t,e={},s=0,i=1/0){const o=s*s,a=i*i;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(Yt.copy(t).clamp(l.min,l.max),Yt.distanceToSquared(t)),intersectsBounds:(l,p,f)=>f<c&&f<a,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,Yt);const f=t.distanceToSquared(Yt);return f<c&&(Ze.copy(Yt),c=f,r=p),f<o}}),c===1/0)return null;const u=Math.sqrt(c);return e.point?e.point.copy(Ze):e.point=Ze.clone(),e.distance=u,e.faceIndex=r,e}const vt=new C,Ft=new C,Vt=new C,fe=new Et,pe=new Et,de=new Et,qn=new C,Wn=new C,jn=new C,he=new C;function Fi(n,t,e,s,i,o){let a;return o===ti?a=n.intersectTriangle(s,e,t,!0,i):a=n.intersectTriangle(t,e,s,o!==Pn,i),a===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Vi(n,t,e,s,i,o,a,c,r){vt.fromBufferAttribute(t,o),Ft.fromBufferAttribute(t,a),Vt.fromBufferAttribute(t,c);const u=Fi(n,vt,Ft,Vt,he,r);if(u){s&&(fe.fromBufferAttribute(s,o),pe.fromBufferAttribute(s,a),de.fromBufferAttribute(s,c),u.uv=O.getInterpolation(he,vt,Ft,Vt,fe,pe,de,new Et)),i&&(fe.fromBufferAttribute(i,o),pe.fromBufferAttribute(i,a),de.fromBufferAttribute(i,c),u.uv1=O.getInterpolation(he,vt,Ft,Vt,fe,pe,de,new Et)),e&&(qn.fromBufferAttribute(e,o),Wn.fromBufferAttribute(e,a),jn.fromBufferAttribute(e,c),u.normal=O.getInterpolation(he,vt,Ft,Vt,qn,Wn,jn,new C),u.normal.dot(n.direction)>0&&u.normal.multiplyScalar(-1));const l={a:o,b:a,c,normal:new C,materialIndex:0};O.getNormal(vt,Ft,Vt,l.normal),u.face=l,u.faceIndex=o}return u}function Fe(n,t,e,s,i){const o=s*3;let a=o+0,c=o+1,r=o+2;const u=n.index;n.index&&(a=u.getX(a),c=u.getX(c),r=u.getX(r));const{position:l,normal:p,uv:f,uv1:h}=n.attributes,y=Vi(e,l,p,f,h,a,c,r,t);return y?(y.faceIndex=s,i&&i.push(y),y):null}function V(n,t,e,s){const i=n.a,o=n.b,a=n.c;let c=t,r=t+1,u=t+2;e&&(c=e.getX(c),r=e.getX(r),u=e.getX(u)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),o.x=s.getX(r),o.y=s.getY(r),o.z=s.getZ(r),a.x=s.getX(u),a.y=s.getY(u),a.z=s.getZ(u)}function Di(n,t,e,s,i,o){const{geometry:a,_indirectBuffer:c}=n;for(let r=s,u=s+i;r<u;r++)Fe(a,t,e,r,o)}function ki(n,t,e,s,i){const{geometry:o,_indirectBuffer:a}=n;let c=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let p;p=Fe(o,t,e,u),p&&p.distance<c&&(r=p,c=p.distance)}return r}function $i(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,u=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let f;if(f=l,V(a,f*3,r,u),a.needsUpdate=!0,s(a,f,i,o))return!0}return!1}function Hi(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),p(0,u),u+=o.byteLength;function p(f,h,y=!1){const T=f*2;if(c[T+15]===ve){const d=a[f+6],m=c[T+14];let g=1/0,A=1/0,x=1/0,S=-1/0,b=-1/0,B=-1/0;for(let P=3*d,M=3*(d+m);P<M;P++){let E=s[P];const _=i.getX(E),I=i.getY(E),z=i.getZ(E);_<g&&(g=_),_>S&&(S=_),I<A&&(A=I),I>b&&(b=I),z<x&&(x=z),z>B&&(B=z)}return r[f+0]!==g||r[f+1]!==A||r[f+2]!==x||r[f+3]!==S||r[f+4]!==b||r[f+5]!==B?(r[f+0]=g,r[f+1]=A,r[f+2]=x,r[f+3]=S,r[f+4]=b,r[f+5]=B,!0):!1}else{const d=f+8,m=a[f+6],g=d+h,A=m+h;let x=y,S=!1,b=!1;t?x||(S=t.has(g),b=t.has(A),x=!S&&!b):(S=!0,b=!0);const B=x||S,P=x||b;let M=!1;B&&(M=p(d,h,x));let E=!1;P&&(E=p(m,h,x));const _=M||E;if(_)for(let I=0;I<3;I++){const z=d+I,L=m+I,N=r[z],D=r[z+3],Rt=r[L],St=r[L+3];r[f+I]=N<Rt?N:Rt,r[f+I+3]=D>St?D:St}return _}}}const Zn=new st;function bt(n,t,e,s){return v(n,t,Zn),e.intersectBox(Zn,s)}function Gi(n,t,e,s,i,o){const{geometry:a,_indirectBuffer:c}=n;for(let r=s,u=s+i;r<u;r++){let l=c?c[r]:r;Fe(a,t,e,l,o)}}function Oi(n,t,e,s,i){const{geometry:o,_indirectBuffer:a}=n;let c=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let p;p=Fe(o,t,e,a?a[u]:u),p&&p.distance<c&&(r=p,c=p.distance)}return r}function Xi(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,u=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let f;if(f=e.resolveTriangleIndex(l),V(a,f*3,r,u),a.needsUpdate=!0,s(a,f,i,o))return!0}return!1}const Yn=new C;function qi(n,t,e,s,i){U.setBuffer(n._roots[t]),wn(0,n,e,s,i),U.clearBuffer()}function wn(n,t,e,s,i){const{float32Array:o,uint16Array:a,uint32Array:c}=U,r=n*2;if(H(r,a)){const l=X(n,c),p=j(r,a);Di(t,e,s,l,p,i)}else{const l=Z(n);bt(l,o,s,Yn)&&wn(l,t,e,s,i);const p=Y(n,c);bt(p,o,s,Yn)&&wn(p,t,e,s,i)}}const Kn=new C,Wi=["x","y","z"];function ji(n,t,e,s){U.setBuffer(n._roots[t]);const i=xn(0,n,e,s);return U.clearBuffer(),i}function xn(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:a}=U;let c=n*2;if(H(c,o)){const u=X(n,a),l=j(c,o);return ki(t,e,s,u,l)}else{const u=Is(n,a),l=Wi[u],f=s.direction[l]>=0;let h,y;f?(h=Z(n),y=Y(n,a)):(h=Y(n,a),y=Z(n));const w=bt(h,i,s,Kn)?xn(h,t,e,s):null;if(w){const g=w.point[l];if(f?g<=i[y+u]:g>=i[y+u+3])return w}const m=bt(y,i,s,Kn)?xn(y,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const ye=new st,Dt=new Q,kt=new Q,Kt=new ct,Jn=new $,ge=new $;function Zi(n,t,e,s){U.setBuffer(n._roots[t]);const i=An(0,n,e,s);return U.clearBuffer(),i}function An(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=U;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Jn.set(e.boundingBox.min,e.boundingBox.max,s),i=Jn),H(r,a)){const l=t.geometry,p=l.index,f=l.attributes.position,h=e.index,y=e.attributes.position,T=X(n,c),w=j(r,a);if(Kt.copy(s).invert(),e.boundsTree)return v(n,o,ge),ge.matrix.copy(Kt),ge.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>ge.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let g=T*3,A=(w+T)*3;g<A;g+=3)if(V(kt,g,p,f),kt.needsUpdate=!0,m.intersectsTriangle(kt))return!0;return!1}});for(let d=T*3,m=(w+T)*3;d<m;d+=3){V(Dt,d,p,f),Dt.a.applyMatrix4(Kt),Dt.b.applyMatrix4(Kt),Dt.c.applyMatrix4(Kt),Dt.needsUpdate=!0;for(let g=0,A=h.count;g<A;g+=3)if(V(kt,g,h,y),kt.needsUpdate=!0,Dt.intersectsTriangle(kt))return!0}}else{const l=n+8,p=c[n+6];return v(l,o,ye),!!(i.intersectsBox(ye)&&An(l,t,e,s,i)||(v(p,o,ye),i.intersectsBox(ye)&&An(p,t,e,s,i)))}}const me=new ct,Ye=new $,Jt=new $,Yi=new C,Ki=new C,Ji=new C,Qi=new C;function tr(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Ye.set(t.boundingBox.min,t.boundingBox.max,e),Ye.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,u=c.index,l=t.attributes.position,p=t.index,f=K.getPrimitive(),h=K.getPrimitive();let y=Yi,T=Ki,w=null,d=null;i&&(w=Ji,d=Qi);let m=1/0,g=null,A=null;return me.copy(e).invert(),Jt.matrix.copy(me),n.shapecast({boundsTraverseOrder:x=>Ye.distanceToBox(x),intersectsBounds:(x,S,b)=>b<m&&b<a?(S&&(Jt.min.copy(x.min),Jt.max.copy(x.max),Jt.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>Jt.distanceToBox(B),intersectsBounds:(B,P,M)=>M<m&&M<a,intersectsRange:(B,P)=>{for(let M=B,E=B+P;M<E;M++){V(h,3*M,p,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let _=x,I=x+S;_<I;_++){V(f,3*_,u,r),f.needsUpdate=!0;const z=f.distanceToTriangle(h,y,w);if(z<m&&(T.copy(y),d&&d.copy(w),m=z,g=_,A=M),z<o)return!0}}}});{const b=Wt(t);for(let B=0,P=b;B<P;B++){V(h,3*B,p,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=x,E=x+S;M<E;M++){V(f,3*M,u,r),f.needsUpdate=!0;const _=f.distanceToTriangle(h,y,w);if(_<m&&(T.copy(y),d&&d.copy(w),m=_,g=M,A=B),_<o)return!0}}}}}),K.releasePrimitive(f),K.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=m,s.faceIndex=g,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(me),T.applyMatrix4(me),i.distance=T.sub(i.point).length(),i.faceIndex=A),s)}function er(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),p(0,u),u+=o.byteLength;function p(f,h,y=!1){const T=f*2;if(c[T+15]===ve){const d=a[f+6],m=c[T+14];let g=1/0,A=1/0,x=1/0,S=-1/0,b=-1/0,B=-1/0;for(let P=d,M=d+m;P<M;P++){const E=3*n.resolveTriangleIndex(P);for(let _=0;_<3;_++){let I=E+_;I=s?s[I]:I;const z=i.getX(I),L=i.getY(I),N=i.getZ(I);z<g&&(g=z),z>S&&(S=z),L<A&&(A=L),L>b&&(b=L),N<x&&(x=N),N>B&&(B=N)}}return r[f+0]!==g||r[f+1]!==A||r[f+2]!==x||r[f+3]!==S||r[f+4]!==b||r[f+5]!==B?(r[f+0]=g,r[f+1]=A,r[f+2]=x,r[f+3]=S,r[f+4]=b,r[f+5]=B,!0):!1}else{const d=f+8,m=a[f+6],g=d+h,A=m+h;let x=y,S=!1,b=!1;t?x||(S=t.has(g),b=t.has(A),x=!S&&!b):(S=!0,b=!0);const B=x||S,P=x||b;let M=!1;B&&(M=p(d,h,x));let E=!1;P&&(E=p(m,h,x));const _=M||E;if(_)for(let I=0;I<3;I++){const z=d+I,L=m+I,N=r[z],D=r[z+3],Rt=r[L],St=r[L+3];r[f+I]=N<Rt?N:Rt,r[f+I+3]=D>St?D:St}return _}}}const Qn=new C;function nr(n,t,e,s,i){U.setBuffer(n._roots[t]),bn(0,n,e,s,i),U.clearBuffer()}function bn(n,t,e,s,i){const{float32Array:o,uint16Array:a,uint32Array:c}=U,r=n*2;if(H(r,a)){const l=X(n,c),p=j(r,a);Gi(t,e,s,l,p,i)}else{const l=Z(n);bt(l,o,s,Qn)&&bn(l,t,e,s,i);const p=Y(n,c);bt(p,o,s,Qn)&&bn(p,t,e,s,i)}}const ts=new C,sr=["x","y","z"];function ir(n,t,e,s){U.setBuffer(n._roots[t]);const i=Tn(0,n,e,s);return U.clearBuffer(),i}function Tn(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:a}=U;let c=n*2;if(H(c,o)){const u=X(n,a),l=j(c,o);return Oi(t,e,s,u,l)}else{const u=Is(n,a),l=sr[u],f=s.direction[l]>=0;let h,y;f?(h=Z(n),y=Y(n,a)):(h=Y(n,a),y=Z(n));const w=bt(h,i,s,ts)?Tn(h,t,e,s):null;if(w){const g=w.point[l];if(f?g<=i[y+u]:g>=i[y+u+3])return w}const m=bt(y,i,s,ts)?Tn(y,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const we=new st,$t=new Q,Ht=new Q,Qt=new ct,es=new $,xe=new $;function rr(n,t,e,s){U.setBuffer(n._roots[t]);const i=Sn(0,n,e,s);return U.clearBuffer(),i}function Sn(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=U;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),es.set(e.boundingBox.min,e.boundingBox.max,s),i=es),H(r,a)){const l=t.geometry,p=l.index,f=l.attributes.position,h=e.index,y=e.attributes.position,T=X(n,c),w=j(r,a);if(Qt.copy(s).invert(),e.boundsTree)return v(n,o,xe),xe.matrix.copy(Qt),xe.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>xe.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let g=T,A=w+T;g<A;g++)if(V(Ht,3*t.resolveTriangleIndex(g),p,f),Ht.needsUpdate=!0,m.intersectsTriangle(Ht))return!0;return!1}});for(let d=T,m=w+T;d<m;d++){const g=t.resolveTriangleIndex(d);V($t,3*g,p,f),$t.a.applyMatrix4(Qt),$t.b.applyMatrix4(Qt),$t.c.applyMatrix4(Qt),$t.needsUpdate=!0;for(let A=0,x=h.count;A<x;A+=3)if(V(Ht,A,h,y),Ht.needsUpdate=!0,$t.intersectsTriangle(Ht))return!0}}else{const l=n+8,p=c[n+6];return v(l,o,we),!!(i.intersectsBox(we)&&Sn(l,t,e,s,i)||(v(p,o,we),i.intersectsBox(we)&&Sn(p,t,e,s,i)))}}const Ae=new ct,Ke=new $,te=new $,or=new C,cr=new C,ar=new C,lr=new C;function ur(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Ke.set(t.boundingBox.min,t.boundingBox.max,e),Ke.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,u=c.index,l=t.attributes.position,p=t.index,f=K.getPrimitive(),h=K.getPrimitive();let y=or,T=cr,w=null,d=null;i&&(w=ar,d=lr);let m=1/0,g=null,A=null;return Ae.copy(e).invert(),te.matrix.copy(Ae),n.shapecast({boundsTraverseOrder:x=>Ke.distanceToBox(x),intersectsBounds:(x,S,b)=>b<m&&b<a?(S&&(te.min.copy(x.min),te.max.copy(x.max),te.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree){const b=t.boundsTree;return b.shapecast({boundsTraverseOrder:B=>te.distanceToBox(B),intersectsBounds:(B,P,M)=>M<m&&M<a,intersectsRange:(B,P)=>{for(let M=B,E=B+P;M<E;M++){const _=b.resolveTriangleIndex(M);V(h,3*_,p,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let I=x,z=x+S;I<z;I++){const L=n.resolveTriangleIndex(I);V(f,3*L,u,r),f.needsUpdate=!0;const N=f.distanceToTriangle(h,y,w);if(N<m&&(T.copy(y),d&&d.copy(w),m=N,g=I,A=M),N<o)return!0}}}})}else{const b=Wt(t);for(let B=0,P=b;B<P;B++){V(h,3*B,p,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=x,E=x+S;M<E;M++){const _=n.resolveTriangleIndex(M);V(f,3*_,u,r),f.needsUpdate=!0;const I=f.distanceToTriangle(h,y,w);if(I<m&&(T.copy(y),d&&d.copy(w),m=I,g=M,A=B),I<o)return!0}}}}}),K.releasePrimitive(f),K.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=m,s.faceIndex=g,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(Ae),T.applyMatrix4(Ae),i.distance=T.sub(i.point).length(),i.faceIndex=A),s)}function fr(){return typeof SharedArrayBuffer<"u"}const ie=new U.constructor,Le=new U.constructor,mt=new En(()=>new st),Gt=new st,Ot=new st,Je=new st,Qe=new st;let tn=!1;function pr(n,t,e,s){if(tn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");tn=!0;const i=n._roots,o=t._roots;let a,c=0,r=0;const u=new ct().copy(e).invert();for(let l=0,p=i.length;l<p;l++){ie.setBuffer(i[l]),r=0;const f=mt.getPrimitive();v(0,ie.float32Array,f),f.applyMatrix4(u);for(let h=0,y=o.length;h<y&&(Le.setBuffer(o[l]),a=tt(0,0,e,u,s,c,r,0,0,f),Le.clearBuffer(),r+=o[h].length,!a);h++);if(mt.releasePrimitive(f),ie.clearBuffer(),c+=i[l].length,a)break}return tn=!1,a}function tt(n,t,e,s,i,o=0,a=0,c=0,r=0,u=null,l=!1){let p,f;l?(p=Le,f=ie):(p=ie,f=Le);const h=p.float32Array,y=p.uint32Array,T=p.uint16Array,w=f.float32Array,d=f.uint32Array,m=f.uint16Array,g=n*2,A=t*2,x=H(g,T),S=H(A,m);let b=!1;if(S&&x)l?b=i(X(t,d),j(t*2,m),X(n,y),j(n*2,T),r,a+t,c,o+n):b=i(X(n,y),j(n*2,T),X(t,d),j(t*2,m),c,o+n,r,a+t);else if(S){const B=mt.getPrimitive();v(t,w,B),B.applyMatrix4(e);const P=Z(n),M=Y(n,y);v(P,h,Gt),v(M,h,Ot);const E=B.intersectsBox(Gt),_=B.intersectsBox(Ot);b=E&&tt(t,P,s,e,i,a,o,r,c+1,B,!l)||_&&tt(t,M,s,e,i,a,o,r,c+1,B,!l),mt.releasePrimitive(B)}else{const B=Z(t),P=Y(t,d);v(B,w,Je),v(P,w,Qe);const M=u.intersectsBox(Je),E=u.intersectsBox(Qe);if(M&&E)b=tt(n,B,e,s,i,o,a,c,r+1,u,l)||tt(n,P,e,s,i,o,a,c,r+1,u,l);else if(M)if(x)b=tt(n,B,e,s,i,o,a,c,r+1,u,l);else{const _=mt.getPrimitive();_.copy(Je).applyMatrix4(e);const I=Z(n),z=Y(n,y);v(I,h,Gt),v(z,h,Ot);const L=_.intersectsBox(Gt),N=_.intersectsBox(Ot);b=L&&tt(B,I,s,e,i,a,o,r,c+1,_,!l)||N&&tt(B,z,s,e,i,a,o,r,c+1,_,!l),mt.releasePrimitive(_)}else if(E)if(x)b=tt(n,P,e,s,i,o,a,c,r+1,u,l);else{const _=mt.getPrimitive();_.copy(Qe).applyMatrix4(e);const I=Z(n),z=Y(n,y);v(I,h,Gt),v(z,h,Ot);const L=_.intersectsBox(Gt),N=_.intersectsBox(Ot);b=L&&tt(P,I,s,e,i,a,o,r,c+1,_,!l)||N&&tt(P,z,s,e,i,a,o,r,c+1,_,!l),mt.releasePrimitive(_)}}return b}const be=new $,ns=new st,dr={strategy:Ps,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Cn{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,o=t._indirectBuffer,a=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(r=>r.slice()),index:a.array.slice(),indirectBuffer:o?o.slice():null}:c={roots:i,index:a.array,indirectBuffer:o},c}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:o,indirectBuffer:a}=t,c=new Cn(e,{...s,[Xe]:!0});if(c._roots=o,c._indirectBuffer=a||null,s.setIndex){const r=e.getIndex();if(r===null){const u=new Ue(t.index,1,!1);e.setIndex(u)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...dr,[Xe]:!1},e),e.useSharedArrayBuffer&&!fr())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Xe]||(Ei(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new st)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?er:Hi)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),o=new Uint16Array(s);a(0);function a(c,r=0){const u=c*2,l=o[u+15]===ve;if(l){const p=i[c+6],f=o[u+14];t(r,l,new Float32Array(s,c*4,6),p,f)}else{const p=c+se/4,f=i[c+6],h=i[c+7];t(r,l,new Float32Array(s,c*4,6),h)||(a(p,r+1),a(f,r+1))}}}raycast(t,e=Dn){const s=this._roots,i=this.geometry,o=[],a=e.isMaterial,c=Array.isArray(e),r=i.groups,u=a?e.side:e,l=this.indirect?nr:qi;for(let p=0,f=s.length;p<f;p++){const h=c?e[r[p].materialIndex].side:u,y=o.length;if(l(this,p,h,t,o),c){const T=r[p].materialIndex;for(let w=y,d=o.length;w<d;w++)o[w].face.materialIndex=T}}return o}raycastFirst(t,e=Dn){const s=this._roots,i=this.geometry,o=e.isMaterial,a=Array.isArray(e);let c=null;const r=i.groups,u=o?e.side:e,l=this.indirect?ir:ji;for(let p=0,f=s.length;p<f;p++){const h=a?e[r[p].materialIndex].side:u,y=l(this,p,h,t);y!=null&&(c==null||y.distance<c.distance)&&(c=y,a&&(y.face.materialIndex=r[p].materialIndex))}return c}intersectsGeometry(t,e){let s=!1;const i=this._roots,o=this.indirect?rr:Zi;for(let a=0,c=i.length;a<c&&(s=o(this,a,t,e),!s);a++);return s}shapecast(t){const e=K.getPrimitive(),s=this.indirect?Xi:$i;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const p=a;a=(f,h,y,T,w)=>p(f,h,y,T,w)?!0:s(f,h,this,c,y,T,e)}else a||(c?a=(p,f,h,y)=>s(p,f,this,c,h,y,e):a=(p,f,h)=>h);let r=!1,u=0;const l=this._roots;for(let p=0,f=l.length;p<f;p++){const h=l[p];if(r=Ui(this,p,o,a,i,u),r)break;u+=h.byteLength}return K.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const a=K.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,u=this.indirect?y=>{const T=this.resolveTriangleIndex(y);V(a,T*3,c,r)}:y=>{V(a,y*3,c,r)},l=K.getPrimitive(),p=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?y=>{const T=t.resolveTriangleIndex(y);V(l,T*3,p,f)}:y=>{V(l,y*3,p,f)};if(o){const y=(T,w,d,m,g,A,x,S)=>{for(let b=d,B=d+m;b<B;b++){h(b),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let P=T,M=T+w;P<M;P++)if(u(P),a.needsUpdate=!0,o(a,l,P,b,g,A,x,S))return!0}return!1};if(i){const T=i;i=function(w,d,m,g,A,x,S,b){return T(w,d,m,g,A,x,S,b)?!0:y(w,d,m,g,A,x,S,b)}}else i=y}return pr(this,t,e,i)}intersectsBox(t,e){return be.set(t.min,t.max,e),be.needsUpdate=!0,this.shapecast({intersectsBounds:s=>be.intersectsBox(s),intersectsTriangle:s=>be.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},o=0,a=1/0){return(this.indirect?ur:tr)(this,t,e,s,i,o,a)}closestPointToPoint(t,e={},s=0,i=1/0){return vi(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{v(0,new Float32Array(s),ns),t.union(ns)}),t}}const zs=1e-6,hr=zs*.5,Ls=Math.pow(10,-Math.log10(zs)),yr=hr*Ls;function ot(n){return~~(n*Ls+yr)}function gr(n){return`${ot(n.x)},${ot(n.y)}`}function ss(n){return`${ot(n.x)},${ot(n.y)},${ot(n.z)}`}function mr(n){return`${ot(n.x)},${ot(n.y)},${ot(n.z)},${ot(n.w)}`}function wr(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}function Ns(){return typeof SharedArrayBuffer<"u"}function xr(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,s=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(s).set(i,0),new t(s)}function Ar(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function br(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ar(e,s);n.setIndex(new Ue(i,1));for(let o=0;o<e;o++)i[o]=o}}function Tr(n){return n.index?n.index.count:n.attributes.position.count}function zn(n){return Tr(n)/3}const Sr=1e-8,Br=new C;function Pr(n){return~~(n/3)}function _r(n){return n%3}function is(n,t){return n.start-t.start}function rs(n,t){return Br.subVectors(t,n.origin).dot(n.direction)}function Mr(n,t,e,s=Sr){n.sort(is),t.sort(is);for(let c=0;c<n.length;c++){const r=n[c];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)o(l.end,r.end)||n.splice(c+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)o(r.end,l.end)||t.splice(u+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const p=r.end;r.end=l.start,l.start=p}else if(r.start>=l.start&&r.end>=l.end){const p=l.end;l.end=r.start,r.start=p}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),a(l)&&(t.splice(u,1),u--),a(r)){n.splice(c,1),c--;break}}}i(n),i(t);function i(c){for(let r=0;r<c.length;r++)a(c[r])&&(c.splice(r,1),r--)}function o(c,r){return Math.abs(r-c)<s}function a(c){return Math.abs(c.end-c.start)<s}}const os=1e-5,cs=1e-4;class Ir{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,o=null;for(let r=0,u=e.length;r<u;r++){const l=e[r];if(a(l,t)&&a(l,s))continue;const p=c(l,t),f=c(l,s),h=Math.min(p,f);h<i&&(i=h,o=l)}return o;function a(r,u){const l=r.origin.distanceTo(u.origin)>os;return r.direction.angleTo(u.direction)>cs||l}function c(r,u){const l=r.origin.distanceTo(u.origin),p=r.direction.angleTo(u.direction);return l/os+p/cs}}}const en=new C,nn=new C,Te=new Ss;function Er(n,t,e){const s=n.attributes,i=n.index,o=s.position,a=new Map,c=new Map,r=Array.from(t),u=new Ir;for(let l=0,p=r.length;l<p;l++){const f=r[l],h=Pr(f),y=_r(f);let T=3*h+y,w=3*h+(y+1)%3;i&&(T=i.getX(T),w=i.getX(w)),en.fromBufferAttribute(o,T),nn.fromBufferAttribute(o,w),wr(en,nn,Te);let d,m=u.findClosestRay(Te);m===null&&(m=Te.clone(),u.addRay(m)),c.has(m)||c.set(m,{forward:[],reverse:[],ray:m}),d=c.get(m);let g=rs(m,en),A=rs(m,nn);g>A&&([g,A]=[A,g]),Te.direction.dot(m.direction)<0?d.reverse.push({start:g,end:A,index:f}):d.forward.push({start:g,end:A,index:f})}return c.forEach(({forward:l,reverse:p},f)=>{Mr(l,p,a,e),l.length===0&&p.length===0&&c.delete(f)}),{disjointConnectivityMap:a,fragmentMap:c}}const Cr=new Et,sn=new C,zr=new Ct,rn=["","",""];class Lr{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>~~(o/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>o%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:o}=this,a=e?g:m,c=new Map,{attributes:r}=t,u=e?Object.keys(r):null,l=t.index,p=r.position;let f=zn(t);const h=f;let y=0;s&&(y=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let T=this.data;(!T||T.length<3*h)&&(T=new Int32Array(3*h)),T.fill(-1);let w=0,d=new Set;for(let A=y,x=f*3+y;A<x;A+=3){const S=A;for(let b=0;b<3;b++){let B=S+b;l&&(B=l.getX(B)),rn[b]=a(B)}for(let b=0;b<3;b++){const B=(b+1)%3,P=rn[b],M=rn[B],E=`${M}_${P}`;if(c.has(E)){const _=S+b,I=c.get(E);T[_]=I,T[I]=_,c.delete(E),w+=2,d.delete(I)}else{const _=`${P}_${M}`,I=S+b;c.set(_,I),d.add(I)}}}if(i){const{fragmentMap:A,disjointConnectivityMap:x}=Er(t,d,o);d.clear(),A.forEach(({forward:S,reverse:b})=>{S.forEach(({index:B})=>d.add(B)),b.forEach(({index:B})=>d.add(B))}),this.unmatchedDisjointEdges=A,this.disjointConnections=x,w=f*3-d.size}this.matchedEdges=w,this.unmatchedEdges=d.size,this.data=T;function m(A){return sn.fromBufferAttribute(p,A),ss(sn)}function g(A){let x="";for(let S=0,b=u.length;S<b;S++){const B=r[u[S]];let P;switch(B.itemSize){case 1:P=ot(B.getX(A));break;case 2:P=gr(Cr.fromBufferAttribute(B,A));break;case 3:P=ss(sn.fromBufferAttribute(B,A));break;case 4:P=mr(zr.fromBufferAttribute(B,A));break}x!==""&&(x+="|"),x+=P}return x}}}class Ne extends qt{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new ct,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let o=0;o<16;o++)if(s[o]!==i[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=Ns();if(s)for(const i in e){const o=e[i];if(o.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");o.array=xr(o.array)}if(t.boundsTree||(br(t,{useSharedArrayBuffer:s}),t.boundsTree=new Cn(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new Lr(t)),!t.groupIndices){const i=zn(t),o=new Uint16Array(i),a=t.groups;for(let c=0,r=a.length;c<r;c++){const{start:u,count:l}=a[c];for(let p=u/3,f=(u+l)/3;p<f;p++)o[p]=c}t.groupIndices=o}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Nr=1e-14,on=new C,as=new C,ls=new C;function wt(n,t=Nr){on.subVectors(n.b,n.a),as.subVectors(n.c,n.a),ls.subVectors(n.b,n.c);const e=on.angleTo(as),s=on.angleTo(ls),i=Math.PI-e-s;return Math.abs(e)<t||Math.abs(s)<t||Math.abs(i)<t||n.a.distanceToSquared(n.b)<t||n.a.distanceToSquared(n.c)<t||n.b.distanceToSquared(n.c)<t}const cn=1e-10,ee=1e-10,Rr=1e-10,at=new J,F=new J,lt=new C,an=new C,us=new C,Se=new Bn,ln=new Q;class Ur{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new O),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class vr{constructor(){this.trianglePool=new Ur,this.triangles=[],this.normal=new C,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:s,normal:i}=this;if(Array.isArray(t))for(let o=0,a=t.length;o<a;o++){const c=t[o];if(o===0)c.getNormal(i);else if(Math.abs(1-c.getNormal(lt).dot(i))>cn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const r=s.getTriangle();r.copy(c),e.push(r)}else{t.getNormal(i);const o=s.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:s}=this;if(t.getNormal(an).normalize(),Math.abs(1-Math.abs(an.dot(e)))<Rr){this.coplanarTriangleUsed=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];c.coplanarCount=0}const i=[t.a,t.b,t.c];for(let o=0;o<3;o++){const a=(o+1)%3,c=i[o],r=i[a];lt.subVectors(r,c).normalize(),us.crossVectors(an,lt),Se.setFromNormalAndCoplanarPoint(us,c),this.splitByPlane(Se,t)}}else t.getPlane(Se),this.splitByPlane(Se,t)}splitByPlane(t,e){const{triangles:s,trianglePool:i}=this;ln.copy(e),ln.needsUpdate=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];if(!ln.intersectsTriangle(c,at,!0))continue;const{a:r,b:u,c:l}=c;let p=0,f=-1,h=!1,y=[],T=[];const w=[r,u,l];for(let d=0;d<3;d++){const m=(d+1)%3;at.start.copy(w[d]),at.end.copy(w[m]);const g=t.distanceToPoint(at.start),A=t.distanceToPoint(at.end);if(Math.abs(g)<ee&&Math.abs(A)<ee){h=!0;break}if(g>0?y.push(d):T.push(d),Math.abs(g)<ee)continue;let x=!!t.intersectLine(at,lt);!x&&Math.abs(A)<ee&&(lt.copy(at.end),x=!0),x&&!(lt.distanceTo(at.start)<cn)&&(lt.distanceTo(at.end)<cn&&(f=d),p===0?F.start.copy(lt):F.end.copy(lt),p++)}if(!h&&p===2&&F.distance()>ee)if(f!==-1){f=(f+1)%3;let d=0;d===f&&(d=(d+1)%3);let m=d+1;m===f&&(m=(m+1)%3);const g=i.getTriangle();g.a.copy(w[m]),g.b.copy(F.end),g.c.copy(F.start),wt(g)||s.push(g),c.a.copy(w[d]),c.b.copy(F.start),c.c.copy(F.end),wt(c)&&(s.splice(o,1),o--,a--)}else{const d=y.length>=2?T[0]:y[0];if(d===0){let S=F.start;F.start=F.end,F.end=S}const m=(d+1)%3,g=(d+2)%3,A=i.getTriangle(),x=i.getTriangle();w[m].distanceToSquared(F.start)<w[g].distanceToSquared(F.end)?(A.a.copy(w[m]),A.b.copy(F.start),A.c.copy(F.end),x.a.copy(w[m]),x.b.copy(w[g]),x.c.copy(F.start)):(A.a.copy(w[g]),A.b.copy(F.start),A.c.copy(F.end),x.a.copy(w[m]),x.b.copy(w[g]),x.c.copy(F.end)),c.a.copy(w[d]),c.b.copy(F.end),c.c.copy(F.start),wt(A)||s.push(A),wt(x)||s.push(x),wt(c)&&(s.splice(o,1),o--,a--)}else p===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function Fr(n){return n=~~n,n+4-n%4}class fs{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,s=Ns()?SharedArrayBuffer:ArrayBuffer,i=new e(new s(Fr(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:s}=this;s+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,o=t.length;i<o;i++)e[s+i]=t[i];this.length+=t.length}clear(){this.length=0}}class Vr{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:s}=this;let i=0;for(let o=0;o<e;o++){const a=s[o];i+=a[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const s=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const o in s){const a=s[o],c=new fs(a.type);c.itemSize=a.itemSize,c.normalized=a.normalized,i[o]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:s}=this;if(!s[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,s,i){const{groupAttributes:o}=this,c=o[0][t];if(c){if(c.type!==e)for(let r=0,u=o.length;r<u;r++){const l=o[r][t];l.setType(e),l.itemSize=s,l.normalized=i}}else for(let r=0,u=o.length;r<u;r++){const l=new fs(e);l.itemSize=s,l.normalized=i,o[r][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const s in e)e[s].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class ps{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:s,ids:i}=this;s[t]||(s[t]=[],i.push(t)),s[t].push(e)}}const Dr=0,Rs=1,kr=2,$r=3,Hr=4,Us=5,vs=6,W=new Ss,ds=new ct,k=new O,ut=new C,hs=new Ct,ys=new Ct,gs=new Ct,un=new Ct,Be=new Ct,Pe=new Ct,ms=new J,fn=new C,pn=1e-8,Gr=1e-15,_t=-1,Mt=1,Ee=-2,Ce=2,re=0,Bt=1,Ln=2,Or=1e-14;let ze=null;function ws(n){ze=n}function Fs(n,t){n.getMidpoint(W.origin),n.getNormal(W.direction);const e=t.raycastFirst(W,Pn);return!!(e&&W.direction.dot(e.face.normal)>0)?_t:Mt}function Xr(n,t){function e(){return Math.random()-.5}n.getNormal(fn),W.direction.copy(fn),n.getMidpoint(W.origin);const s=3;let i=0,o=1/0;for(let a=0;a<s;a++){W.direction.x+=e()*pn,W.direction.y+=e()*pn,W.direction.z+=e()*pn,W.direction.multiplyScalar(-1);const c=t.raycastFirst(W,Pn);if(!!(c&&W.direction.dot(c.face.normal)>0)&&i++,c!==null&&(o=Math.min(o,c.distance)),o<=Gr)return c.face.normal.dot(fn)>0?Ce:Ee;if(i/s>.5||(a-i+1)/s>.5)break}return i/s>.5?_t:Mt}function qr(n,t){const e=new ps,s=new ps;return ds.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,ds,{intersectsTriangles(i,o,a,c){if(!wt(i)&&!wt(o)){let r=i.intersectsTriangle(o,ms,!0);if(!r){const u=i.plane,l=o.plane,p=u.normal,f=l.normal;p.dot(f)===1&&Math.abs(u.constant-l.constant)<Or&&(r=!0)}if(r){let u=n.geometry.boundsTree.resolveTriangleIndex(a),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(u,l),s.add(l,u),ze&&(ze.addEdge(ms),ze.addIntersectingTriangles(a,i,c,o))}}return!1}}),{aIntersections:e,bIntersections:s}}function Wr(n,t,e,s,i,o,a=!1){const c=e.attributes,r=e.index,u=n*3,l=r.getX(u+0),p=r.getX(u+1),f=r.getX(u+2);for(const h in o){const y=c[h],T=o[h];if(!(h in c))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const w=y.itemSize;h==="position"?(k.a.fromBufferAttribute(y,l).applyMatrix4(s),k.b.fromBufferAttribute(y,p).applyMatrix4(s),k.c.fromBufferAttribute(y,f).applyMatrix4(s),dn(k.a,k.b,k.c,t,3,T,a)):h==="normal"?(k.a.fromBufferAttribute(y,l).applyNormalMatrix(i),k.b.fromBufferAttribute(y,p).applyNormalMatrix(i),k.c.fromBufferAttribute(y,f).applyNormalMatrix(i),a&&(k.a.multiplyScalar(-1),k.b.multiplyScalar(-1),k.c.multiplyScalar(-1)),dn(k.a,k.b,k.c,t,3,T,a,!0)):(hs.fromBufferAttribute(y,l),ys.fromBufferAttribute(y,p),gs.fromBufferAttribute(y,f),dn(hs,ys,gs,t,w,T,a))}}function jr(n,t,e,s,i,o,a,c=!1){hn(n,s,i,o,a,c),hn(c?e:t,s,i,o,a,c),hn(c?t:e,s,i,o,a,c)}function Vs(n,t,e=!1){switch(n){case Dr:if(t===Mt||t===Ce&&!e)return Bt;break;case Rs:if(e){if(t===_t)return re}else if(t===Mt||t===Ee)return Bt;break;case kr:if(e){if(t===Mt||t===Ee)return Bt}else if(t===_t)return re;break;case Hr:if(t===_t)return re;if(t===Mt)return Bt;break;case $r:if(t===_t||t===Ce&&!e)return Bt;break;case Us:if(!e&&(t===Mt||t===Ee))return Bt;break;case vs:if(!e&&(t===_t||t===Ce))return Bt;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return Ln}function dn(n,t,e,s,i,o,a=!1,c=!1){const r=u=>{o.push(u.x),i>1&&o.push(u.y),i>2&&o.push(u.z),i>3&&o.push(u.w)};un.set(0,0,0,0).addScaledVector(n,s.a.x).addScaledVector(t,s.a.y).addScaledVector(e,s.a.z),Be.set(0,0,0,0).addScaledVector(n,s.b.x).addScaledVector(t,s.b.y).addScaledVector(e,s.b.z),Pe.set(0,0,0,0).addScaledVector(n,s.c.x).addScaledVector(t,s.c.y).addScaledVector(e,s.c.z),c&&(un.normalize(),Be.normalize(),Pe.normalize()),r(un),a?(r(Pe),r(Be)):(r(Be),r(Pe))}function hn(n,t,e,s,i,o=!1){for(const a in i){const c=t[a],r=i[a];if(!(a in t))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const u=c.itemSize;a==="position"?(ut.fromBufferAttribute(c,n).applyMatrix4(e),r.push(ut.x,ut.y,ut.z)):a==="normal"?(ut.fromBufferAttribute(c,n).applyNormalMatrix(s),o&&ut.multiplyScalar(-1),r.push(ut.x,ut.y,ut.z)):(r.push(c.getX(n)),u>1&&r.push(c.getY(n)),u>2&&r.push(c.getZ(n)),u>3&&r.push(c.getW(n)))}}class Zr{constructor(t){this.triangle=new O().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new O().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const s in e)t.push(e[s]);return t}}class xs{constructor(){this.data={}}addTriangleIntersection(t,e,s,i){const{data:o}=this;o[t]||(o[t]=new Zr(e)),o[t].addTriangle(s,i)}getTrianglesAsArray(t=null){const{data:e}=this,s=[];if(t!==null)t in e&&s.push(e[t].triangle);else for(const i in e)s.push(e[i].triangle);return s}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(s=>parseInt(s)):[]}getIntersectionsAsArray(t=null,e=null){const{data:s}=this,i=new Set,o=[],a=c=>{if(s[c])if(e!==null)s[c].intersects[e]&&o.push(s[c].intersects[e]);else{const r=s[c].intersects;for(const u in r)i.has(u)||(i.add(u),o.push(r[u]))}};if(t!==null)a(t);else for(const c in s)a(c);return o}reset(){this.data={}}}class Yr{constructor(){this.enabled=!1,this.triangleIntersectsA=new xs,this.triangleIntersectsB=new xs,this.intersectionEdges=[]}addIntersectingTriangles(t,e,s,i){const{triangleIntersectsA:o,triangleIntersectsB:a}=this;o.addTriangleIntersection(t,e,s,i),a.addTriangleIntersection(s,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),ws(this))}complete(){this.enabled&&ws(null)}}const At=new ct,Re=new ei,Pt=new O,_e=new O,gt=new O,Me=new O,et=[],It=[];function Kr(n){for(const t of n)return t}function Jr(n,t,e,s,i,o={}){const{useGroups:a=!0}=o,{aIntersections:c,bIntersections:r}=qr(n,t),u=[];let l=null,p;return p=a?0:-1,As(n,t,c,e,!1,s,i,p),bs(n,t,c,e,!1,i,p),e.findIndex(h=>h!==vs&&h!==Us)!==-1&&(p=a?n.geometry.groups.length||1:-1,As(t,n,r,e,!0,s,i,p),bs(t,n,r,e,!0,i,p)),et.length=0,It.length=0,{groups:u,materials:l}}function As(n,t,e,s,i,o,a,c=0){const r=n.matrixWorld.determinant()<0;At.copy(t.matrixWorld).invert().multiply(n.matrixWorld),Re.getNormalMatrix(n.matrixWorld).multiplyScalar(r?-1:1);const u=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,y=t.geometry.attributes.position,T=e.ids,w=e.intersectionSet;for(let d=0,m=T.length;d<m;d++){const g=T[d],A=c===-1?0:u[g]+c,x=3*g,S=l.getX(x+0),b=l.getX(x+1),B=l.getX(x+2);Pt.a.fromBufferAttribute(p,S).applyMatrix4(At),Pt.b.fromBufferAttribute(p,b).applyMatrix4(At),Pt.c.fromBufferAttribute(p,B).applyMatrix4(At),o.reset(),o.initialize(Pt);const P=w[g];for(let E=0,_=P.length;E<_;E++){const I=3*P[E],z=h.getX(I+0),L=h.getX(I+1),N=h.getX(I+2);_e.a.fromBufferAttribute(y,z),_e.b.fromBufferAttribute(y,L),_e.c.fromBufferAttribute(y,N),o.splitByTriangle(_e)}const M=o.triangles;for(let E=0,_=M.length;E<_;E++){const I=M[E],z=o.coplanarTriangleUsed?Xr(I,f):Fs(I,f);et.length=0,It.length=0;for(let L=0,N=s.length;L<N;L++){const D=Vs(s[L],z,i);D!==Ln&&(It.push(D),et.push(a[L].getGroupAttrSet(A)))}if(et.length!==0){Pt.getBarycoord(I.a,Me.a),Pt.getBarycoord(I.b,Me.b),Pt.getBarycoord(I.c,Me.c);for(let L=0,N=et.length;L<N;L++){const D=et[L],St=It[L]===re;Wr(g,Me,n.geometry,n.matrixWorld,Re,D,r!==St)}}}}return T.length}function bs(n,t,e,s,i,o,a=0){const c=n.matrixWorld.determinant()<0;At.copy(t.matrixWorld).invert().multiply(n.matrixWorld),Re.getNormalMatrix(n.matrixWorld).multiplyScalar(c?-1:1);const r=t.geometry.boundsTree,u=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes,f=p.position,h=[],y=n.geometry.halfEdges,T=new Set,w=zn(n.geometry);for(let d=0,m=w;d<m;d++)d in e.intersectionSet||T.add(d);for(;T.size>0;){const d=Kr(T);T.delete(d),h.push(d);const m=3*d,g=l.getX(m+0),A=l.getX(m+1),x=l.getX(m+2);gt.a.fromBufferAttribute(f,g).applyMatrix4(At),gt.b.fromBufferAttribute(f,A).applyMatrix4(At),gt.c.fromBufferAttribute(f,x).applyMatrix4(At);const S=Fs(gt,r);It.length=0,et.length=0;for(let b=0,B=s.length;b<B;b++){const P=Vs(s[b],S,i);P!==Ln&&(It.push(P),et.push(o[b]))}for(;h.length>0;){const b=h.pop();for(let B=0;B<3;B++){const P=y.getSiblingTriangleIndex(b,B);P!==-1&&T.has(P)&&(h.push(P),T.delete(P))}if(et.length!==0){const B=3*b,P=l.getX(B+0),M=l.getX(B+1),E=l.getX(B+2),_=a===-1?0:u[b]+a;if(gt.a.fromBufferAttribute(f,P),gt.b.fromBufferAttribute(f,M),gt.c.fromBufferAttribute(f,E),!wt(gt))for(let I=0,z=et.length;I<z;I++){const L=It[I],N=et[I].getGroupAttrSet(_),D=L===re;jr(P,M,E,p,n.matrixWorld,Re,N,D!==c)}}}}}function Qr(n){for(let t=0;t<n.length-1;t++){const e=n[t],s=n[t+1];if(e.materialIndex===s.materialIndex){const i=e.start,o=s.start+s.count;s.start=i,s.count=o-i,n.splice(t,1),t--}}}function to(n,t,e,s){e.clear();const i=n.attributes;for(let o=0,a=s.length;o<a;o++){const c=s[o],r=i[c];e.initializeArray(c,r.array.constructor,r.itemSize,r.normalized)}for(const o in e.attributes)s.includes(o)||e.delete(o);for(const o in t.attributes)s.includes(o)||(t.deleteAttribute(o),t.dispose())}function eo(n,t,e){let s=!1,i=-1;const o=n.attributes,a=t.groupAttributes[0];for(const r in a){const u=t.getTotalLength(r),l=t.getType(r),p=t.getItemSize(r),f=t.getNormalized(r);let h=o[r];(!h||h.array.length<u)&&(h=new Ue(new l(u),p,f),n.setAttribute(r,h),s=!0);let y=0;for(let T=0,w=Math.min(e.length,t.groupCount);T<w;T++){const d=e[T].index,{array:m,type:g,length:A}=t.groupAttributes[d][r],x=new g(m.buffer,0,A);h.array.set(x,y),y+=x.length}h.needsUpdate=!0,i=u/h.itemSize}if(n.index){const r=n.index.array;if(r.length<i)n.index=null,s=!0;else for(let u=0,l=r.length;u<l;u++)r[u]=u}let c=0;n.clearGroups();for(let r=0,u=Math.min(e.length,t.groupCount);r<u;r++){const{index:l,materialIndex:p}=e[r],f=t.getCount(l);f!==0&&(n.addGroup(c,f,p),c+=f)}n.setDrawRange(0,i),n.boundsTree=null,s&&n.dispose()}function Ts(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(s=>{e[s.materialIndex]=t})),e}class no{constructor(){this.triangleSplitter=new vr,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Yr}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,s,i=new Ne){let o=!0;if(Array.isArray(s)||(s=[s]),Array.isArray(i)||(i=[i],o=!1),i.length!==s.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:a,attributeData:c,attributes:r,useGroups:u,consolidateGroups:l,debug:p}=this;for(;c.length<i.length;)c.push(new Vr);i.forEach((d,m)=>{to(t.geometry,d.geometry,c[m],r)}),p.init(),Jr(t,e,s,a,c,{useGroups:u}),p.complete();const f=this.getGroupRanges(t.geometry),h=Ts(f,t.material),y=this.getGroupRanges(e.geometry),T=Ts(y,e.material);y.forEach(d=>d.materialIndex+=h.length);let w=[...f,...y].map((d,m)=>({...d,index:m}));if(u){const d=[...h,...T];l&&(w=w.map(g=>{const A=d[g.materialIndex];return g.materialIndex=d.indexOf(A),g}).sort((g,A)=>g.materialIndex-A.materialIndex));const m=[];for(let g=0,A=d.length;g<A;g++){let x=!1;for(let S=0,b=w.length;S<b;S++){const B=w[S];B.materialIndex===g&&(x=!0,B.materialIndex=m.length)}x&&m.push(d[g])}i.forEach(g=>{g.material=m})}else w=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(d=>{d.material=h[0]});return i.forEach((d,m)=>{const g=d.geometry;eo(g,c[m],w),l&&Qr(g.groups)}),o?i:i[0]}evaluateHierarchy(t,e=new Ne){t.updateMatrixWorld(!0);const s=(o,a)=>{const c=o.children;for(let r=0,u=c.length;r<u;r++){const l=c[r];l.isOperationGroup?s(l,a):a(l)}},i=o=>{const a=o.children;let c=!1;for(let u=0,l=a.length;u<l;u++){const p=a[u];c=i(p)||c}const r=o.isDirty();if(r&&o.markUpdated(),c&&!o.isOperationGroup){let u;return s(o,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(o,l,l.operation)}),o._cachedGeometry=u.geometry,o._cachedMaterials=u.material,!0}else return c||r};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const it=40,rt=30,dt=26.8,R=.8,Lt=.2,Nt=8,Ds=18,Nn=!1,Rn=new _n({roughness:1,metalness:0,wireframe:Nn,transparent:!0,opacity:0}),so=new zt(it,R,rt,Nt,Lt),io=new _n({roughness:1,metalness:0,wireframe:Nn}),Ve=new qt(so,io);Ve.position.set(it/2,-R/2,rt/2);Ve.receiveShadow=!0;Ve.castShadow=!0;const Un=new _n({roughness:1,metalness:0,wireframe:Nn}),ro=new zt(R,dt,rt,Nt,Lt),De=new qt(ro,Un);De.position.set(-R/2,dt/2-R,rt/2);De.receiveShadow=!0;De.castShadow=!0;const oo=new zt(it+R,dt,R,Nt,Lt),vn=new Ne(oo,Un);vn.position.set(it/2-R/2,dt/2-R,-R/2);vn.updateMatrixWorld();const co=new zt(20,18,R,Nt,Lt),Fn=new Ne(co,Un);Fn.position.set(20,12,-R/2);Fn.updateMatrixWorld();const ao=new no,Vn=ao.evaluate(vn,Fn,Rs);Vn.receiveShadow=!0;Vn.castShadow=!0;const lo=new zt(it+R+R,dt,R,Nt,Lt),ke=new qt(lo,Rn);ke.position.set(it/2,dt/2-R,rt+R/2);ke.receiveShadow=!0;ke.castShadow=!0;const uo=new zt(R,dt,rt+R,Nt,Lt),$e=new qt(uo,Rn);$e.position.set(it+R/2,dt/2-R,rt/2-R/2);$e.receiveShadow=!0;$e.castShadow=!0;const fo=new zt(it+R+R,R,rt+R+R,Nt,Lt),He=new qt(fo,Rn);He.position.set(it/2,dt-R/2,rt/2);He.receiveShadow=!0;He.castShadow=!0;const ht=new ni;ht.position.set(-it/2,-Ds,-rt/2);ht.add(Ve);ht.add(De);ht.add(Vn);ht.add(ke);ht.add($e);ht.add(He);Tt.add(ht);const ks=new si(ht);Tt.add(ks);const po=new ii,$s=()=>{kn.begin(),nt.clear(),ks.update(),Mn.update();const n=po.getDelta();Ge.animating&&Ge.update(n),nt.render(Tt,ce),Ge.render(nt),kn.end(),requestAnimationFrame($s)},ho=new ri("#ffffff",.3);Tt.add(ho);const G=new oi("#ffffff",1);G.position.set(20,20,-30);G.castShadow=!0;G.shadow.mapSize.width=1024;G.shadow.mapSize.height=1024;G.shadow.camera.near=1;G.shadow.camera.far=100;G.shadow.camera.top=50;G.shadow.camera.right=50;G.shadow.camera.bottom=-50;G.shadow.camera.left=-50;G.shadow.normalBias=.12;Tt.add(G);const Hs=new ci(G,10);Tt.add(Hs);Hs.visible=!1;const Gs=new ai(G.shadow.camera);Tt.add(Gs);Gs.visible=!1;const Os=new li(42);Os.position.set(-it/2,-Ds,-rt/2);Tt.add(Os);$s();ui(oe,ce,nt);fi.add(Mn,"autoRotate");

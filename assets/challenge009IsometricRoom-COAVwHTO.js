import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as I,aP as ts,n as Mo,j as _o,m as Bo,a4 as fe,_ as Bi,aQ as ye,X as ms,U as Pi,Q as xn,aR as Po,a0 as Li,a3 as ws,M as k,S as Lo,aS as vo,q as Io,aT as Eo,aU as Re,p as Co,aV as zo,o as es,aW as ns,G as Ro,P as Vo,W as No,aX as Fo,O as Uo,c as ko,J as ss,V as ue,aY as ti,aZ as gt,a_ as nt,ar as jo,v as It,aq as Bt,a$ as Do,Y as ei,ak as vi,b0 as xr,b1 as de,b2 as $o,s as te,z as Ve,t as tn,R as z,a as Mt,b3 as Go,b as Ii,d as Ho,A as Oo,l as Wo}from"./index-HDcUnNI7.js";const $e=new I;function ct(s,t,e,n,i,r){const c=2*Math.PI*i/4,a=Math.max(r-2*i,0),o=Math.PI/4;$e.copy(t),$e[n]=0,$e.normalize();const u=.5*c/(c+a),l=1-$e.angleTo(s)/o;return Math.sign($e[e])===1?l*u:a/(c+a)+u+u*(1-l)}class R extends ts{constructor(t=1,e=1,n=1,i=2,r=.1){if(i=i*2+1,r=Math.min(t/2,e/2,n/2,r),super(1,1,1,i,i,i),i===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const a=new I,o=new I,u=new I(t,e,n).divideScalar(2).subScalar(r),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,g=new I,A=.5/i;for(let w=0,p=0;w<l.length;w+=3,p+=2)switch(a.fromArray(l,w),o.copy(a),o.x-=Math.sign(o.x)*A,o.y-=Math.sign(o.y)*A,o.z-=Math.sign(o.z)*A,o.normalize(),l[w+0]=u.x*Math.sign(a.x)+o.x*r,l[w+1]=u.y*Math.sign(a.y)+o.y*r,l[w+2]=u.z*Math.sign(a.z)+o.z*r,d[w+0]=o.x,d[w+1]=o.y,d[w+2]=o.z,Math.floor(w/h)){case 0:g.set(1,0,0),f[p+0]=ct(g,o,"z","y",r,n),f[p+1]=1-ct(g,o,"y","z",r,e);break;case 1:g.set(-1,0,0),f[p+0]=1-ct(g,o,"z","y",r,n),f[p+1]=1-ct(g,o,"y","z",r,e);break;case 2:g.set(0,1,0),f[p+0]=1-ct(g,o,"x","z",r,t),f[p+1]=ct(g,o,"z","x",r,n);break;case 3:g.set(0,-1,0),f[p+0]=1-ct(g,o,"x","z",r,t),f[p+1]=1-ct(g,o,"z","x",r,n);break;case 4:g.set(0,0,1),f[p+0]=1-ct(g,o,"x","y",r,t),f[p+1]=1-ct(g,o,"y","x",r,e);break;case 5:g.set(0,0,-1),f[p+0]=ct(g,o,"x","y",r,t),f[p+1]=1-ct(g,o,"y","x",r,e);break}}}const Xo=/^[og]\s*(.+)?/,qo=/^mtllib /,Zo=/^usemtl /,Ko=/^usemap /,Ei=/\s+/,Ci=new I,ys=new I,zi=new I,Ri=new I,lt=new I,bn=new Mo;function Yo(){const s={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(i,r){const c=this._finalize(!1);c&&(c.inherited||c.groupCount<=0)&&this.materials.splice(c.index,1);const a={index:this.materials.length,name:i||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:c!==void 0?c.smooth:this.smooth,groupStart:c!==void 0?c.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(o){const u={index:typeof o=="number"?o:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return u.clone=this.clone.bind(u),u}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(i){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),i&&this.materials.length>1)for(let c=this.materials.length-1;c>=0;c--)this.materials[c].groupCount<=0&&this.materials.splice(c,1);return i&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},n&&n.name&&typeof n.clone=="function"){const i=n.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseNormalIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseUVIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/2)*2},addVertex:function(t,e,n){const i=this.vertices,r=this.object.geometry.vertices;r.push(i[t+0],i[t+1],i[t+2]),r.push(i[e+0],i[e+1],i[e+2]),r.push(i[n+0],i[n+1],i[n+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,n){const i=this.normals,r=this.object.geometry.normals;r.push(i[t+0],i[t+1],i[t+2]),r.push(i[e+0],i[e+1],i[e+2]),r.push(i[n+0],i[n+1],i[n+2])},addFaceNormal:function(t,e,n){const i=this.vertices,r=this.object.geometry.normals;Ci.fromArray(i,t),ys.fromArray(i,e),zi.fromArray(i,n),lt.subVectors(zi,ys),Ri.subVectors(Ci,ys),lt.cross(Ri),lt.normalize(),r.push(lt.x,lt.y,lt.z),r.push(lt.x,lt.y,lt.z),r.push(lt.x,lt.y,lt.z)},addColor:function(t,e,n){const i=this.colors,r=this.object.geometry.colors;i[t]!==void 0&&r.push(i[t+0],i[t+1],i[t+2]),i[e]!==void 0&&r.push(i[e+0],i[e+1],i[e+2]),i[n]!==void 0&&r.push(i[n+0],i[n+1],i[n+2])},addUV:function(t,e,n){const i=this.uvs,r=this.object.geometry.uvs;r.push(i[t+0],i[t+1]),r.push(i[e+0],i[e+1]),r.push(i[n+0],i[n+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,n,i,r,c,a,o,u){const l=this.vertices.length;let d=this.parseVertexIndex(t,l),f=this.parseVertexIndex(e,l),h=this.parseVertexIndex(n,l);if(this.addVertex(d,f,h),this.addColor(d,f,h),a!==void 0&&a!==""){const g=this.normals.length;d=this.parseNormalIndex(a,g),f=this.parseNormalIndex(o,g),h=this.parseNormalIndex(u,g),this.addNormal(d,f,h)}else this.addFaceNormal(d,f,h);if(i!==void 0&&i!==""){const g=this.uvs.length;d=this.parseUVIndex(i,g),f=this.parseUVIndex(r,g),h=this.parseUVIndex(c,g),this.addUV(d,f,h),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let n=0,i=t.length;n<i;n++){const r=this.parseVertexIndex(t[n],e);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const n=this.vertices.length,i=this.uvs.length;for(let r=0,c=t.length;r<c;r++)this.addVertexLine(this.parseVertexIndex(t[r],n));for(let r=0,c=e.length;r<c;r++)this.addUVLine(this.parseUVIndex(e[r],i))}};return s.startObject("",!1),s}class br extends _o{constructor(t){super(t),this.materials=null}load(t,e,n,i){const r=this,c=new Bo(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(t,function(a){try{e(r.parse(a))}catch(o){i?i(o):console.error(o),r.manager.itemError(t)}},n,i)}setMaterials(t){return this.materials=t,this}parse(t){const e=new Yo;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const n=t.split(`
`);let i=[];for(let a=0,o=n.length;a<o;a++){const u=n[a].trimStart();if(u.length===0)continue;const l=u.charAt(0);if(l!=="#")if(l==="v"){const d=u.split(Ei);switch(d[0]){case"v":e.vertices.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3])),d.length>=7?(bn.setRGB(parseFloat(d[4]),parseFloat(d[5]),parseFloat(d[6])).convertSRGBToLinear(),e.colors.push(bn.r,bn.g,bn.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3]));break;case"vt":e.uvs.push(parseFloat(d[1]),parseFloat(d[2]));break}}else if(l==="f"){const f=u.slice(1).trim().split(Ei),h=[];for(let A=0,w=f.length;A<w;A++){const p=f[A];if(p.length>0){const m=p.split("/");h.push(m)}}const g=h[0];for(let A=1,w=h.length-1;A<w;A++){const p=h[A],m=h[A+1];e.addFace(g[0],p[0],m[0],g[1],p[1],m[1],g[2],p[2],m[2])}}else if(l==="l"){const d=u.substring(1).trim().split(" ");let f=[];const h=[];if(u.indexOf("/")===-1)f=d;else for(let g=0,A=d.length;g<A;g++){const w=d[g].split("/");w[0]!==""&&f.push(w[0]),w[1]!==""&&h.push(w[1])}e.addLineGeometry(f,h)}else if(l==="p"){const f=u.slice(1).trim().split(" ");e.addPointGeometry(f)}else if((i=Xo.exec(u))!==null){const d=(" "+i[0].slice(1).trim()).slice(1);e.startObject(d)}else if(Zo.test(u))e.object.startMaterial(u.substring(7).trim(),e.materialLibraries);else if(qo.test(u))e.materialLibraries.push(u.substring(7).trim());else if(Ko.test(u))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(l==="s"){if(i=u.split(" "),i.length>1){const f=i[1].trim().toLowerCase();e.object.smooth=f!=="0"&&f!=="off"}else e.object.smooth=!0;const d=e.object.currentMaterial();d&&(d.smooth=e.object.smooth)}else{if(u==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+u+'"')}}e.finalize();const r=new fe;if(r.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let a=0,o=e.objects.length;a<o;a++){const u=e.objects[a],l=u.geometry,d=u.materials,f=l.type==="Line",h=l.type==="Points";let g=!1;if(l.vertices.length===0)continue;const A=new Bi;A.setAttribute("position",new ye(l.vertices,3)),l.normals.length>0&&A.setAttribute("normal",new ye(l.normals,3)),l.colors.length>0&&(g=!0,A.setAttribute("color",new ye(l.colors,3))),l.hasUVIndices===!0&&A.setAttribute("uv",new ye(l.uvs,2));const w=[];for(let m=0,y=d.length;m<y;m++){const x=d[m],b=x.name+"_"+x.smooth+"_"+g;let S=e.materials[b];if(this.materials!==null){if(S=this.materials.create(x.name),f&&S&&!(S instanceof ms)){const T=new ms;Pi.prototype.copy.call(T,S),T.color.copy(S.color),S=T}else if(h&&S&&!(S instanceof xn)){const T=new xn({size:10,sizeAttenuation:!1});Pi.prototype.copy.call(T,S),T.color.copy(S.color),T.map=S.map,S=T}}S===void 0&&(f?S=new ms:h?S=new xn({size:1,sizeAttenuation:!1}):S=new Po,S.name=x.name,S.flatShading=!x.smooth,S.vertexColors=g,e.materials[b]=S),w.push(S)}let p;if(w.length>1){for(let m=0,y=d.length;m<y;m++){const x=d[m];A.addGroup(x.groupStart,x.groupCount,m)}f?p=new Li(A,w):h?p=new ws(A,w):p=new k(A,w)}else f?p=new Li(A,w[0]):h?p=new ws(A,w[0]):p=new k(A,w[0]);p.name=u.name,r.add(p)}else if(e.vertices.length>0){const a=new xn({size:1,sizeAttenuation:!1}),o=new Bi;o.setAttribute("position",new ye(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(o.setAttribute("color",new ye(e.colors,3)),a.vertexColors=!0);const u=new ws(o,a);r.add(u)}return r}}const U=new Lo,_t=!1,V={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},ce={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},Ar=new vo("#ffffff",.2);U.add(Ar);const K=new Io("#ffffff",2);K.position.set(20,20,-30);K.castShadow=!0;K.shadow.mapSize.width=1024;K.shadow.mapSize.height=1024;K.shadow.camera.near=1;K.shadow.camera.far=200;K.shadow.camera.top=50;K.shadow.camera.right=50;K.shadow.camera.bottom=-50;K.shadow.camera.left=-50;K.shadow.normalBias=.1;U.add(K);const Tr=new Eo(K,10);U.add(Tr);Tr.visible=!1;const Sr=new Re(K.shadow.camera);U.add(Sr);Sr.visible=!1;const Ct=new Co(16777215,30,40,1);Ct.position.set(V.wallThickness,2,V.wallThickness);Ct.castShadow=!0;Ct.shadow.camera.near=1;Ct.shadow.camera.far=30;Ct.shadow.normalBias=.7;Ct.shadow.radius=5;U.add(Ct);const Mr=new zo(Ct,10);U.add(Mr);Mr.visible=!1;const _r=new Re(Ct.shadow.camera);U.add(_r);_r.visible=!1;const Ut=new es(16777215,30,60,Math.PI*.11,.6,1);Ut.position.set(V.floorXLength/2-3,6,-6);Ut.target.position.set(V.floorXLength/2-3,-V.ny,-6);Ut.castShadow=!0;Ut.shadow.camera.near=1;Ut.shadow.camera.far=30;U.add(Ut);const Br=new ns(Ut,16776960);U.add(Br);Br.visible=!1;const Pr=new Re(Ut.shadow.camera);U.add(Pr);Pr.visible=!1;const kt=new es(16777215,30,60,Math.PI*.11,.6,1);kt.position.set(V.floorXLength/2-3,6,6);kt.target.position.set(V.floorXLength/2-3,-V.ny,6);kt.castShadow=!0;kt.shadow.camera.near=1;kt.shadow.camera.far=30;U.add(kt);const Lr=new ns(kt,16776960);U.add(Lr);Lr.visible=!1;const vr=new Re(kt.shadow.camera);U.add(vr);vr.visible=!1;const jt=new es(16777215,30,60,Math.PI*.19,.6,1.5);jt.position.set(-(V.floorXLength/2-1),6.8,6);jt.target.position.set(-(V.floorXLength/2),-V.ny,6);jt.castShadow=!0;jt.shadow.camera.near=1;jt.shadow.camera.far=30;U.add(jt);const Ir=new ns(jt,16776960);U.add(Ir);Ir.visible=!1;const Er=new Re(jt.shadow.camera);U.add(Er);Er.visible=!1;const Dt=new es(16777215,30,60,Math.PI*.19,.6,1.5);Dt.position.set(-(V.floorXLength/2-1),6.8,-6);Dt.target.position.set(-(V.floorXLength/2),-V.ny,-6);Dt.castShadow=!0;Dt.shadow.camera.near=1;Dt.shadow.camera.far=30;U.add(Dt);const Cr=new ns(Dt,16776960);U.add(Cr);Cr.visible=!1;const zr=new Re(Dt.shadow.camera);U.add(zr);zr.visible=!1;const Rr=[Ut,kt,jt,Dt],Jo=()=>{Rr.forEach(s=>{s.visible=!1})},Qo=()=>{Rr.forEach(s=>{s.visible=!0})},gn=new Ro,ta={spotLight:!0};gn.add(K,"visible").name("directionalLight");gn.add(Ct,"visible").name("pointLight");gn.add(Ar,"visible").name("ambientLight");gn.add(ta,"spotLight").name("spotLight").onChange(s=>{s?Qo():Jo()});const Ie={width:window.innerWidth,height:window.innerHeight},Ee=new Vo(20,Ie.width/Ie.height,25,800);Ie.width<768?Ee.position.set(200,175,200):Ee.position.set(120,100,120);const Vr=document.querySelector("canvas.webgl");if(Vr===null)throw new Error("Cannot find the canvas element");const St=new No({canvas:Vr,antialias:!0});St.setSize(Ie.width,Ie.height);St.setPixelRatio(Math.min(window.devicePixelRatio,2));St.autoClear=!1;St.shadowMap.enabled=!0;St.shadowMap.type=Fo;const Ne=new Uo(Ee,St.domElement);Ne.enableDamping=!0;Ne.minDistance=30;Ne.maxDistance=400;Ne.maxPolarAngle=Math.PI/1.98;const xs=ko(Ee,St.domElement),Nr=0,ea=1,na=2,Vi=2,bs=1.25,Ni=1,Ye=6*4+4+4,is=65535,sa=Math.pow(2,-24),As=Symbol("SKIP_GENERATION");function ia(s){return s.index?s.index.count:s.attributes.position.count}function Fe(s){return ia(s)/3}function ra(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function oa(s,t){if(!s.index){const e=s.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ra(e,n);s.setIndex(new ss(i,1));for(let r=0;r<e;r++)i[r]=r}}function Fr(s){const t=Fe(s),e=s.drawRange,n=e.start/3,i=(e.start+e.count)/3,r=Math.max(0,n),c=Math.min(t,i)-r;return[{offset:Math.floor(r),count:Math.floor(c)}]}function Ur(s){if(!s.groups||!s.groups.length)return Fr(s);const t=[],e=new Set,n=s.drawRange,i=n.start/3,r=(n.start+n.count)/3;for(const a of s.groups){const o=a.start/3,u=(a.start+a.count)/3;e.add(Math.max(i,o)),e.add(Math.min(r,u))}const c=Array.from(e.values()).sort((a,o)=>a-o);for(let a=0;a<c.length-1;a++){const o=c[a],u=c[a+1];t.push({offset:Math.floor(o),count:Math.floor(u-o)})}return t}function aa(s){if(s.groups.length===0)return!1;const t=Fe(s),e=Ur(s).sort((r,c)=>r.offset-c.offset),n=e[e.length-1];n.count=Math.min(t-n.offset,n.count);let i=0;return e.forEach(({count:r})=>i+=r),t!==i}function Ts(s,t,e,n,i){let r=1/0,c=1/0,a=1/0,o=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,g=-1/0,A=-1/0,w=-1/0;for(let p=t*6,m=(t+e)*6;p<m;p+=6){const y=s[p+0],x=s[p+1],b=y-x,S=y+x;b<r&&(r=b),S>o&&(o=S),y<d&&(d=y),y>g&&(g=y);const T=s[p+2],M=s[p+3],_=T-M,P=T+M;_<c&&(c=_),P>u&&(u=P),T<f&&(f=T),T>A&&(A=T);const v=s[p+4],B=s[p+5],L=v-B,E=v+B;L<a&&(a=L),E>l&&(l=E),v<h&&(h=v),v>w&&(w=v)}n[0]=r,n[1]=c,n[2]=a,n[3]=o,n[4]=u,n[5]=l,i[0]=d,i[1]=f,i[2]=h,i[3]=g,i[4]=A,i[5]=w}function ca(s,t=null,e=null,n=null){const i=s.attributes.position,r=s.index?s.index.array:null,c=Fe(s),a=i.normalized;let o;t===null?(o=new Float32Array(c*6*4),e=0,n=c):(o=t,e=e||0,n=n||c);const u=i.array,l=i.offset||0;let d=3;i.isInterleavedBufferAttribute&&(d=i.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+n;h++){const g=h*3,A=h*6;let w=g+0,p=g+1,m=g+2;r&&(w=r[w],p=r[p],m=r[m]),a||(w=w*d+l,p=p*d+l,m=m*d+l);for(let y=0;y<3;y++){let x,b,S;a?(x=i[f[y]](w),b=i[f[y]](p),S=i[f[y]](m)):(x=u[w+y],b=u[p+y],S=u[m+y]);let T=x;b<T&&(T=b),S<T&&(T=S);let M=x;b>M&&(M=b),S>M&&(M=S);const _=(M-T)/2,P=y*2;o[A+P+0]=T+_,o[A+P+1]=_+(Math.abs(T)+_)*sa}}return o}function $(s,t,e){return e.min.x=t[s],e.min.y=t[s+1],e.min.z=t[s+2],e.max.x=t[s+3],e.max.y=t[s+4],e.max.z=t[s+5],e}function Fi(s){let t=-1,e=-1/0;for(let n=0;n<3;n++){const i=s[n+3]-s[n];i>e&&(e=i,t=n)}return t}function Ui(s,t){t.set(s)}function ki(s,t,e){let n,i;for(let r=0;r<3;r++){const c=r+3;n=s[r],i=t[r],e[r]=n<i?n:i,n=s[c],i=t[c],e[c]=n>i?n:i}}function An(s,t,e){for(let n=0;n<3;n++){const i=t[s+2*n],r=t[s+2*n+1],c=i-r,a=i+r;c<e[n]&&(e[n]=c),a>e[n+3]&&(e[n+3]=a)}}function Ge(s){const t=s[3]-s[0],e=s[4]-s[1],n=s[5]-s[2];return 2*(t*e+e*n+n*t)}const Nt=32,la=(s,t)=>s.candidate-t.candidate,Xt=new Array(Nt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Tn=new Float32Array(6);function ua(s,t,e,n,i,r){let c=-1,a=0;if(r===Nr)c=Fi(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(r===ea)c=Fi(s),c!==-1&&(a=fa(e,n,i,c));else if(r===na){const o=Ge(s);let u=bs*i;const l=n*6,d=(n+i)*6;for(let f=0;f<3;f++){const h=t[f],w=(t[f+3]-h)/Nt;if(i<Nt/4){const p=[...Xt];p.length=i;let m=0;for(let x=l;x<d;x+=6,m++){const b=p[m];b.candidate=e[x+2*f],b.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:M}=b;for(let _=0;_<3;_++)M[_]=1/0,M[_+3]=-1/0,T[_]=1/0,T[_+3]=-1/0,S[_]=1/0,S[_+3]=-1/0;An(x,e,S)}p.sort(la);let y=i;for(let x=0;x<y;x++){const b=p[x];for(;x+1<y&&p[x+1].candidate===b.candidate;)p.splice(x+1,1),y--}for(let x=l;x<d;x+=6){const b=e[x+2*f];for(let S=0;S<y;S++){const T=p[S];b>=T.candidate?An(x,e,T.rightCacheBounds):(An(x,e,T.leftCacheBounds),T.count++)}}for(let x=0;x<y;x++){const b=p[x],S=b.count,T=i-b.count,M=b.leftCacheBounds,_=b.rightCacheBounds;let P=0;S!==0&&(P=Ge(M)/o);let v=0;T!==0&&(v=Ge(_)/o);const B=Ni+bs*(P*S+v*T);B<u&&(c=f,u=B,a=b.candidate)}}else{for(let y=0;y<Nt;y++){const x=Xt[y];x.count=0,x.candidate=h+w+y*w;const b=x.bounds;for(let S=0;S<3;S++)b[S]=1/0,b[S+3]=-1/0}for(let y=l;y<d;y+=6){let S=~~((e[y+2*f]-h)/w);S>=Nt&&(S=Nt-1);const T=Xt[S];T.count++,An(y,e,T.bounds)}const p=Xt[Nt-1];Ui(p.bounds,p.rightCacheBounds);for(let y=Nt-2;y>=0;y--){const x=Xt[y],b=Xt[y+1];ki(x.bounds,b.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let y=0;y<Nt-1;y++){const x=Xt[y],b=x.count,S=x.bounds,M=Xt[y+1].rightCacheBounds;b!==0&&(m===0?Ui(S,Tn):ki(S,Tn,Tn)),m+=b;let _=0,P=0;m!==0&&(_=Ge(Tn)/o);const v=i-m;v!==0&&(P=Ge(M)/o);const B=Ni+bs*(_*m+P*v);B<u&&(c=f,u=B,a=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:c,pos:a}}function fa(s,t,e,n){let i=0;for(let r=t,c=t+e;r<c;r++)i+=s[r*6+n*2];return i/e}class Ss{constructor(){this.boundingData=new Float32Array(6)}}function da(s,t,e,n,i,r){let c=n,a=n+i-1;const o=r.pos,u=r.axis*2;for(;;){for(;c<=a&&e[c*6+u]<o;)c++;for(;c<=a&&e[a*6+u]>=o;)a--;if(c<a){for(let l=0;l<3;l++){let d=t[c*3+l];t[c*3+l]=t[a*3+l],t[a*3+l]=d}for(let l=0;l<6;l++){let d=e[c*6+l];e[c*6+l]=e[a*6+l],e[a*6+l]=d}c++,a--}else return c}}function pa(s,t,e,n,i,r){let c=n,a=n+i-1;const o=r.pos,u=r.axis*2;for(;;){for(;c<=a&&e[c*6+u]<o;)c++;for(;c<=a&&e[a*6+u]>=o;)a--;if(c<a){let l=s[c];s[c]=s[a],s[a]=l;for(let d=0;d<6;d++){let f=e[c*6+d];e[c*6+d]=e[a*6+d],e[a*6+d]=f}c++,a--}else return c}}function Q(s,t){return t[s+15]===65535}function st(s,t){return t[s+6]}function ft(s,t){return t[s+14]}function dt(s){return s+8}function pt(s,t){return t[s+6]}function kr(s,t){return t[s+7]}let jr,Ke,Dn,Dr;const ha=Math.pow(2,32);function Hs(s){return"count"in s?1:1+Hs(s.left)+Hs(s.right)}function ga(s,t,e){return jr=new Float32Array(e),Ke=new Uint32Array(e),Dn=new Uint16Array(e),Dr=new Uint8Array(e),Os(s,t)}function Os(s,t){const e=s/4,n=s/2,i="count"in t,r=t.boundingData;for(let c=0;c<6;c++)jr[e+c]=r[c];if(i)if(t.buffer){const c=t.buffer;Dr.set(new Uint8Array(c),s);for(let a=s,o=s+c.byteLength;a<o;a+=Ye){const u=a/2;Q(u,Dn)||(Ke[a/4+6]+=e)}return s+c.byteLength}else{const c=t.offset,a=t.count;return Ke[e+6]=c,Dn[n+14]=a,Dn[n+15]=is,s+Ye}else{const c=t.left,a=t.right,o=t.splitAxis;let u;if(u=Os(s+Ye,c),u/4>ha)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ke[e+6]=u/4,u=Os(u,a),Ke[e+7]=o,u}}function ma(s,t){const e=(s.index?s.index.count:s.attributes.position.count)/3,n=e>2**16,i=n?4:2,r=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),c=n?new Uint32Array(r):new Uint16Array(r);for(let a=0,o=c.length;a<o;a++)c[a]=a;return c}function wa(s,t,e,n,i){const{maxDepth:r,verbose:c,maxLeafTris:a,strategy:o,onProgress:u,indirect:l}=i,d=s._indirectBuffer,f=s.geometry,h=f.index?f.index.array:null,g=l?pa:da,A=Fe(f),w=new Float32Array(6);let p=!1;const m=new Ss;return Ts(t,e,n,m.boundingData,w),x(m,e,n,w),m;function y(b){u&&u(b/A)}function x(b,S,T,M=null,_=0){if(!p&&_>=r&&(p=!0,c&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),T<=a||_>=r)return y(S+T),b.offset=S,b.count=T,b;const P=ua(b.boundingData,M,t,S,T,o);if(P.axis===-1)return y(S+T),b.offset=S,b.count=T,b;const v=g(d,h,t,S,T,P);if(v===S||v===S+T)y(S+T),b.offset=S,b.count=T;else{b.splitAxis=P.axis;const B=new Ss,L=S,E=v-S;b.left=B,Ts(t,L,E,B.boundingData,w),x(B,L,E,w,_+1);const C=new Ss,N=v,q=T-E;b.right=C,Ts(t,N,q,C.boundingData,w),x(C,N,q,w,_+1)}return b}}function ya(s,t){const e=s.geometry;t.indirect&&(s._indirectBuffer=ma(e,t.useSharedArrayBuffer),aa(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||oa(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ca(e),r=t.indirect?Fr(e):Ur(e);s._roots=r.map(c=>{const a=wa(s,i,c.offset,c.count,t),o=Hs(a),u=new n(Ye*o);return ga(0,a,u),u})}class Ft{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,i=-1/0;for(let r=0,c=t.length;r<c;r++){const o=t[r][e];n=o<n?o:n,i=o>i?o:i}this.min=n,this.max=i}setFromPoints(t,e){let n=1/0,i=-1/0;for(let r=0,c=e.length;r<c;r++){const a=e[r],o=t.dot(a);n=o<n?o:n,i=o>i?o:i}this.min=n,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}Ft.prototype.setFromBox=function(){const s=new I;return function(e,n){const i=n.min,r=n.max;let c=1/0,a=-1/0;for(let o=0;o<=1;o++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){s.x=i.x*o+r.x*(1-o),s.y=i.y*u+r.y*(1-u),s.z=i.z*l+r.z*(1-l);const d=e.dot(s);c=Math.min(d,c),a=Math.max(d,a)}this.min=c,this.max=a}}();const xa=function(){const s=new I,t=new I,e=new I;return function(i,r,c){const a=i.start,o=s,u=r.start,l=t;e.subVectors(a,u),s.subVectors(i.end,i.start),t.subVectors(r.end,r.start);const d=e.dot(l),f=l.dot(o),h=l.dot(l),g=e.dot(o),w=o.dot(o)*h-f*f;let p,m;w!==0?p=(d*f-g*h)/w:p=0,m=(d+p*f)/h,c.x=p,c.y=m}}(),ni=function(){const s=new ue,t=new I,e=new I;return function(i,r,c,a){xa(i,r,s);let o=s.x,u=s.y;if(o>=0&&o<=1&&u>=0&&u<=1){i.at(o,c),r.at(u,a);return}else if(o>=0&&o<=1){u<0?r.at(0,a):r.at(1,a),i.closestPointToPoint(a,!0,c);return}else if(u>=0&&u<=1){o<0?i.at(0,c):i.at(1,c),r.closestPointToPoint(c,!0,a);return}else{let l;o<0?l=i.start:l=i.end;let d;u<0?d=r.start:d=r.end;const f=t,h=e;if(i.closestPointToPoint(d,!0,t),r.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=h.distanceToSquared(l)){c.copy(f),a.copy(d);return}else{c.copy(l),a.copy(h);return}}}}(),ba=function(){const s=new I,t=new I,e=new ti,n=new gt;return function(r,c){const{radius:a,center:o}=r,{a:u,b:l,c:d}=c;if(n.start=u,n.end=l,n.closestPointToPoint(o,!0,s).distanceTo(o)<=a||(n.start=u,n.end=d,n.closestPointToPoint(o,!0,s).distanceTo(o)<=a)||(n.start=l,n.end=d,n.closestPointToPoint(o,!0,s).distanceTo(o)<=a))return!0;const A=c.getPlane(e);if(Math.abs(A.distanceToPoint(o))<=a){const p=A.projectPoint(o,t);if(c.containsPoint(p))return!0}return!1}}(),Aa=1e-15;function Ms(s){return Math.abs(s)<Aa}class mt extends nt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new I),this.satBounds=new Array(4).fill().map(()=>new Ft),this.points=[this.a,this.b,this.c],this.sphere=new jo,this.plane=new ti,this.needsUpdate=!0}intersectsSphere(t){return ba(t,this)}update(){const t=this.a,e=this.b,n=this.c,i=this.points,r=this.satAxes,c=this.satBounds,a=r[0],o=c[0];this.getNormal(a),o.setFromPoints(a,i);const u=r[1],l=c[1];u.subVectors(t,e),l.setFromPoints(u,i);const d=r[2],f=c[2];d.subVectors(e,n),f.setFromPoints(d,i);const h=r[3],g=c[3];h.subVectors(n,t),g.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}mt.prototype.closestPointToSegment=function(){const s=new I,t=new I,e=new gt;return function(i,r=null,c=null){const{start:a,end:o}=i,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),ni(e,i,s,t),l=s.distanceToSquared(t),l<d&&(d=l,r&&r.copy(s),c&&c.copy(t))}return this.closestPointToPoint(a,s),l=a.distanceToSquared(s),l<d&&(d=l,r&&r.copy(s),c&&c.copy(a)),this.closestPointToPoint(o,s),l=o.distanceToSquared(s),l<d&&(d=l,r&&r.copy(s),c&&c.copy(o)),Math.sqrt(d)}}();mt.prototype.intersectsTriangle=function(){const s=new mt,t=new Array(3),e=new Array(3),n=new Ft,i=new Ft,r=new I,c=new I,a=new I,o=new I,u=new I,l=new gt,d=new gt,f=new gt,h=new I;function g(A,w,p){const m=A.points;let y=0,x=-1;for(let b=0;b<3;b++){const{start:S,end:T}=l;S.copy(m[b]),T.copy(m[(b+1)%3]),l.delta(c);const M=Ms(w.distanceToPoint(S));if(Ms(w.normal.dot(c))&&M){p.copy(l),y=2;break}const _=w.intersectLine(l,h);if(!_&&M&&h.copy(S),(_||M)&&!Ms(h.distanceTo(T))){if(y<=1)(y===1?p.start:p.end).copy(h),M&&(x=y);else if(y>=2){(x===1?p.start:p.end).copy(h),y=2;break}if(y++,y===2&&x===-1)break}}return y}return function(w,p=null,m=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(s.copy(w),s.update(),w=s);const y=this.plane,x=w.plane;if(Math.abs(y.normal.dot(x.normal))>1-1e-10){const b=this.satBounds,S=this.satAxes;e[0]=w.a,e[1]=w.b,e[2]=w.c;for(let _=0;_<4;_++){const P=b[_],v=S[_];if(n.setFromPoints(v,e),P.isSeparated(n))return!1}const T=w.satBounds,M=w.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let _=0;_<4;_++){const P=T[_],v=M[_];if(n.setFromPoints(v,t),P.isSeparated(n))return!1}for(let _=0;_<4;_++){const P=S[_];for(let v=0;v<4;v++){const B=M[v];if(r.crossVectors(P,B),n.setFromPoints(r,t),i.setFromPoints(r,e),n.isSeparated(i))return!1}}return p&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const b=g(this,x,d);if(b===1&&w.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(b!==2)return!1;const S=g(w,y,f);if(S===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(S!==2)return!1;if(d.delta(a),f.delta(o),a.dot(o)<0){let L=f.start;f.start=f.end,f.end=L}const T=d.start.dot(a),M=d.end.dot(a),_=f.start.dot(a),P=f.end.dot(a),v=M<_,B=T<P;return T!==P&&_!==M&&v===B?!1:(p&&(u.subVectors(d.start,f.start),u.dot(a)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();mt.prototype.distanceToPoint=function(){const s=new I;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}}();mt.prototype.distanceToTriangle=function(){const s=new I,t=new I,e=["a","b","c"],n=new gt,i=new gt;return function(c,a=null,o=null){const u=a||o?n:null;if(this.intersectsTriangle(c,u))return(a||o)&&(a&&u.getCenter(a),o&&u.getCenter(o)),0;let l=1/0;for(let d=0;d<3;d++){let f;const h=e[d],g=c[h];this.closestPointToPoint(g,s),f=g.distanceToSquared(s),f<l&&(l=f,a&&a.copy(s),o&&o.copy(g));const A=this[h];c.closestPointToPoint(A,s),f=A.distanceToSquared(s),f<l&&(l=f,a&&a.copy(A),o&&o.copy(s))}for(let d=0;d<3;d++){const f=e[d],h=e[(d+1)%3];n.set(this[f],this[h]);for(let g=0;g<3;g++){const A=e[g],w=e[(g+1)%3];i.set(c[A],c[w]),ni(n,i,s,t);const p=s.distanceToSquared(t);p<l&&(l=p,a&&a.copy(s),o&&o.copy(t))}}return Math.sqrt(l)}}();class Y{constructor(t,e,n){this.isOrientedBox=!0,this.min=new I,this.max=new I,this.matrix=new It,this.invMatrix=new It,this.points=new Array(8).fill().map(()=>new I),this.satAxes=new Array(3).fill().map(()=>new I),this.satBounds=new Array(3).fill().map(()=>new Ft),this.alignedSatBounds=new Array(3).fill().map(()=>new Ft),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Y.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,h=i[f];h.x=u?n.x:e.x,h.y=l?n.y:e.y,h.z=d?n.z:e.z,h.applyMatrix4(t)}const r=this.satBounds,c=this.satAxes,a=i[0];for(let u=0;u<3;u++){const l=c[u],d=r[u],f=1<<u,h=i[f];l.subVectors(a,h),d.setFromPoints(l,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Y.prototype.intersectsBox=function(){const s=new Ft;return function(e){this.needsUpdate&&this.update();const n=e.min,i=e.max,r=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(s.min=n.x,s.max=i.x,a[0].isSeparated(s)||(s.min=n.y,s.max=i.y,a[1].isSeparated(s))||(s.min=n.z,s.max=i.z,a[2].isSeparated(s)))return!1;for(let o=0;o<3;o++){const u=c[o],l=r[o];if(s.setFromBox(u,e),l.isSeparated(s))return!1}return!0}}();Y.prototype.intersectsTriangle=function(){const s=new mt,t=new Array(3),e=new Ft,n=new Ft,i=new I;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(s.copy(c),s.update(),c=s);const a=this.satBounds,o=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let f=0;f<3;f++){const h=a[f],g=o[f];if(e.setFromPoints(g,t),h.isSeparated(e))return!1}const u=c.satBounds,l=c.satAxes,d=this.points;for(let f=0;f<3;f++){const h=u[f],g=l[f];if(e.setFromPoints(g,d),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=o[f];for(let g=0;g<4;g++){const A=l[g];if(i.crossVectors(h,A),e.setFromPoints(i,t),n.setFromPoints(i,d),e.isSeparated(n))return!1}}return!0}}();Y.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();Y.prototype.distanceToPoint=function(){const s=new I;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}}();Y.prototype.distanceToBox=function(){const s=["x","y","z"],t=new Array(12).fill().map(()=>new gt),e=new Array(12).fill().map(()=>new gt),n=new I,i=new I;return function(c,a=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(o||u)&&(c.getCenter(i),this.closestPointToPoint(i,n),c.closestPointToPoint(n,i),o&&o.copy(n),u&&u.copy(i)),0;const l=a*a,d=c.min,f=c.max,h=this.points;let g=1/0;for(let w=0;w<8;w++){const p=h[w];i.copy(p).clamp(d,f);const m=p.distanceToSquared(i);if(m<g&&(g=m,o&&o.copy(p),u&&u.copy(i),m<l))return Math.sqrt(m)}let A=0;for(let w=0;w<3;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){const y=(w+1)%3,x=(w+2)%3,b=p<<y|m<<x,S=1<<w|p<<y|m<<x,T=h[b],M=h[S];t[A].set(T,M);const P=s[w],v=s[y],B=s[x],L=e[A],E=L.start,C=L.end;E[P]=d[P],E[v]=p?d[v]:f[v],E[B]=m?d[B]:f[v],C[P]=f[P],C[v]=p?d[v]:f[v],C[B]=m?d[B]:f[v],A++}for(let w=0;w<=1;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){i.x=w?f.x:d.x,i.y=p?f.y:d.y,i.z=m?f.z:d.z,this.closestPointToPoint(i,n);const y=i.distanceToSquared(n);if(y<g&&(g=y,o&&o.copy(n),u&&u.copy(i),y<l))return Math.sqrt(y)}for(let w=0;w<12;w++){const p=t[w];for(let m=0;m<12;m++){const y=e[m];ni(p,y,n,i);const x=n.distanceToSquared(i);if(x<g&&(g=x,o&&o.copy(n),u&&u.copy(i),x<l))return Math.sqrt(x)}}return Math.sqrt(g)}}();class si{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Ta extends si{constructor(){super(()=>new mt)}}const ht=new Ta;class Sa{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const j=new Sa;let Yt,ve;const xe=[],Sn=new si(()=>new Bt);function Ma(s,t,e,n,i,r){Yt=Sn.getPrimitive(),ve=Sn.getPrimitive(),xe.push(Yt,ve),j.setBuffer(s._roots[t]);const c=Ws(0,s.geometry,e,n,i,r);j.clearBuffer(),Sn.releasePrimitive(Yt),Sn.releasePrimitive(ve),xe.pop(),xe.pop();const a=xe.length;return a>0&&(ve=xe[a-1],Yt=xe[a-2]),c}function Ws(s,t,e,n,i=null,r=0,c=0){const{float32Array:a,uint16Array:o,uint32Array:u}=j;let l=s*2;if(Q(l,o)){const f=st(s,u),h=ft(l,o);return $(s,a,Yt),n(f,h,!1,c,r+s,Yt)}else{let P=function(B){const{uint16Array:L,uint32Array:E}=j;let C=B*2;for(;!Q(C,L);)B=dt(B),C=B*2;return st(B,E)},v=function(B){const{uint16Array:L,uint32Array:E}=j;let C=B*2;for(;!Q(C,L);)B=pt(B,E),C=B*2;return st(B,E)+ft(C,L)};const f=dt(s),h=pt(s,u);let g=f,A=h,w,p,m,y;if(i&&(m=Yt,y=ve,$(g,a,m),$(A,a,y),w=i(m),p=i(y),p<w)){g=h,A=f;const B=w;w=p,p=B,m=y}m||(m=Yt,$(g,a,m));const x=Q(g*2,o),b=e(m,x,w,c+1,r+g);let S;if(b===Vi){const B=P(g),E=v(g)-B;S=n(B,E,!0,c+1,r+g,m)}else S=b&&Ws(g,t,e,n,i,r,c+1);if(S)return!0;y=ve,$(A,a,y);const T=Q(A*2,o),M=e(y,T,p,c+1,r+A);let _;if(M===Vi){const B=P(A),E=v(A)-B;_=n(B,E,!0,c+1,r+A,y)}else _=M&&Ws(A,t,e,n,i,r,c+1);return!!_}}const He=new I,_s=new I;function _a(s,t,e={},n=0,i=1/0){const r=n*n,c=i*i;let a=1/0,o=null;if(s.shapecast({boundsTraverseOrder:l=>(He.copy(t).clamp(l.min,l.max),He.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<a&&f<c,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,He);const f=t.distanceToSquared(He);return f<a&&(_s.copy(He),a=f,o=d),f<r}}),a===1/0)return null;const u=Math.sqrt(a);return e.point?e.point.copy(_s):e.point=_s.clone(),e.distance=u,e.faceIndex=o,e}const be=new I,Ae=new I,Te=new I,Mn=new ue,_n=new ue,Bn=new ue,ji=new I,Di=new I,$i=new I,Pn=new I;function Ba(s,t,e,n,i,r){let c;return r===Do?c=s.intersectTriangle(n,e,t,!0,i):c=s.intersectTriangle(t,e,n,r!==ei,i),c===null?null:{distance:s.origin.distanceTo(i),point:i.clone()}}function Pa(s,t,e,n,i,r,c,a,o){be.fromBufferAttribute(t,r),Ae.fromBufferAttribute(t,c),Te.fromBufferAttribute(t,a);const u=Ba(s,be,Ae,Te,Pn,o);if(u){n&&(Mn.fromBufferAttribute(n,r),_n.fromBufferAttribute(n,c),Bn.fromBufferAttribute(n,a),u.uv=nt.getInterpolation(Pn,be,Ae,Te,Mn,_n,Bn,new ue)),i&&(Mn.fromBufferAttribute(i,r),_n.fromBufferAttribute(i,c),Bn.fromBufferAttribute(i,a),u.uv1=nt.getInterpolation(Pn,be,Ae,Te,Mn,_n,Bn,new ue)),e&&(ji.fromBufferAttribute(e,r),Di.fromBufferAttribute(e,c),$i.fromBufferAttribute(e,a),u.normal=nt.getInterpolation(Pn,be,Ae,Te,ji,Di,$i,new I),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const l={a:r,b:c,c:a,normal:new I,materialIndex:0};nt.getNormal(be,Ae,Te,l.normal),u.face=l,u.faceIndex=r}return u}function rs(s,t,e,n,i){const r=n*3;let c=r+0,a=r+1,o=r+2;const u=s.index;s.index&&(c=u.getX(c),a=u.getX(a),o=u.getX(o));const{position:l,normal:d,uv:f,uv1:h}=s.attributes,g=Pa(e,l,d,f,h,c,a,o,t);return g?(g.faceIndex=n,i&&i.push(g),g):null}function H(s,t,e,n){const i=s.a,r=s.b,c=s.c;let a=t,o=t+1,u=t+2;e&&(a=e.getX(a),o=e.getX(o),u=e.getX(u)),i.x=n.getX(a),i.y=n.getY(a),i.z=n.getZ(a),r.x=n.getX(o),r.y=n.getY(o),r.z=n.getZ(o),c.x=n.getX(u),c.y=n.getY(u),c.z=n.getZ(u)}function La(s,t,e,n,i,r){const{geometry:c,_indirectBuffer:a}=s;for(let o=n,u=n+i;o<u;o++)rs(c,t,e,o,r)}function va(s,t,e,n,i){const{geometry:r,_indirectBuffer:c}=s;let a=1/0,o=null;for(let u=n,l=n+i;u<l;u++){let d;d=rs(r,t,e,u),d&&d.distance<a&&(o=d,a=d.distance)}return o}function Ia(s,t,e,n,i,r,c){const{geometry:a}=e,{index:o}=a,u=a.attributes.position;for(let l=s,d=t+s;l<d;l++){let f;if(f=l,H(c,f*3,o,u),c.needsUpdate=!0,n(c,f,i,r))return!0}return!1}function Ea(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let r,c,a,o,u=0;const l=s._roots;for(let f=0,h=l.length;f<h;f++)r=l[f],c=new Uint32Array(r),a=new Uint16Array(r),o=new Float32Array(r),d(0,u),u+=r.byteLength;function d(f,h,g=!1){const A=f*2;if(a[A+15]===is){const p=c[f+6],m=a[A+14];let y=1/0,x=1/0,b=1/0,S=-1/0,T=-1/0,M=-1/0;for(let _=3*p,P=3*(p+m);_<P;_++){let v=n[_];const B=i.getX(v),L=i.getY(v),E=i.getZ(v);B<y&&(y=B),B>S&&(S=B),L<x&&(x=L),L>T&&(T=L),E<b&&(b=E),E>M&&(M=E)}return o[f+0]!==y||o[f+1]!==x||o[f+2]!==b||o[f+3]!==S||o[f+4]!==T||o[f+5]!==M?(o[f+0]=y,o[f+1]=x,o[f+2]=b,o[f+3]=S,o[f+4]=T,o[f+5]=M,!0):!1}else{const p=f+8,m=c[f+6],y=p+h,x=m+h;let b=g,S=!1,T=!1;t?b||(S=t.has(y),T=t.has(x),b=!S&&!T):(S=!0,T=!0);const M=b||S,_=b||T;let P=!1;M&&(P=d(p,h,b));let v=!1;_&&(v=d(m,h,b));const B=P||v;if(B)for(let L=0;L<3;L++){const E=p+L,C=m+L,N=o[E],q=o[E+3],we=o[C],se=o[C+3];o[f+L]=N<we?N:we,o[f+L+3]=q>se?q:se}return B}}}const Gi=new Bt;function Qt(s,t,e,n){return $(s,t,Gi),e.intersectBox(Gi,n)}function Ca(s,t,e,n,i,r){const{geometry:c,_indirectBuffer:a}=s;for(let o=n,u=n+i;o<u;o++){let l=a?a[o]:o;rs(c,t,e,l,r)}}function za(s,t,e,n,i){const{geometry:r,_indirectBuffer:c}=s;let a=1/0,o=null;for(let u=n,l=n+i;u<l;u++){let d;d=rs(r,t,e,c?c[u]:u),d&&d.distance<a&&(o=d,a=d.distance)}return o}function Ra(s,t,e,n,i,r,c){const{geometry:a}=e,{index:o}=a,u=a.attributes.position;for(let l=s,d=t+s;l<d;l++){let f;if(f=e.resolveTriangleIndex(l),H(c,f*3,o,u),c.needsUpdate=!0,n(c,f,i,r))return!0}return!1}const Hi=new I;function Va(s,t,e,n,i){j.setBuffer(s._roots[t]),Xs(0,s,e,n,i),j.clearBuffer()}function Xs(s,t,e,n,i){const{float32Array:r,uint16Array:c,uint32Array:a}=j,o=s*2;if(Q(o,c)){const l=st(s,a),d=ft(o,c);La(t,e,n,l,d,i)}else{const l=dt(s);Qt(l,r,n,Hi)&&Xs(l,t,e,n,i);const d=pt(s,a);Qt(d,r,n,Hi)&&Xs(d,t,e,n,i)}}const Oi=new I,Na=["x","y","z"];function Fa(s,t,e,n){j.setBuffer(s._roots[t]);const i=qs(0,s,e,n);return j.clearBuffer(),i}function qs(s,t,e,n){const{float32Array:i,uint16Array:r,uint32Array:c}=j;let a=s*2;if(Q(a,r)){const u=st(s,c),l=ft(a,r);return va(t,e,n,u,l)}else{const u=kr(s,c),l=Na[u],f=n.direction[l]>=0;let h,g;f?(h=dt(s),g=pt(s,c)):(h=pt(s,c),g=dt(s));const w=Qt(h,i,n,Oi)?qs(h,t,e,n):null;if(w){const y=w.point[l];if(f?y<=i[g+u]:y>=i[g+u+3])return w}const m=Qt(g,i,n,Oi)?qs(g,t,e,n):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const Ln=new Bt,Se=new mt,Me=new mt,Oe=new It,Wi=new Y,vn=new Y;function Ua(s,t,e,n){j.setBuffer(s._roots[t]);const i=Zs(0,s,e,n);return j.clearBuffer(),i}function Zs(s,t,e,n,i=null){const{float32Array:r,uint16Array:c,uint32Array:a}=j;let o=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Wi.set(e.boundingBox.min,e.boundingBox.max,n),i=Wi),Q(o,c)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,g=e.attributes.position,A=st(s,a),w=ft(o,c);if(Oe.copy(n).invert(),e.boundsTree)return $(s,r,vn),vn.matrix.copy(Oe),vn.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>vn.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let y=A*3,x=(w+A)*3;y<x;y+=3)if(H(Me,y,d,f),Me.needsUpdate=!0,m.intersectsTriangle(Me))return!0;return!1}});for(let p=A*3,m=(w+A)*3;p<m;p+=3){H(Se,p,d,f),Se.a.applyMatrix4(Oe),Se.b.applyMatrix4(Oe),Se.c.applyMatrix4(Oe),Se.needsUpdate=!0;for(let y=0,x=h.count;y<x;y+=3)if(H(Me,y,h,g),Me.needsUpdate=!0,Se.intersectsTriangle(Me))return!0}}else{const l=s+8,d=a[s+6];return $(l,r,Ln),!!(i.intersectsBox(Ln)&&Zs(l,t,e,n,i)||($(d,r,Ln),i.intersectsBox(Ln)&&Zs(d,t,e,n,i)))}}const In=new It,Bs=new Y,We=new Y,ka=new I,ja=new I,Da=new I,$a=new I;function Ga(s,t,e,n={},i={},r=0,c=1/0){t.boundingBox||t.computeBoundingBox(),Bs.set(t.boundingBox.min,t.boundingBox.max,e),Bs.needsUpdate=!0;const a=s.geometry,o=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=ht.getPrimitive(),h=ht.getPrimitive();let g=ka,A=ja,w=null,p=null;i&&(w=Da,p=$a);let m=1/0,y=null,x=null;return In.copy(e).invert(),We.matrix.copy(In),s.shapecast({boundsTraverseOrder:b=>Bs.distanceToBox(b),intersectsBounds:(b,S,T)=>T<m&&T<c?(S&&(We.min.copy(b.min),We.max.copy(b.max),We.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>We.distanceToBox(M),intersectsBounds:(M,_,P)=>P<m&&P<c,intersectsRange:(M,_)=>{for(let P=M,v=M+_;P<v;P++){H(h,3*P,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let B=b,L=b+S;B<L;B++){H(f,3*B,u,o),f.needsUpdate=!0;const E=f.distanceToTriangle(h,g,w);if(E<m&&(A.copy(g),p&&p.copy(w),m=E,y=B,x=P),E<r)return!0}}}});{const T=Fe(t);for(let M=0,_=T;M<_;M++){H(h,3*M,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let P=b,v=b+S;P<v;P++){H(f,3*P,u,o),f.needsUpdate=!0;const B=f.distanceToTriangle(h,g,w);if(B<m&&(A.copy(g),p&&p.copy(w),m=B,y=P,x=M),B<r)return!0}}}}}),ht.releasePrimitive(f),ht.releasePrimitive(h),m===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=m,n.faceIndex=y,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(In),A.applyMatrix4(In),i.distance=A.sub(i.point).length(),i.faceIndex=x),n)}function Ha(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let r,c,a,o,u=0;const l=s._roots;for(let f=0,h=l.length;f<h;f++)r=l[f],c=new Uint32Array(r),a=new Uint16Array(r),o=new Float32Array(r),d(0,u),u+=r.byteLength;function d(f,h,g=!1){const A=f*2;if(a[A+15]===is){const p=c[f+6],m=a[A+14];let y=1/0,x=1/0,b=1/0,S=-1/0,T=-1/0,M=-1/0;for(let _=p,P=p+m;_<P;_++){const v=3*s.resolveTriangleIndex(_);for(let B=0;B<3;B++){let L=v+B;L=n?n[L]:L;const E=i.getX(L),C=i.getY(L),N=i.getZ(L);E<y&&(y=E),E>S&&(S=E),C<x&&(x=C),C>T&&(T=C),N<b&&(b=N),N>M&&(M=N)}}return o[f+0]!==y||o[f+1]!==x||o[f+2]!==b||o[f+3]!==S||o[f+4]!==T||o[f+5]!==M?(o[f+0]=y,o[f+1]=x,o[f+2]=b,o[f+3]=S,o[f+4]=T,o[f+5]=M,!0):!1}else{const p=f+8,m=c[f+6],y=p+h,x=m+h;let b=g,S=!1,T=!1;t?b||(S=t.has(y),T=t.has(x),b=!S&&!T):(S=!0,T=!0);const M=b||S,_=b||T;let P=!1;M&&(P=d(p,h,b));let v=!1;_&&(v=d(m,h,b));const B=P||v;if(B)for(let L=0;L<3;L++){const E=p+L,C=m+L,N=o[E],q=o[E+3],we=o[C],se=o[C+3];o[f+L]=N<we?N:we,o[f+L+3]=q>se?q:se}return B}}}const Xi=new I;function Oa(s,t,e,n,i){j.setBuffer(s._roots[t]),Ks(0,s,e,n,i),j.clearBuffer()}function Ks(s,t,e,n,i){const{float32Array:r,uint16Array:c,uint32Array:a}=j,o=s*2;if(Q(o,c)){const l=st(s,a),d=ft(o,c);Ca(t,e,n,l,d,i)}else{const l=dt(s);Qt(l,r,n,Xi)&&Ks(l,t,e,n,i);const d=pt(s,a);Qt(d,r,n,Xi)&&Ks(d,t,e,n,i)}}const qi=new I,Wa=["x","y","z"];function Xa(s,t,e,n){j.setBuffer(s._roots[t]);const i=Ys(0,s,e,n);return j.clearBuffer(),i}function Ys(s,t,e,n){const{float32Array:i,uint16Array:r,uint32Array:c}=j;let a=s*2;if(Q(a,r)){const u=st(s,c),l=ft(a,r);return za(t,e,n,u,l)}else{const u=kr(s,c),l=Wa[u],f=n.direction[l]>=0;let h,g;f?(h=dt(s),g=pt(s,c)):(h=pt(s,c),g=dt(s));const w=Qt(h,i,n,qi)?Ys(h,t,e,n):null;if(w){const y=w.point[l];if(f?y<=i[g+u]:y>=i[g+u+3])return w}const m=Qt(g,i,n,qi)?Ys(g,t,e,n):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const En=new Bt,_e=new mt,Be=new mt,Xe=new It,Zi=new Y,Cn=new Y;function qa(s,t,e,n){j.setBuffer(s._roots[t]);const i=Js(0,s,e,n);return j.clearBuffer(),i}function Js(s,t,e,n,i=null){const{float32Array:r,uint16Array:c,uint32Array:a}=j;let o=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Zi.set(e.boundingBox.min,e.boundingBox.max,n),i=Zi),Q(o,c)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,g=e.attributes.position,A=st(s,a),w=ft(o,c);if(Xe.copy(n).invert(),e.boundsTree)return $(s,r,Cn),Cn.matrix.copy(Xe),Cn.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Cn.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let y=A,x=w+A;y<x;y++)if(H(Be,3*t.resolveTriangleIndex(y),d,f),Be.needsUpdate=!0,m.intersectsTriangle(Be))return!0;return!1}});for(let p=A,m=w+A;p<m;p++){const y=t.resolveTriangleIndex(p);H(_e,3*y,d,f),_e.a.applyMatrix4(Xe),_e.b.applyMatrix4(Xe),_e.c.applyMatrix4(Xe),_e.needsUpdate=!0;for(let x=0,b=h.count;x<b;x+=3)if(H(Be,x,h,g),Be.needsUpdate=!0,_e.intersectsTriangle(Be))return!0}}else{const l=s+8,d=a[s+6];return $(l,r,En),!!(i.intersectsBox(En)&&Js(l,t,e,n,i)||($(d,r,En),i.intersectsBox(En)&&Js(d,t,e,n,i)))}}const zn=new It,Ps=new Y,qe=new Y,Za=new I,Ka=new I,Ya=new I,Ja=new I;function Qa(s,t,e,n={},i={},r=0,c=1/0){t.boundingBox||t.computeBoundingBox(),Ps.set(t.boundingBox.min,t.boundingBox.max,e),Ps.needsUpdate=!0;const a=s.geometry,o=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=ht.getPrimitive(),h=ht.getPrimitive();let g=Za,A=Ka,w=null,p=null;i&&(w=Ya,p=Ja);let m=1/0,y=null,x=null;return zn.copy(e).invert(),qe.matrix.copy(zn),s.shapecast({boundsTraverseOrder:b=>Ps.distanceToBox(b),intersectsBounds:(b,S,T)=>T<m&&T<c?(S&&(qe.min.copy(b.min),qe.max.copy(b.max),qe.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:M=>qe.distanceToBox(M),intersectsBounds:(M,_,P)=>P<m&&P<c,intersectsRange:(M,_)=>{for(let P=M,v=M+_;P<v;P++){const B=T.resolveTriangleIndex(P);H(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let L=b,E=b+S;L<E;L++){const C=s.resolveTriangleIndex(L);H(f,3*C,u,o),f.needsUpdate=!0;const N=f.distanceToTriangle(h,g,w);if(N<m&&(A.copy(g),p&&p.copy(w),m=N,y=L,x=P),N<r)return!0}}}})}else{const T=Fe(t);for(let M=0,_=T;M<_;M++){H(h,3*M,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let P=b,v=b+S;P<v;P++){const B=s.resolveTriangleIndex(P);H(f,3*B,u,o),f.needsUpdate=!0;const L=f.distanceToTriangle(h,g,w);if(L<m&&(A.copy(g),p&&p.copy(w),m=L,y=P,x=M),L<r)return!0}}}}}),ht.releasePrimitive(f),ht.releasePrimitive(h),m===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=m,n.faceIndex=y,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(zn),A.applyMatrix4(zn),i.distance=A.sub(i.point).length(),i.faceIndex=x),n)}function tc(){return typeof SharedArrayBuffer<"u"}const Je=new j.constructor,On=new j.constructor,Zt=new si(()=>new Bt),Pe=new Bt,Le=new Bt,Ls=new Bt,vs=new Bt;let Is=!1;function ec(s,t,e,n){if(Is)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Is=!0;const i=s._roots,r=t._roots;let c,a=0,o=0;const u=new It().copy(e).invert();for(let l=0,d=i.length;l<d;l++){Je.setBuffer(i[l]),o=0;const f=Zt.getPrimitive();$(0,Je.float32Array,f),f.applyMatrix4(u);for(let h=0,g=r.length;h<g&&(On.setBuffer(r[l]),c=At(0,0,e,u,n,a,o,0,0,f),On.clearBuffer(),o+=r[h].length,!c);h++);if(Zt.releasePrimitive(f),Je.clearBuffer(),a+=i[l].length,c)break}return Is=!1,c}function At(s,t,e,n,i,r=0,c=0,a=0,o=0,u=null,l=!1){let d,f;l?(d=On,f=Je):(d=Je,f=On);const h=d.float32Array,g=d.uint32Array,A=d.uint16Array,w=f.float32Array,p=f.uint32Array,m=f.uint16Array,y=s*2,x=t*2,b=Q(y,A),S=Q(x,m);let T=!1;if(S&&b)l?T=i(st(t,p),ft(t*2,m),st(s,g),ft(s*2,A),o,c+t,a,r+s):T=i(st(s,g),ft(s*2,A),st(t,p),ft(t*2,m),a,r+s,o,c+t);else if(S){const M=Zt.getPrimitive();$(t,w,M),M.applyMatrix4(e);const _=dt(s),P=pt(s,g);$(_,h,Pe),$(P,h,Le);const v=M.intersectsBox(Pe),B=M.intersectsBox(Le);T=v&&At(t,_,n,e,i,c,r,o,a+1,M,!l)||B&&At(t,P,n,e,i,c,r,o,a+1,M,!l),Zt.releasePrimitive(M)}else{const M=dt(t),_=pt(t,p);$(M,w,Ls),$(_,w,vs);const P=u.intersectsBox(Ls),v=u.intersectsBox(vs);if(P&&v)T=At(s,M,e,n,i,r,c,a,o+1,u,l)||At(s,_,e,n,i,r,c,a,o+1,u,l);else if(P)if(b)T=At(s,M,e,n,i,r,c,a,o+1,u,l);else{const B=Zt.getPrimitive();B.copy(Ls).applyMatrix4(e);const L=dt(s),E=pt(s,g);$(L,h,Pe),$(E,h,Le);const C=B.intersectsBox(Pe),N=B.intersectsBox(Le);T=C&&At(M,L,n,e,i,c,r,o,a+1,B,!l)||N&&At(M,E,n,e,i,c,r,o,a+1,B,!l),Zt.releasePrimitive(B)}else if(v)if(b)T=At(s,_,e,n,i,r,c,a,o+1,u,l);else{const B=Zt.getPrimitive();B.copy(vs).applyMatrix4(e);const L=dt(s),E=pt(s,g);$(L,h,Pe),$(E,h,Le);const C=B.intersectsBox(Pe),N=B.intersectsBox(Le);T=C&&At(_,L,n,e,i,c,r,o,a+1,B,!l)||N&&At(_,E,n,e,i,c,r,o,a+1,B,!l),Zt.releasePrimitive(B)}}return T}const Rn=new Y,Ki=new Bt,nc={strategy:Nr,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class ii{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,i=t._roots,r=t._indirectBuffer,c=n.getIndex();let a;return e.cloneBuffers?a={roots:i.map(o=>o.slice()),index:c.array.slice(),indirectBuffer:r?r.slice():null}:a={roots:i,index:c.array,indirectBuffer:r},a}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:i,roots:r,indirectBuffer:c}=t,a=new ii(e,{...n,[As]:!0});if(a._roots=r,a._indirectBuffer=c||null,n.setIndex){const o=e.getIndex();if(o===null){const u=new ss(t.index,1,!1);e.setIndex(u)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...nc,[As]:!1},e),e.useSharedArrayBuffer&&!tc())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[As]||(ya(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Bt)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?i=>n[i]:i=>i}refit(t=null){return(this.indirect?Ha:Ea)(this,t)}traverse(t,e=0){const n=this._roots[e],i=new Uint32Array(n),r=new Uint16Array(n);c(0);function c(a,o=0){const u=a*2,l=r[u+15]===is;if(l){const d=i[a+6],f=r[u+14];t(o,l,new Float32Array(n,a*4,6),d,f)}else{const d=a+Ye/4,f=i[a+6],h=i[a+7];t(o,l,new Float32Array(n,a*4,6),h)||(c(d,o+1),c(f,o+1))}}}raycast(t,e=vi){const n=this._roots,i=this.geometry,r=[],c=e.isMaterial,a=Array.isArray(e),o=i.groups,u=c?e.side:e,l=this.indirect?Oa:Va;for(let d=0,f=n.length;d<f;d++){const h=a?e[o[d].materialIndex].side:u,g=r.length;if(l(this,d,h,t,r),a){const A=o[d].materialIndex;for(let w=g,p=r.length;w<p;w++)r[w].face.materialIndex=A}}return r}raycastFirst(t,e=vi){const n=this._roots,i=this.geometry,r=e.isMaterial,c=Array.isArray(e);let a=null;const o=i.groups,u=r?e.side:e,l=this.indirect?Xa:Fa;for(let d=0,f=n.length;d<f;d++){const h=c?e[o[d].materialIndex].side:u,g=l(this,d,h,t);g!=null&&(a==null||g.distance<a.distance)&&(a=g,c&&(g.face.materialIndex=o[d].materialIndex))}return a}intersectsGeometry(t,e){let n=!1;const i=this._roots,r=this.indirect?qa:Ua;for(let c=0,a=i.length;c<a&&(n=r(this,c,t,e),!n);c++);return n}shapecast(t){const e=ht.getPrimitive(),n=this.indirect?Ra:Ia;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:c,intersectsTriangle:a}=t;if(c&&a){const d=c;c=(f,h,g,A,w)=>d(f,h,g,A,w)?!0:n(f,h,this,a,g,A,e)}else c||(a?c=(d,f,h,g)=>n(d,f,this,a,h,g,e):c=(d,f,h)=>h);let o=!1,u=0;const l=this._roots;for(let d=0,f=l.length;d<f;d++){const h=l[d];if(o=Ma(this,d,r,c,i,u),o)break;u+=h.byteLength}return ht.releasePrimitive(e),o}bvhcast(t,e,n){let{intersectsRanges:i,intersectsTriangles:r}=n;const c=ht.getPrimitive(),a=this.geometry.index,o=this.geometry.attributes.position,u=this.indirect?g=>{const A=this.resolveTriangleIndex(g);H(c,A*3,a,o)}:g=>{H(c,g*3,a,o)},l=ht.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?g=>{const A=t.resolveTriangleIndex(g);H(l,A*3,d,f)}:g=>{H(l,g*3,d,f)};if(r){const g=(A,w,p,m,y,x,b,S)=>{for(let T=p,M=p+m;T<M;T++){h(T),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let _=A,P=A+w;_<P;_++)if(u(_),c.needsUpdate=!0,r(c,l,_,T,y,x,b,S))return!0}return!1};if(i){const A=i;i=function(w,p,m,y,x,b,S,T){return A(w,p,m,y,x,b,S,T)?!0:g(w,p,m,y,x,b,S,T)}}else i=g}return ec(this,t,e,i)}intersectsBox(t,e){return Rn.set(t.min,t.max,e),Rn.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Rn.intersectsBox(n),intersectsTriangle:n=>Rn.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},i={},r=0,c=1/0){return(this.indirect?Qa:Ga)(this,t,e,n,i,r,c)}closestPointToPoint(t,e={},n=0,i=1/0){return _a(this,t,e,n,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{$(0,new Float32Array(n),Ki),t.union(Ki)}),t}}const $r=1e-6,sc=$r*.5,Gr=Math.pow(10,-Math.log10($r)),ic=sc*Gr;function vt(s){return~~(s*Gr+ic)}function rc(s){return`${vt(s.x)},${vt(s.y)}`}function Yi(s){return`${vt(s.x)},${vt(s.y)},${vt(s.z)}`}function oc(s){return`${vt(s.x)},${vt(s.y)},${vt(s.z)},${vt(s.w)}`}function ac(s,t,e){e.direction.subVectors(t,s).normalize();const n=s.dot(e.direction);return e.origin.copy(s).addScaledVector(e.direction,-n),e}function Hr(){return typeof SharedArrayBuffer<"u"}function cc(s){if(s.buffer instanceof SharedArrayBuffer)return s;const t=s.constructor,e=s.buffer,n=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(n).set(i,0),new t(n)}function lc(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function uc(s,t){if(!s.index){const e=s.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=lc(e,n);s.setIndex(new ss(i,1));for(let r=0;r<e;r++)i[r]=r}}function fc(s){return s.index?s.index.count:s.attributes.position.count}function ri(s){return fc(s)/3}const dc=1e-8,pc=new I;function hc(s){return~~(s/3)}function gc(s){return s%3}function Ji(s,t){return s.start-t.start}function Qi(s,t){return pc.subVectors(t,s.origin).dot(s.direction)}function mc(s,t,e,n=dc){s.sort(Ji),t.sort(Ji);for(let a=0;a<s.length;a++){const o=s[a];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>o.end)){if(o.end<l.start||l.end<o.start)continue;if(o.start<=l.start&&o.end>=l.end)r(l.end,o.end)||s.splice(a+1,0,{start:l.end,end:o.end,index:o.index}),o.end=l.start,l.start=0,l.end=0;else if(o.start>=l.start&&o.end<=l.end)r(o.end,l.end)||t.splice(u+1,0,{start:o.end,end:l.end,index:l.index}),l.end=o.start,o.start=0,o.end=0;else if(o.start<=l.start&&o.end<=l.end){const d=o.end;o.end=l.start,l.start=d}else if(o.start>=l.start&&o.end>=l.end){const d=l.end;l.end=o.start,o.start=d}else throw new Error}if(e.has(o.index)||e.set(o.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(o.index).push(l.index),e.get(l.index).push(o.index),c(l)&&(t.splice(u,1),u--),c(o)){s.splice(a,1),a--;break}}}i(s),i(t);function i(a){for(let o=0;o<a.length;o++)c(a[o])&&(a.splice(o,1),o--)}function r(a,o){return Math.abs(o-a)<n}function c(a){return Math.abs(a.end-a.start)<n}}const tr=1e-5,er=1e-4;class wc{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let i=1/0,r=null;for(let o=0,u=e.length;o<u;o++){const l=e[o];if(c(l,t)&&c(l,n))continue;const d=a(l,t),f=a(l,n),h=Math.min(d,f);h<i&&(i=h,r=l)}return r;function c(o,u){const l=o.origin.distanceTo(u.origin)>tr;return o.direction.angleTo(u.direction)>er||l}function a(o,u){const l=o.origin.distanceTo(u.origin),d=o.direction.angleTo(u.direction);return l/tr+d/er}}}const Es=new I,Cs=new I,Vn=new xr;function yc(s,t,e){const n=s.attributes,i=s.index,r=n.position,c=new Map,a=new Map,o=Array.from(t),u=new wc;for(let l=0,d=o.length;l<d;l++){const f=o[l],h=hc(f),g=gc(f);let A=3*h+g,w=3*h+(g+1)%3;i&&(A=i.getX(A),w=i.getX(w)),Es.fromBufferAttribute(r,A),Cs.fromBufferAttribute(r,w),ac(Es,Cs,Vn);let p,m=u.findClosestRay(Vn);m===null&&(m=Vn.clone(),u.addRay(m)),a.has(m)||a.set(m,{forward:[],reverse:[],ray:m}),p=a.get(m);let y=Qi(m,Es),x=Qi(m,Cs);y>x&&([y,x]=[x,y]),Vn.direction.dot(m.direction)<0?p.reverse.push({start:y,end:x,index:f}):p.forward.push({start:y,end:x,index:f})}return a.forEach(({forward:l,reverse:d},f)=>{mc(l,d,c,e),l.length===0&&d.length===0&&a.delete(f)}),{disjointConnectivityMap:c,fragmentMap:a}}const xc=new ue,zs=new I,bc=new de,Rs=["","",""];class Ac{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,i=this.disjointConnections.get(n);return i?i.map(r=>~~(r/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,i=this.disjointConnections.get(n);return i?i.map(r=>r%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:i,degenerateEpsilon:r}=this,c=e?y:m,a=new Map,{attributes:o}=t,u=e?Object.keys(o):null,l=t.index,d=o.position;let f=ri(t);const h=f;let g=0;n&&(g=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let A=this.data;(!A||A.length<3*h)&&(A=new Int32Array(3*h)),A.fill(-1);let w=0,p=new Set;for(let x=g,b=f*3+g;x<b;x+=3){const S=x;for(let T=0;T<3;T++){let M=S+T;l&&(M=l.getX(M)),Rs[T]=c(M)}for(let T=0;T<3;T++){const M=(T+1)%3,_=Rs[T],P=Rs[M],v=`${P}_${_}`;if(a.has(v)){const B=S+T,L=a.get(v);A[B]=L,A[L]=B,a.delete(v),w+=2,p.delete(L)}else{const B=`${_}_${P}`,L=S+T;a.set(B,L),p.add(L)}}}if(i){const{fragmentMap:x,disjointConnectivityMap:b}=yc(t,p,r);p.clear(),x.forEach(({forward:S,reverse:T})=>{S.forEach(({index:M})=>p.add(M)),T.forEach(({index:M})=>p.add(M))}),this.unmatchedDisjointEdges=x,this.disjointConnections=b,w=f*3-p.size}this.matchedEdges=w,this.unmatchedEdges=p.size,this.data=A;function m(x){return zs.fromBufferAttribute(d,x),Yi(zs)}function y(x){let b="";for(let S=0,T=u.length;S<T;S++){const M=o[u[S]];let _;switch(M.itemSize){case 1:_=vt(M.getX(x));break;case 2:_=rc(xc.fromBufferAttribute(M,x));break;case 3:_=Yi(zs.fromBufferAttribute(M,x));break;case 4:_=oc(bc.fromBufferAttribute(M,x));break}b!==""&&(b+="|"),b+=_}return b}}}class it extends k{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new It,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,i=e.elements;for(let r=0;r<16;r++)if(n[r]!==i[r])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=Hr();if(n)for(const i in e){const r=e[i];if(r.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");r.array=cc(r.array)}if(t.boundsTree||(uc(t,{useSharedArrayBuffer:n}),t.boundsTree=new ii(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Ac(t)),!t.groupIndices){const i=ri(t),r=new Uint16Array(i),c=t.groups;for(let a=0,o=c.length;a<o;a++){const{start:u,count:l}=c[a];for(let d=u/3,f=(u+l)/3;d<f;d++)r[d]=a}t.groupIndices=r}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Tc=1e-14,Vs=new I,nr=new I,sr=new I;function Kt(s,t=Tc){Vs.subVectors(s.b,s.a),nr.subVectors(s.c,s.a),sr.subVectors(s.b,s.c);const e=Vs.angleTo(nr),n=Vs.angleTo(sr),i=Math.PI-e-n;return Math.abs(e)<t||Math.abs(n)<t||Math.abs(i)<t||s.a.distanceToSquared(s.b)<t||s.a.distanceToSquared(s.c)<t||s.b.distanceToSquared(s.c)<t}const Ns=1e-10,Ze=1e-10,Sc=1e-10,zt=new gt,G=new gt,Rt=new I,Fs=new I,ir=new I,Nn=new ti,Us=new mt;class Mc{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new nt),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class _c{constructor(){this.trianglePool=new Mc,this.triangles=[],this.normal=new I,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:i}=this;if(Array.isArray(t))for(let r=0,c=t.length;r<c;r++){const a=t[r];if(r===0)a.getNormal(i);else if(Math.abs(1-a.getNormal(Rt).dot(i))>Ns)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const o=n.getTriangle();o.copy(a),e.push(o)}else{t.getNormal(i);const r=n.getTriangle();r.copy(t),e.push(r)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(Fs).normalize(),Math.abs(1-Math.abs(Fs.dot(e)))<Sc){this.coplanarTriangleUsed=!0;for(let r=0,c=n.length;r<c;r++){const a=n[r];a.coplanarCount=0}const i=[t.a,t.b,t.c];for(let r=0;r<3;r++){const c=(r+1)%3,a=i[r],o=i[c];Rt.subVectors(o,a).normalize(),ir.crossVectors(Fs,Rt),Nn.setFromNormalAndCoplanarPoint(ir,a),this.splitByPlane(Nn,t)}}else t.getPlane(Nn),this.splitByPlane(Nn,t)}splitByPlane(t,e){const{triangles:n,trianglePool:i}=this;Us.copy(e),Us.needsUpdate=!0;for(let r=0,c=n.length;r<c;r++){const a=n[r];if(!Us.intersectsTriangle(a,zt,!0))continue;const{a:o,b:u,c:l}=a;let d=0,f=-1,h=!1,g=[],A=[];const w=[o,u,l];for(let p=0;p<3;p++){const m=(p+1)%3;zt.start.copy(w[p]),zt.end.copy(w[m]);const y=t.distanceToPoint(zt.start),x=t.distanceToPoint(zt.end);if(Math.abs(y)<Ze&&Math.abs(x)<Ze){h=!0;break}if(y>0?g.push(p):A.push(p),Math.abs(y)<Ze)continue;let b=!!t.intersectLine(zt,Rt);!b&&Math.abs(x)<Ze&&(Rt.copy(zt.end),b=!0),b&&!(Rt.distanceTo(zt.start)<Ns)&&(Rt.distanceTo(zt.end)<Ns&&(f=p),d===0?G.start.copy(Rt):G.end.copy(Rt),d++)}if(!h&&d===2&&G.distance()>Ze)if(f!==-1){f=(f+1)%3;let p=0;p===f&&(p=(p+1)%3);let m=p+1;m===f&&(m=(m+1)%3);const y=i.getTriangle();y.a.copy(w[m]),y.b.copy(G.end),y.c.copy(G.start),Kt(y)||n.push(y),a.a.copy(w[p]),a.b.copy(G.start),a.c.copy(G.end),Kt(a)&&(n.splice(r,1),r--,c--)}else{const p=g.length>=2?A[0]:g[0];if(p===0){let S=G.start;G.start=G.end,G.end=S}const m=(p+1)%3,y=(p+2)%3,x=i.getTriangle(),b=i.getTriangle();w[m].distanceToSquared(G.start)<w[y].distanceToSquared(G.end)?(x.a.copy(w[m]),x.b.copy(G.start),x.c.copy(G.end),b.a.copy(w[m]),b.b.copy(w[y]),b.c.copy(G.start)):(x.a.copy(w[y]),x.b.copy(G.start),x.c.copy(G.end),b.a.copy(w[m]),b.b.copy(w[y]),b.c.copy(G.end)),a.a.copy(w[p]),a.b.copy(G.end),a.c.copy(G.start),Kt(x)||n.push(x),Kt(b)||n.push(b),Kt(a)&&(n.splice(r,1),r--,c--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function Bc(s){return s=~~s,s+4-s%4}class rr{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=Hr()?SharedArrayBuffer:ArrayBuffer,i=new e(new n(Bc(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,r=t.length;i<r;i++)e[n+i]=t[i];this.length+=t.length}clear(){this.length=0}}class Pc{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let i=0;for(let r=0;r<e;r++){const c=n[r];i+=c[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const r in n){const c=n[r],a=new rr(c.type);a.itemSize=c.itemSize,a.normalized=c.normalized,i[r]=a}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,i){const{groupAttributes:r}=this,a=r[0][t];if(a){if(a.type!==e)for(let o=0,u=r.length;o<u;o++){const l=r[o][t];l.setType(e),l.itemSize=n,l.normalized=i}}else for(let o=0,u=r.length;o<u;o++){const l=new rr(e);l.itemSize=n,l.normalized=i,r[o][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const n in e)e[n].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class or{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:i}=this;n[t]||(n[t]=[],i.push(t)),n[t].push(e)}}const $t=0,oi=1,Lc=2,vc=3,Ic=4,Or=5,Wr=6,ut=new xr,ar=new It,Z=new nt,Vt=new I,cr=new de,lr=new de,ur=new de,ks=new de,Fn=new de,Un=new de,fr=new gt,js=new I,Ds=1e-8,Ec=1e-15,oe=-1,ae=1,$n=-2,Gn=2,Qe=0,ie=1,ai=2,Cc=1e-14;let Hn=null;function dr(s){Hn=s}function Xr(s,t){s.getMidpoint(ut.origin),s.getNormal(ut.direction);const e=t.raycastFirst(ut,ei);return!!(e&&ut.direction.dot(e.face.normal)>0)?oe:ae}function zc(s,t){function e(){return Math.random()-.5}s.getNormal(js),ut.direction.copy(js),s.getMidpoint(ut.origin);const n=3;let i=0,r=1/0;for(let c=0;c<n;c++){ut.direction.x+=e()*Ds,ut.direction.y+=e()*Ds,ut.direction.z+=e()*Ds,ut.direction.multiplyScalar(-1);const a=t.raycastFirst(ut,ei);if(!!(a&&ut.direction.dot(a.face.normal)>0)&&i++,a!==null&&(r=Math.min(r,a.distance)),r<=Ec)return a.face.normal.dot(js)>0?Gn:$n;if(i/n>.5||(c-i+1)/n>.5)break}return i/n>.5?oe:ae}function Rc(s,t){const e=new or,n=new or;return ar.copy(s.matrixWorld).invert().multiply(t.matrixWorld),s.geometry.boundsTree.bvhcast(t.geometry.boundsTree,ar,{intersectsTriangles(i,r,c,a){if(!Kt(i)&&!Kt(r)){let o=i.intersectsTriangle(r,fr,!0);if(!o){const u=i.plane,l=r.plane,d=u.normal,f=l.normal;d.dot(f)===1&&Math.abs(u.constant-l.constant)<Cc&&(o=!0)}if(o){let u=s.geometry.boundsTree.resolveTriangleIndex(c),l=t.geometry.boundsTree.resolveTriangleIndex(a);e.add(u,l),n.add(l,u),Hn&&(Hn.addEdge(fr),Hn.addIntersectingTriangles(c,i,a,r))}}return!1}}),{aIntersections:e,bIntersections:n}}function Vc(s,t,e,n,i,r,c=!1){const a=e.attributes,o=e.index,u=s*3,l=o.getX(u+0),d=o.getX(u+1),f=o.getX(u+2);for(const h in r){const g=a[h],A=r[h];if(!(h in a))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const w=g.itemSize;h==="position"?(Z.a.fromBufferAttribute(g,l).applyMatrix4(n),Z.b.fromBufferAttribute(g,d).applyMatrix4(n),Z.c.fromBufferAttribute(g,f).applyMatrix4(n),$s(Z.a,Z.b,Z.c,t,3,A,c)):h==="normal"?(Z.a.fromBufferAttribute(g,l).applyNormalMatrix(i),Z.b.fromBufferAttribute(g,d).applyNormalMatrix(i),Z.c.fromBufferAttribute(g,f).applyNormalMatrix(i),c&&(Z.a.multiplyScalar(-1),Z.b.multiplyScalar(-1),Z.c.multiplyScalar(-1)),$s(Z.a,Z.b,Z.c,t,3,A,c,!0)):(cr.fromBufferAttribute(g,l),lr.fromBufferAttribute(g,d),ur.fromBufferAttribute(g,f),$s(cr,lr,ur,t,w,A,c))}}function Nc(s,t,e,n,i,r,c,a=!1){Gs(s,n,i,r,c,a),Gs(a?e:t,n,i,r,c,a),Gs(a?t:e,n,i,r,c,a)}function qr(s,t,e=!1){switch(s){case $t:if(t===ae||t===Gn&&!e)return ie;break;case oi:if(e){if(t===oe)return Qe}else if(t===ae||t===$n)return ie;break;case Lc:if(e){if(t===ae||t===$n)return ie}else if(t===oe)return Qe;break;case Ic:if(t===oe)return Qe;if(t===ae)return ie;break;case vc:if(t===oe||t===Gn&&!e)return ie;break;case Or:if(!e&&(t===ae||t===$n))return ie;break;case Wr:if(!e&&(t===oe||t===Gn))return ie;break;default:throw new Error(`Unrecognized CSG operation enum "${s}".`)}return ai}function $s(s,t,e,n,i,r,c=!1,a=!1){const o=u=>{r.push(u.x),i>1&&r.push(u.y),i>2&&r.push(u.z),i>3&&r.push(u.w)};ks.set(0,0,0,0).addScaledVector(s,n.a.x).addScaledVector(t,n.a.y).addScaledVector(e,n.a.z),Fn.set(0,0,0,0).addScaledVector(s,n.b.x).addScaledVector(t,n.b.y).addScaledVector(e,n.b.z),Un.set(0,0,0,0).addScaledVector(s,n.c.x).addScaledVector(t,n.c.y).addScaledVector(e,n.c.z),a&&(ks.normalize(),Fn.normalize(),Un.normalize()),o(ks),c?(o(Un),o(Fn)):(o(Fn),o(Un))}function Gs(s,t,e,n,i,r=!1){for(const c in i){const a=t[c],o=i[c];if(!(c in t))throw new Error(`CSG Operations: Attribute ${c} no available on geometry.`);const u=a.itemSize;c==="position"?(Vt.fromBufferAttribute(a,s).applyMatrix4(e),o.push(Vt.x,Vt.y,Vt.z)):c==="normal"?(Vt.fromBufferAttribute(a,s).applyNormalMatrix(n),r&&Vt.multiplyScalar(-1),o.push(Vt.x,Vt.y,Vt.z)):(o.push(a.getX(s)),u>1&&o.push(a.getY(s)),u>2&&o.push(a.getZ(s)),u>3&&o.push(a.getW(s)))}}class Fc{constructor(t){this.triangle=new nt().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new nt().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class pr{constructor(){this.data={}}addTriangleIntersection(t,e,n,i){const{data:r}=this;r[t]||(r[t]=new Fc(e)),r[t].addTriangle(n,i)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const i in e)n.push(e[i].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,i=new Set,r=[],c=a=>{if(n[a])if(e!==null)n[a].intersects[e]&&r.push(n[a].intersects[e]);else{const o=n[a].intersects;for(const u in o)i.has(u)||(i.add(u),r.push(o[u]))}};if(t!==null)c(t);else for(const a in n)c(a);return r}reset(){this.data={}}}class Uc{constructor(){this.enabled=!1,this.triangleIntersectsA=new pr,this.triangleIntersectsB=new pr,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,i){const{triangleIntersectsA:r,triangleIntersectsB:c}=this;r.addTriangleIntersection(t,e,n,i),c.addTriangleIntersection(n,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),dr(this))}complete(){this.enabled&&dr(null)}}const Jt=new It,Wn=new $o,re=new nt,kn=new nt,qt=new nt,jn=new nt,Tt=[],le=[];function kc(s){for(const t of s)return t}function jc(s,t,e,n,i,r={}){const{useGroups:c=!0}=r,{aIntersections:a,bIntersections:o}=Rc(s,t),u=[];let l=null,d;return d=c?0:-1,hr(s,t,a,e,!1,n,i,d),gr(s,t,a,e,!1,i,d),e.findIndex(h=>h!==Wr&&h!==Or)!==-1&&(d=c?s.geometry.groups.length||1:-1,hr(t,s,o,e,!0,n,i,d),gr(t,s,o,e,!0,i,d)),Tt.length=0,le.length=0,{groups:u,materials:l}}function hr(s,t,e,n,i,r,c,a=0){const o=s.matrixWorld.determinant()<0;Jt.copy(t.matrixWorld).invert().multiply(s.matrixWorld),Wn.getNormalMatrix(s.matrixWorld).multiplyScalar(o?-1:1);const u=s.geometry.groupIndices,l=s.geometry.index,d=s.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,g=t.geometry.attributes.position,A=e.ids,w=e.intersectionSet;for(let p=0,m=A.length;p<m;p++){const y=A[p],x=a===-1?0:u[y]+a,b=3*y,S=l.getX(b+0),T=l.getX(b+1),M=l.getX(b+2);re.a.fromBufferAttribute(d,S).applyMatrix4(Jt),re.b.fromBufferAttribute(d,T).applyMatrix4(Jt),re.c.fromBufferAttribute(d,M).applyMatrix4(Jt),r.reset(),r.initialize(re);const _=w[y];for(let v=0,B=_.length;v<B;v++){const L=3*_[v],E=h.getX(L+0),C=h.getX(L+1),N=h.getX(L+2);kn.a.fromBufferAttribute(g,E),kn.b.fromBufferAttribute(g,C),kn.c.fromBufferAttribute(g,N),r.splitByTriangle(kn)}const P=r.triangles;for(let v=0,B=P.length;v<B;v++){const L=P[v],E=r.coplanarTriangleUsed?zc(L,f):Xr(L,f);Tt.length=0,le.length=0;for(let C=0,N=n.length;C<N;C++){const q=qr(n[C],E,i);q!==ai&&(le.push(q),Tt.push(c[C].getGroupAttrSet(x)))}if(Tt.length!==0){re.getBarycoord(L.a,jn.a),re.getBarycoord(L.b,jn.b),re.getBarycoord(L.c,jn.c);for(let C=0,N=Tt.length;C<N;C++){const q=Tt[C],se=le[C]===Qe;Vc(y,jn,s.geometry,s.matrixWorld,Wn,q,o!==se)}}}}return A.length}function gr(s,t,e,n,i,r,c=0){const a=s.matrixWorld.determinant()<0;Jt.copy(t.matrixWorld).invert().multiply(s.matrixWorld),Wn.getNormalMatrix(s.matrixWorld).multiplyScalar(a?-1:1);const o=t.geometry.boundsTree,u=s.geometry.groupIndices,l=s.geometry.index,d=s.geometry.attributes,f=d.position,h=[],g=s.geometry.halfEdges,A=new Set,w=ri(s.geometry);for(let p=0,m=w;p<m;p++)p in e.intersectionSet||A.add(p);for(;A.size>0;){const p=kc(A);A.delete(p),h.push(p);const m=3*p,y=l.getX(m+0),x=l.getX(m+1),b=l.getX(m+2);qt.a.fromBufferAttribute(f,y).applyMatrix4(Jt),qt.b.fromBufferAttribute(f,x).applyMatrix4(Jt),qt.c.fromBufferAttribute(f,b).applyMatrix4(Jt);const S=Xr(qt,o);le.length=0,Tt.length=0;for(let T=0,M=n.length;T<M;T++){const _=qr(n[T],S,i);_!==ai&&(le.push(_),Tt.push(r[T]))}for(;h.length>0;){const T=h.pop();for(let M=0;M<3;M++){const _=g.getSiblingTriangleIndex(T,M);_!==-1&&A.has(_)&&(h.push(_),A.delete(_))}if(Tt.length!==0){const M=3*T,_=l.getX(M+0),P=l.getX(M+1),v=l.getX(M+2),B=c===-1?0:u[T]+c;if(qt.a.fromBufferAttribute(f,_),qt.b.fromBufferAttribute(f,P),qt.c.fromBufferAttribute(f,v),!Kt(qt))for(let L=0,E=Tt.length;L<E;L++){const C=le[L],N=Tt[L].getGroupAttrSet(B),q=C===Qe;Nc(_,P,v,d,s.matrixWorld,Wn,N,q!==a)}}}}}function Dc(s){for(let t=0;t<s.length-1;t++){const e=s[t],n=s[t+1];if(e.materialIndex===n.materialIndex){const i=e.start,r=n.start+n.count;n.start=i,n.count=r-i,s.splice(t,1),t--}}}function $c(s,t,e,n){e.clear();const i=s.attributes;for(let r=0,c=n.length;r<c;r++){const a=n[r],o=i[a];e.initializeArray(a,o.array.constructor,o.itemSize,o.normalized)}for(const r in e.attributes)n.includes(r)||e.delete(r);for(const r in t.attributes)n.includes(r)||(t.deleteAttribute(r),t.dispose())}function Gc(s,t,e){let n=!1,i=-1;const r=s.attributes,c=t.groupAttributes[0];for(const o in c){const u=t.getTotalLength(o),l=t.getType(o),d=t.getItemSize(o),f=t.getNormalized(o);let h=r[o];(!h||h.array.length<u)&&(h=new ss(new l(u),d,f),s.setAttribute(o,h),n=!0);let g=0;for(let A=0,w=Math.min(e.length,t.groupCount);A<w;A++){const p=e[A].index,{array:m,type:y,length:x}=t.groupAttributes[p][o],b=new y(m.buffer,0,x);h.array.set(b,g),g+=b.length}h.needsUpdate=!0,i=u/h.itemSize}if(s.index){const o=s.index.array;if(o.length<i)s.index=null,n=!0;else for(let u=0,l=o.length;u<l;u++)o[u]=u}let a=0;s.clearGroups();for(let o=0,u=Math.min(e.length,t.groupCount);o<u;o++){const{index:l,materialIndex:d}=e[o],f=t.getCount(l);f!==0&&(s.addGroup(a,f,d),a+=f)}s.setDrawRange(0,i),s.boundsTree=null,n&&s.dispose()}function mr(s,t){let e=t;return Array.isArray(t)||(e=[],s.forEach(n=>{e[n.materialIndex]=t})),e}class Zr{constructor(){this.triangleSplitter=new _c,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Uc}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,n,i=new it){let r=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(i)||(i=[i],r=!1),i.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:c,attributeData:a,attributes:o,useGroups:u,consolidateGroups:l,debug:d}=this;for(;a.length<i.length;)a.push(new Pc);i.forEach((p,m)=>{$c(t.geometry,p.geometry,a[m],o)}),d.init(),jc(t,e,n,c,a,{useGroups:u}),d.complete();const f=this.getGroupRanges(t.geometry),h=mr(f,t.material),g=this.getGroupRanges(e.geometry),A=mr(g,e.material);g.forEach(p=>p.materialIndex+=h.length);let w=[...f,...g].map((p,m)=>({...p,index:m}));if(u){const p=[...h,...A];l&&(w=w.map(y=>{const x=p[y.materialIndex];return y.materialIndex=p.indexOf(x),y}).sort((y,x)=>y.materialIndex-x.materialIndex));const m=[];for(let y=0,x=p.length;y<x;y++){let b=!1;for(let S=0,T=w.length;S<T;S++){const M=w[S];M.materialIndex===y&&(b=!0,M.materialIndex=m.length)}b&&m.push(p[y])}i.forEach(y=>{y.material=m})}else w=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(p=>{p.material=h[0]});return i.forEach((p,m)=>{const y=p.geometry;Gc(y,a[m],w),l&&Dc(y.groups)}),r?i:i[0]}evaluateHierarchy(t,e=new it){t.updateMatrixWorld(!0);const n=(r,c)=>{const a=r.children;for(let o=0,u=a.length;o<u;o++){const l=a[o];l.isOperationGroup?n(l,c):c(l)}},i=r=>{const c=r.children;let a=!1;for(let u=0,l=c.length;u<l;u++){const d=c[u];a=i(d)||a}const o=r.isDirty();if(o&&r.markUpdated(),a&&!r.isOperationGroup){let u;return n(r,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(r,l,l.operation)}),r._cachedGeometry=u.geometry,r._cachedMaterials=u.material,!0}else return a||o};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const Hc=te({title:"Shelf Texture"}),Ue=new Ve(Hc),en=Ue.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_COL_1K_METALNESS.png");en.colorSpace=tn;const nn=Ue.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_NRM_1K_METALNESS.png"),sn=Ue.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_AO_1K_METALNESS.png"),rn=Ue.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_ROUGHNESS_1K_METALNESS.png"),on=Ue.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_METALNESS_1K_METALNESS.png"),an=Ue.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_DISP_1K_METALNESS.png");en.wrapS=en.wrapT=nn.wrapS=nn.wrapT=sn.wrapS=sn.wrapT=rn.wrapS=rn.wrapT=on.wrapS=on.wrapT=an.wrapS=an.wrapT=z;const wt=.3;en.repeat.set(wt,wt);nn.repeat.set(wt,wt);sn.repeat.set(wt,wt);rn.repeat.set(wt,wt);on.repeat.set(wt,wt);an.repeat.set(wt,wt);const Oc=te({title:"Window texture"}),ke=new Ve(Oc),ci=ke.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-albedo.png");ci.colorSpace=tn;const os=ke.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Normal-dx.png"),as=ke.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-ao.png"),cs=ke.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Roughness.png"),ls=ke.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Metallic.png"),li=ke.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Height.png");ci.wrapS=z;ci.wrapT=z;os.wrapS=z;os.wrapT=z;as.wrapS=z;as.wrapT=z;cs.wrapS=z;cs.wrapT=z;ls.wrapS=z;ls.wrapT=z;li.wrapS=z;li.wrapT=z;const{frameThickness:ui,frameWidthOuter:Kr,frameHeightOuter:Yr,slatWidth:Ce,x:Wc,y:Xc,frameWidthInner:Jr,frameHeightInner:Qr}=ce,yt=new Mt({roughness:.1,metalness:.6,wireframe:_t,color:16777215}),to=new it(new ts(Kr,Yr,ui),yt);to.updateMatrixWorld();const eo=new it(new ts(Jr,Qr,ui),yt);eo.updateMatrixWorld();const mn=new Zr,qc=mn.evaluate(to,eo,oi),fi=new it(new R(Jr+1,Ce*2,Ce*2,V.roundSegments,V.roundRadius/2),yt);fi.position.set(0,-2.2,0);fi.updateMatrixWorld();const di=new it(new R(.6,Qr+1,.6,V.roundSegments,V.roundRadius/2),yt);di.position.set(0,0,0);di.updateMatrixWorld();let cn=mn.evaluate(fi,di,$t);const pi=new it(new R(Ce,13.4,Ce,V.roundSegments,V.roundRadius/2),yt);pi.position.set(-8.2,4.6,0);pi.updateMatrixWorld();cn=mn.evaluate(cn,pi,$t);const hi=new it(new R(Ce,13.4,Ce,V.roundSegments,V.roundRadius/2),yt);hi.position.set(8.2,4.6,0);hi.updateMatrixWorld();cn=mn.evaluate(cn,hi,$t);const gi=mn.evaluate(qc,cn,$t);gi.position.set(Kr/2+Wc,Yr/2+Xc,-(V.wallThickness-ui/2));gi.updateMatrixWorld();yt.normalMap=os;yt.aoMap=as;yt.roughnessMap=cs;yt.metalnessMap=ls;yt.displacementMap=li;yt.displacementScale=.01;const{floorXLength:xt,floorZLength:bt,wallHeight:Gt,wallThickness:D,roundRadius:pe,roundSegments:he,ny:Zc}=V,wn=new Zr,Kc=te({title:"Wall texture"}),mi=new Ve(Kc),Xn=mi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_albedo.png"),qn=mi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_normal-ogl.png"),Zn=mi.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_ao.png");Xn.repeat.set(2,2);qn.repeat.set(2,2);Zn.repeat.set(2,2);Xn.wrapS=Xn.wrapT=z;qn.wrapS=qn.wrapT=z;Zn.wrapS=Zn.wrapT=z;const je=new Mt({roughness:1,metalness:0,wireframe:_t});je.map=Xn;je.normalMap=qn;je.aoMap=Zn;const wi=new Mt({roughness:1,metalness:0,wireframe:_t,transparent:!0,opacity:0}),Yc=new R(xt+1,D,bt+1,he,pe),Jc=te({title:"Floor texture"}),us=new Ve(Jc),Qc=new Mt({roughness:1,metalness:0,wireframe:_t});let ln=new it(Yc,Qc);ln.position.set(xt/2-1/2,-D/2,bt/2-1/2);ln.updateMatrixWorld();const tl=new R(xt+1,.4,bt+1,he,pe),un=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DIFFUSE-1K.png"),fn=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-NORMALS16_OPENGL-1K.png"),dn=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DISPLACEMENT16-1K.png"),pn=us.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-ROUGHNESS-1K.png");un.wrapS=un.wrapT=fn.wrapS=fn.wrapT=dn.wrapS=dn.wrapT=pn.wrapS=pn.wrapT=z;un.rotation=fn.rotation=dn.rotation=pn.rotation=Math.PI/2;un.repeat.set(1.3,1.3);fn.repeat.set(1.3,1.3);dn.repeat.set(1.3,1.3);pn.repeat.set(1.3,1.3);const el=new Mt({wireframe:_t,map:un,normalMap:fn,displacementMap:dn,displacementScale:.001,roughnessMap:pn}),yi=new it(tl,el);yi.position.set(xt/2-1/2,-.199,bt/2-1/2);yi.updateMatrixWorld();ln=wn.evaluate(yi,ln,$t);const nl=new R(D,Gt,bt+1,he,pe),xi=new it(nl,je);xi.position.set(-D/2,Gt/2-D,bt/2-1/2);xi.updateMatrixWorld();const sl=new R(xt+D,Gt,D,he,pe),bi=new it(sl,je);bi.position.set(xt/2-D/2,Gt/2-D,-D/2);bi.updateMatrixWorld();const il=new ts(ce.frameWidthOuter,ce.frameHeightOuter,D),Ai=new it(il,je);Ai.position.set(ce.frameWidthOuter/2+ce.x,ce.frameHeightOuter/2+ce.y,-D/2);Ai.updateMatrixWorld();const no=wn.evaluate(bi,Ai,oi);no.updateMatrixWorld();const fs=wn.evaluate(no,gi,$t);fs.receiveShadow=!0;fs.castShadow=!0;fs.updateMatrixWorld();const rl=new R(xt+D+.1,Gt,.1,he,pe),ds=new k(rl,wi);ds.position.set(xt/2-D/2,Gt/2-D,bt-.19);ds.receiveShadow=!0;ds.castShadow=!0;const ol=new R(.1,Gt,bt+D,he,pe),ps=new k(ol,wi);ps.position.set(xt+.1/2,Gt/2-D,bt/2-D/2);ps.receiveShadow=!0;ps.castShadow=!0;const al=new R(xt+D+.1,D,bt+D+.1,he,pe),hs=new k(al,wi);hs.position.set(xt/2-D/2,Gt-D/2,bt/2-D/2);hs.receiveShadow=!0;hs.castShadow=!0;const ge=new fe;ge.position.set(-xt/2,-Zc,-bt/2);let ze=wn.evaluate(xi,fs,$t);ze.updateMatrixWorld();ze=wn.evaluate(ze,ln,$t);ze.castShadow=!0;ze.receiveShadow=!0;ge.add(ze);ge.add(ds);ge.add(ps);ge.add(hs);U.add(ge);const Ti=new Go(ge);Ti.visible=!1;U.add(Ti);const cl=new Ho,so=()=>{Ii.begin(),St.clear(),Ti.update(),Ne.update();const s=cl.getDelta();xs.animating&&xs.update(s),St.render(U,Ee),xs.render(St),Ii.end(),requestAnimationFrame(so)},{floorXLength:ll,floorZLength:ul,ny:fl}=V,Si=new Oo(42);Si.position.set(-ll/2,-fl,-ul/2);Si.visible=!1;U.add(Si);const{floorXLength:dl,floorZLength:pl,ny:hl}=V,Mi=new fe;Mi.position.set(-dl/2,-hl,-pl/2);const gl=te({title:"Sofa"}),ml=new br(gl);ml.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/ikeaSofa.obj",s=>{s.scale.set(10,10,10),s.rotation.y=-Math.PI/2,s.position.set(33,0,15);const e=s.children[0],n=s.children[1];wr(e),wr(n);const i=te({title:"Sofa texture",onLoad:()=>{const h=new Mt({map:c,normalMap:a,aoMap:o,roughnessMap:u,wireframe:_t});e.material=h;const g=new Mt({map:l,normalMap:d,aoMap:f,color:5093036,wireframe:_t});n.material=g,Mi.add(s)}}),r=new Ve(i),c=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Color.jpg");c.colorSpace=tn,c.wrapS=z,c.wrapT=z;const a=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_NormalGL.jpg");a.wrapS=z,a.wrapT=z;const o=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_AmbientOcclusion.jpg");o.wrapS=z,o.wrapT=z;const u=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Roughness.jpg");u.wrapS=z,u.wrapT=z;const l=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_b.png");l.colorSpace=tn,l.wrapS=z,l.wrapT=z;const d=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_n.png");d.wrapS=z,d.wrapT=z;const f=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_o.png");f.wrapS=z,f.wrapT=z});const wr=s=>{s.castShadow=!0,s.receiveShadow=!0};U.add(Mi);const{floorXLength:wl,floorZLength:yl,ny:xl}=V,_i=new fe;_i.position.set(-wl/2,-xl,-yl/2);const bl=new R(22,.2,26,2,.5),Al=te({title:"Rug Texture"}),yn=new Ve(Al),hn=yn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_COLOR2.png");hn.colorSpace=tn;const Kn=yn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_DISP.png"),Yn=yn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_NRM.jpg"),Jn=yn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_OCC.jpg"),Qn=yn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_ROUGH.jpg");hn.wrapS=hn.wrapT=Kn.wrapS=Kn.wrapT=Yn.wrapS=Yn.wrapT=Jn.wrapS=Jn.wrapT=Qn.wrapS=Qn.wrapT=z;const Et=.44;hn.repeat.set(Et,Et);Kn.repeat.set(Et,Et);Yn.repeat.set(Et,Et);Jn.repeat.set(Et,Et);Qn.repeat.set(Et,Et);const io=new Mt({wireframe:_t,map:hn,displacementMap:Kn,displacementScale:.005,normalMap:Yn,aoMap:Jn,roughnessMap:Qn});io.normalScale.set(1.2,1.2);const gs=new k(bl,io);gs.position.set(28,.01,15);gs.receiveShadow=!0;gs.castShadow=!0;_i.add(gs);U.add(_i);const tt=18.2,rt=18.2,et=3.3,F=.37,X=.24,Pt=3.3,ot=3,at=.05,Tl={shelfWidth:tt,shelfHeight:rt,shelfDepth:et,shelfBorderBoardThickness:F,shelfBoardThickness:X,shelfInnerWidth:Pt,roundSegments:ot,roundRadius:at},{floorXLength:Sl,floorZLength:Ml,ny:_l}=V,J=new fe;J.position.set(-Sl/2+et/2,-_l+F/2+.1,-Ml/2+tt/2+2);const O=new Mt({wireframe:_t,map:en,normalMap:nn,aoMap:sn,roughnessMap:rn,metalnessMap:on,displacementMap:an,displacementScale:.006}),ro=new k(new R(et,rt,F,ot,at),O);ro.position.set(0,rt/2-F/2,-tt/2+F/2);const Bl=new k(new R(et,F,tt,ot,at),O),oo=new k(new R(et,X,tt,ot,at),O);oo.position.set(0,F+Pt,0);const ao=new k(new R(et,X,tt,ot,at),O);ao.position.set(0,F+Pt*2+X,0);const co=new k(new R(et,X,tt,ot,at),O);co.position.set(0,F+Pt*3+X*2,0);const lo=new k(new R(et,X,tt,ot,at),O);lo.position.set(0,F+Pt*4+X*3,0);const uo=new k(new R(et,F,tt,ot,at),O);uo.position.set(0,F+Pt*5+X*4,0);const fo=new k(new R(et,rt,X,ot,at),O);fo.position.set(0,rt/2-F/2,-tt/2+F/2+F+Pt);const po=new k(new R(et,rt,X,ot,at),O);po.position.set(0,rt/2-F/2,-tt/2+F/2+F+Pt*2+X);const ho=new k(new R(et,rt,X,ot,at),O);ho.position.set(0,rt/2-F/2,-tt/2+F/2+F+Pt*3+X*2);const go=new k(new R(et,rt,X,ot,at),O);go.position.set(0,rt/2-F/2,-tt/2+F/2+F+Pt*4+X*3);const mo=new k(new R(et,rt,F,ot,at),O);mo.position.set(0,rt/2-F/2,-tt/2+F/2+F+Pt*5+X*4);J.add(Bl);J.add(oo);J.add(ao);J.add(co);J.add(lo);J.add(uo);J.add(ro);J.add(fo);J.add(po);J.add(ho);J.add(go);J.add(mo);J.children.forEach(s=>{s.castShadow=!0,s.receiveShadow=!0});U.add(J);const{shelfWidth:Pl,shelfDepth:Ht,shelfBorderBoardThickness:W,shelfBoardThickness:Ot,shelfInnerWidth:me,roundSegments:ee,roundRadius:ne}=Tl,Wt=me*2+Ot+W*2,De=me*4+Ot*3+W*2,{floorXLength:Ll,floorZLength:vl,ny:Il}=V,Lt=new fe;Lt.position.set(-Ll/2+Ht/2,-Il+W/2+.1,-vl/2+Wt/2+2+Pl);const El=new k(new R(Ht,W,Wt,ee,ne),O),wo=new k(new R(Ht,Ot,Wt,ee,ne),O);wo.position.set(0,W+me,0);const yo=new k(new R(Ht,Ot,Wt,ee,ne),O);yo.position.set(0,W+me*2+Ot,0);const xo=new k(new R(Ht,Ot,Wt,ee,ne),O);xo.position.set(0,W+me*3+Ot*2,0);const bo=new k(new R(Ht,W,Wt,ee,ne),O);bo.position.set(0,W+me*4+Ot*3,0);const Ao=new k(new R(Ht,De,W,ee,ne),O);Ao.position.set(0,De/2-W/2,-Wt/2+W/2);const To=new k(new R(Ht,De,W,ee,ne),O);To.position.set(0,De/2-W/2,Wt/2-W/2);const So=new k(new R(Ht,De,Ot,ee,ne),O);So.position.set(0,De/2-W/2,-Wt/2+W/2+W+me);Lt.add(El);Lt.add(wo);Lt.add(yo);Lt.add(xo);Lt.add(bo);Lt.add(Ao);Lt.add(To);Lt.add(So);Lt.children.forEach(s=>{s.castShadow=!0,s.receiveShadow=!0});U.add(Lt);const{floorXLength:Cl,floorZLength:zl,ny:Rl}=V,Qs=new fe;Qs.position.set(-Cl/2,-Rl,-zl/2);const Vl=te({title:"Table"}),Nl=new br(Vl),yr=new Mt({wireframe:_t,color:16777215,normalMap:nn,aoMap:sn,roughnessMap:rn,metalnessMap:on,displacementMap:an,displacementScale:.002}),Fl=new Mt({wireframe:_t,color:16777215,normalMap:os,aoMap:as,roughnessMap:cs,metalnessMap:ls});Nl.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/table/ikea Kvistbro storage.obj",s=>{s.scale.set(12,10,12),s.position.set(22,0,15),s.children[73].material=yr,s.children[72].material=yr,s.children[73].castShadow=!0,s.children[73].receiveShadow=!0,s.children[72].castShadow=!0,s.children[72].receiveShadow=!0;for(let e=0;e<72;e++){const n=s.children[e];n.castShadow=!0,n.receiveShadow=!0,n.material=Fl}Qs.add(s),U.add(Qs)});so();Wo(Ie,Ee,St);gn.add(Ne,"autoRotate");

import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as v,aP as en,n as Qi,j as tr,m as er,a4 as Jn,_ as Ts,aQ as Gt,X as hn,U as Ss,Q as Me,aR as nr,a0 as Bs,a3 as mn,M as ee,S as sr,aS as ir,q as rr,aT as or,aU as ie,p as ar,aV as cr,o as nn,aW as sn,G as lr,P as ur,W as fr,aX as dr,O as pr,c as hr,J as rn,V as Dt,aY as Kn,aZ as et,a_ as X,ar as mr,v as lt,aq as at,a$ as gr,Y as Qn,ak as _s,b0 as mi,b1 as kt,b2 as yr,a as Se,b3 as wr,b as Ps,d as xr,A as br,s as gi,z as Ar,t as Tr,R as Ms,l as Sr}from"./index-FjJc5u6_.js";const le=new v;function q(i,t,e,n,s,r){const c=2*Math.PI*s/4,a=Math.max(r-2*s,0),o=Math.PI/4;le.copy(t),le[n]=0,le.normalize();const u=.5*c/(c+a),l=1-le.angleTo(i)/o;return Math.sign(le[e])===1?l*u:a/(c+a)+u+u*(1-l)}class ut extends en{constructor(t=1,e=1,n=1,s=2,r=.1){if(s=s*2+1,r=Math.min(t/2,e/2,n/2,r),super(1,1,1,s,s,s),s===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const a=new v,o=new v,u=new v(t,e,n).divideScalar(2).subScalar(r),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,m=new v,A=.5/s;for(let y=0,p=0;y<l.length;y+=3,p+=2)switch(a.fromArray(l,y),o.copy(a),o.x-=Math.sign(o.x)*A,o.y-=Math.sign(o.y)*A,o.z-=Math.sign(o.z)*A,o.normalize(),l[y+0]=u.x*Math.sign(a.x)+o.x*r,l[y+1]=u.y*Math.sign(a.y)+o.y*r,l[y+2]=u.z*Math.sign(a.z)+o.z*r,d[y+0]=o.x,d[y+1]=o.y,d[y+2]=o.z,Math.floor(y/h)){case 0:m.set(1,0,0),f[p+0]=q(m,o,"z","y",r,n),f[p+1]=1-q(m,o,"y","z",r,e);break;case 1:m.set(-1,0,0),f[p+0]=1-q(m,o,"z","y",r,n),f[p+1]=1-q(m,o,"y","z",r,e);break;case 2:m.set(0,1,0),f[p+0]=1-q(m,o,"x","z",r,t),f[p+1]=q(m,o,"z","x",r,n);break;case 3:m.set(0,-1,0),f[p+0]=1-q(m,o,"x","z",r,t),f[p+1]=1-q(m,o,"z","x",r,n);break;case 4:m.set(0,0,1),f[p+0]=1-q(m,o,"x","y",r,t),f[p+1]=1-q(m,o,"y","x",r,e);break;case 5:m.set(0,0,-1),f[p+0]=q(m,o,"x","y",r,t),f[p+1]=1-q(m,o,"y","x",r,e);break}}}const Br=/^[og]\s*(.+)?/,_r=/^mtllib /,Pr=/^usemtl /,Mr=/^usemap /,Is=/\s+/,Ls=new v,gn=new v,vs=new v,Es=new v,Z=new v,Ie=new Qi;function Ir(){const i={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(s,r){const c=this._finalize(!1);c&&(c.inherited||c.groupCount<=0)&&this.materials.splice(c.index,1);const a={index:this.materials.length,name:s||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:c!==void 0?c.smooth:this.smooth,groupStart:c!==void 0?c.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(o){const u={index:typeof o=="number"?o:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return u.clone=this.clone.bind(u),u}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(s){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),s&&this.materials.length>1)for(let c=this.materials.length-1;c>=0;c--)this.materials[c].groupCount<=0&&this.materials.splice(c,1);return s&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},n&&n.name&&typeof n.clone=="function"){const s=n.clone(0);s.inherited=!0,this.object.materials.push(s)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseNormalIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseUVIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/2)*2},addVertex:function(t,e,n){const s=this.vertices,r=this.object.geometry.vertices;r.push(s[t+0],s[t+1],s[t+2]),r.push(s[e+0],s[e+1],s[e+2]),r.push(s[n+0],s[n+1],s[n+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,n){const s=this.normals,r=this.object.geometry.normals;r.push(s[t+0],s[t+1],s[t+2]),r.push(s[e+0],s[e+1],s[e+2]),r.push(s[n+0],s[n+1],s[n+2])},addFaceNormal:function(t,e,n){const s=this.vertices,r=this.object.geometry.normals;Ls.fromArray(s,t),gn.fromArray(s,e),vs.fromArray(s,n),Z.subVectors(vs,gn),Es.subVectors(Ls,gn),Z.cross(Es),Z.normalize(),r.push(Z.x,Z.y,Z.z),r.push(Z.x,Z.y,Z.z),r.push(Z.x,Z.y,Z.z)},addColor:function(t,e,n){const s=this.colors,r=this.object.geometry.colors;s[t]!==void 0&&r.push(s[t+0],s[t+1],s[t+2]),s[e]!==void 0&&r.push(s[e+0],s[e+1],s[e+2]),s[n]!==void 0&&r.push(s[n+0],s[n+1],s[n+2])},addUV:function(t,e,n){const s=this.uvs,r=this.object.geometry.uvs;r.push(s[t+0],s[t+1]),r.push(s[e+0],s[e+1]),r.push(s[n+0],s[n+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,n,s,r,c,a,o,u){const l=this.vertices.length;let d=this.parseVertexIndex(t,l),f=this.parseVertexIndex(e,l),h=this.parseVertexIndex(n,l);if(this.addVertex(d,f,h),this.addColor(d,f,h),a!==void 0&&a!==""){const m=this.normals.length;d=this.parseNormalIndex(a,m),f=this.parseNormalIndex(o,m),h=this.parseNormalIndex(u,m),this.addNormal(d,f,h)}else this.addFaceNormal(d,f,h);if(s!==void 0&&s!==""){const m=this.uvs.length;d=this.parseUVIndex(s,m),f=this.parseUVIndex(r,m),h=this.parseUVIndex(c,m),this.addUV(d,f,h),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let n=0,s=t.length;n<s;n++){const r=this.parseVertexIndex(t[n],e);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const n=this.vertices.length,s=this.uvs.length;for(let r=0,c=t.length;r<c;r++)this.addVertexLine(this.parseVertexIndex(t[r],n));for(let r=0,c=e.length;r<c;r++)this.addUVLine(this.parseUVIndex(e[r],s))}};return i.startObject("",!1),i}class Lr extends tr{constructor(t){super(t),this.materials=null}load(t,e,n,s){const r=this,c=new er(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(t,function(a){try{e(r.parse(a))}catch(o){s?s(o):console.error(o),r.manager.itemError(t)}},n,s)}setMaterials(t){return this.materials=t,this}parse(t){const e=new Ir;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const n=t.split(`
`);let s=[];for(let a=0,o=n.length;a<o;a++){const u=n[a].trimStart();if(u.length===0)continue;const l=u.charAt(0);if(l!=="#")if(l==="v"){const d=u.split(Is);switch(d[0]){case"v":e.vertices.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3])),d.length>=7?(Ie.setRGB(parseFloat(d[4]),parseFloat(d[5]),parseFloat(d[6])).convertSRGBToLinear(),e.colors.push(Ie.r,Ie.g,Ie.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3]));break;case"vt":e.uvs.push(parseFloat(d[1]),parseFloat(d[2]));break}}else if(l==="f"){const f=u.slice(1).trim().split(Is),h=[];for(let A=0,y=f.length;A<y;A++){const p=f[A];if(p.length>0){const g=p.split("/");h.push(g)}}const m=h[0];for(let A=1,y=h.length-1;A<y;A++){const p=h[A],g=h[A+1];e.addFace(m[0],p[0],g[0],m[1],p[1],g[1],m[2],p[2],g[2])}}else if(l==="l"){const d=u.substring(1).trim().split(" ");let f=[];const h=[];if(u.indexOf("/")===-1)f=d;else for(let m=0,A=d.length;m<A;m++){const y=d[m].split("/");y[0]!==""&&f.push(y[0]),y[1]!==""&&h.push(y[1])}e.addLineGeometry(f,h)}else if(l==="p"){const f=u.slice(1).trim().split(" ");e.addPointGeometry(f)}else if((s=Br.exec(u))!==null){const d=(" "+s[0].slice(1).trim()).slice(1);e.startObject(d)}else if(Pr.test(u))e.object.startMaterial(u.substring(7).trim(),e.materialLibraries);else if(_r.test(u))e.materialLibraries.push(u.substring(7).trim());else if(Mr.test(u))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(l==="s"){if(s=u.split(" "),s.length>1){const f=s[1].trim().toLowerCase();e.object.smooth=f!=="0"&&f!=="off"}else e.object.smooth=!0;const d=e.object.currentMaterial();d&&(d.smooth=e.object.smooth)}else{if(u==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+u+'"')}}e.finalize();const r=new Jn;if(r.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let a=0,o=e.objects.length;a<o;a++){const u=e.objects[a],l=u.geometry,d=u.materials,f=l.type==="Line",h=l.type==="Points";let m=!1;if(l.vertices.length===0)continue;const A=new Ts;A.setAttribute("position",new Gt(l.vertices,3)),l.normals.length>0&&A.setAttribute("normal",new Gt(l.normals,3)),l.colors.length>0&&(m=!0,A.setAttribute("color",new Gt(l.colors,3))),l.hasUVIndices===!0&&A.setAttribute("uv",new Gt(l.uvs,2));const y=[];for(let g=0,w=d.length;g<w;g++){const x=d[g],b=x.name+"_"+x.smooth+"_"+m;let S=e.materials[b];if(this.materials!==null){if(S=this.materials.create(x.name),f&&S&&!(S instanceof hn)){const T=new hn;Ss.prototype.copy.call(T,S),T.color.copy(S.color),S=T}else if(h&&S&&!(S instanceof Me)){const T=new Me({size:10,sizeAttenuation:!1});Ss.prototype.copy.call(T,S),T.color.copy(S.color),T.map=S.map,S=T}}S===void 0&&(f?S=new hn:h?S=new Me({size:1,sizeAttenuation:!1}):S=new nr,S.name=x.name,S.flatShading=!x.smooth,S.vertexColors=m,e.materials[b]=S),y.push(S)}let p;if(y.length>1){for(let g=0,w=d.length;g<w;g++){const x=d[g];A.addGroup(x.groupStart,x.groupCount,g)}f?p=new Bs(A,y):h?p=new mn(A,y):p=new ee(A,y)}else f?p=new Bs(A,y[0]):h?p=new mn(A,y[0]):p=new ee(A,y[0]);p.name=u.name,r.add(p)}else if(e.vertices.length>0){const a=new Me({size:1,sizeAttenuation:!1}),o=new Ts;o.setAttribute("position",new Gt(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(o.setAttribute("color",new Gt(e.colors,3)),a.vertexColors=!0);const u=new mn(o,a);r.add(u)}return r}}const F=new sr,Be=!1,R={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},Ft={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},yi=new ir("#ffffff",.2);F.add(yi);const G=new rr("#ffffff",2);G.position.set(20,20,-30);G.castShadow=!0;G.shadow.mapSize.width=1024;G.shadow.mapSize.height=1024;G.shadow.camera.near=1;G.shadow.camera.far=100;G.shadow.camera.top=50;G.shadow.camera.right=50;G.shadow.camera.bottom=-50;G.shadow.camera.left=-50;G.shadow.normalBias=.1;F.add(G);const wi=new or(G,10);F.add(wi);wi.visible=!1;const xi=new ie(G.shadow.camera);F.add(xi);xi.visible=!1;const wt=new ar(16777215,20,40,1);wt.position.set(R.wallThickness,6,R.wallThickness);wt.castShadow=!0;wt.shadow.camera.near=1;wt.shadow.camera.far=30;wt.shadow.normalBias=.7;F.add(wt);const bi=new cr(wt,10);F.add(bi);bi.visible=!1;const Ai=new ie(wt.shadow.camera);F.add(Ai);Ai.visible=!1;const Mt=new nn(16777215,30,60,Math.PI*.1,.6,1);Mt.position.set(R.floorXLength/2-3,6,-6);Mt.target.position.set(R.floorXLength/2-3,-R.ny,-6);Mt.castShadow=!0;Mt.shadow.camera.near=1;Mt.shadow.camera.far=30;F.add(Mt);const Ti=new sn(Mt,16776960);F.add(Ti);Ti.visible=!1;const Si=new ie(Mt.shadow.camera);F.add(Si);Si.visible=!1;const It=new nn(16777215,30,60,Math.PI*.1,.6,1);It.position.set(R.floorXLength/2-3,6,6);It.target.position.set(R.floorXLength/2-3,-R.ny,6);It.castShadow=!0;It.shadow.camera.near=1;It.shadow.camera.far=30;F.add(It);const Bi=new sn(It,16776960);F.add(Bi);Bi.visible=!1;const _i=new ie(It.shadow.camera);F.add(_i);_i.visible=!1;const Lt=new nn(16777215,30,60,Math.PI*.1,.6,1.5);Lt.position.set(-(R.floorXLength/2-1),6.8,6);Lt.target.position.set(-(R.floorXLength/2),-R.ny,6);Lt.castShadow=!0;Lt.shadow.camera.near=1;Lt.shadow.camera.far=30;F.add(Lt);const Pi=new sn(Lt,16776960);F.add(Pi);Pi.visible=!1;const Mi=new ie(Lt.shadow.camera);F.add(Mi);Mi.visible=!1;const vt=new nn(16777215,30,60,Math.PI*.1,.6,1.5);vt.position.set(-(R.floorXLength/2-1),6.8,-6);vt.target.position.set(-(R.floorXLength/2),-R.ny,-6);vt.castShadow=!0;vt.shadow.camera.near=1;vt.shadow.camera.far=30;F.add(vt);const Ii=new sn(vt,16776960);F.add(Ii);Ii.visible=!1;const Li=new ie(vt.shadow.camera);F.add(Li);Li.visible=!1;const on=new lr;on.add(G,"visible").name("directionalLight");on.add(wt,"visible").name("pointLight");on.add(yi,"visible").name("ambientLight");const Ae={width:window.innerWidth,height:window.innerHeight},_e=new ur(20,Ae.width/Ae.height,.1,1e5);_e.position.set(120,100,120);const vi=document.querySelector("canvas.webgl");if(vi===null)throw new Error("Cannot find the canvas element");const ot=new fr({canvas:vi,antialias:!0});ot.setSize(Ae.width,Ae.height);ot.setPixelRatio(Math.min(window.devicePixelRatio,2));ot.autoClear=!1;ot.shadowMap.enabled=!0;ot.shadowMap.type=dr;const ts=new pr(_e,ot.domElement);ts.enableDamping=!0;const yn=hr(_e,ot.domElement),Ei=0,vr=1,Er=2,Cs=2,wn=1.25,zs=1,we=6*4+4+4,an=65535,Cr=Math.pow(2,-24),xn=Symbol("SKIP_GENERATION");function zr(i){return i.index?i.index.count:i.attributes.position.count}function re(i){return zr(i)/3}function Vr(i,t=ArrayBuffer){return i>65535?new Uint32Array(new t(4*i)):new Uint16Array(new t(2*i))}function Rr(i,t){if(!i.index){const e=i.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Vr(e,n);i.setIndex(new rn(s,1));for(let r=0;r<e;r++)s[r]=r}}function Ci(i){const t=re(i),e=i.drawRange,n=e.start/3,s=(e.start+e.count)/3,r=Math.max(0,n),c=Math.min(t,s)-r;return[{offset:Math.floor(r),count:Math.floor(c)}]}function zi(i){if(!i.groups||!i.groups.length)return Ci(i);const t=[],e=new Set,n=i.drawRange,s=n.start/3,r=(n.start+n.count)/3;for(const a of i.groups){const o=a.start/3,u=(a.start+a.count)/3;e.add(Math.max(s,o)),e.add(Math.min(r,u))}const c=Array.from(e.values()).sort((a,o)=>a-o);for(let a=0;a<c.length-1;a++){const o=c[a],u=c[a+1];t.push({offset:Math.floor(o),count:Math.floor(u-o)})}return t}function Ur(i){if(i.groups.length===0)return!1;const t=re(i),e=zi(i).sort((r,c)=>r.offset-c.offset),n=e[e.length-1];n.count=Math.min(t-n.offset,n.count);let s=0;return e.forEach(({count:r})=>s+=r),t!==s}function bn(i,t,e,n,s){let r=1/0,c=1/0,a=1/0,o=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,m=-1/0,A=-1/0,y=-1/0;for(let p=t*6,g=(t+e)*6;p<g;p+=6){const w=i[p+0],x=i[p+1],b=w-x,S=w+x;b<r&&(r=b),S>o&&(o=S),w<d&&(d=w),w>m&&(m=w);const T=i[p+2],B=i[p+3],_=T-B,M=T+B;_<c&&(c=_),M>u&&(u=M),T<f&&(f=T),T>A&&(A=T);const L=i[p+4],P=i[p+5],I=L-P,E=L+P;I<a&&(a=I),E>l&&(l=E),L<h&&(h=L),L>y&&(y=L)}n[0]=r,n[1]=c,n[2]=a,n[3]=o,n[4]=u,n[5]=l,s[0]=d,s[1]=f,s[2]=h,s[3]=m,s[4]=A,s[5]=y}function Fr(i,t=null,e=null,n=null){const s=i.attributes.position,r=i.index?i.index.array:null,c=re(i),a=s.normalized;let o;t===null?(o=new Float32Array(c*6*4),e=0,n=c):(o=t,e=e||0,n=n||c);const u=s.array,l=s.offset||0;let d=3;s.isInterleavedBufferAttribute&&(d=s.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+n;h++){const m=h*3,A=h*6;let y=m+0,p=m+1,g=m+2;r&&(y=r[y],p=r[p],g=r[g]),a||(y=y*d+l,p=p*d+l,g=g*d+l);for(let w=0;w<3;w++){let x,b,S;a?(x=s[f[w]](y),b=s[f[w]](p),S=s[f[w]](g)):(x=u[y+w],b=u[p+w],S=u[g+w]);let T=x;b<T&&(T=b),S<T&&(T=S);let B=x;b>B&&(B=b),S>B&&(B=S);const _=(B-T)/2,M=w*2;o[A+M+0]=T+_,o[A+M+1]=_+(Math.abs(T)+_)*Cr}}return o}function N(i,t,e){return e.min.x=t[i],e.min.y=t[i+1],e.min.z=t[i+2],e.max.x=t[i+3],e.max.y=t[i+4],e.max.z=t[i+5],e}function Vs(i){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=i[n+3]-i[n];s>e&&(e=s,t=n)}return t}function Rs(i,t){t.set(i)}function Us(i,t,e){let n,s;for(let r=0;r<3;r++){const c=r+3;n=i[r],s=t[r],e[r]=n<s?n:s,n=i[c],s=t[c],e[c]=n>s?n:s}}function Le(i,t,e){for(let n=0;n<3;n++){const s=t[i+2*n],r=t[i+2*n+1],c=s-r,a=s+r;c<e[n]&&(e[n]=c),a>e[n+3]&&(e[n+3]=a)}}function ue(i){const t=i[3]-i[0],e=i[4]-i[1],n=i[5]-i[2];return 2*(t*e+e*n+n*t)}const gt=32,Nr=(i,t)=>i.candidate-t.candidate,bt=new Array(gt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),ve=new Float32Array(6);function Dr(i,t,e,n,s,r){let c=-1,a=0;if(r===Ei)c=Vs(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(r===vr)c=Vs(i),c!==-1&&(a=kr(e,n,s,c));else if(r===Er){const o=ue(i);let u=wn*s;const l=n*6,d=(n+s)*6;for(let f=0;f<3;f++){const h=t[f],y=(t[f+3]-h)/gt;if(s<gt/4){const p=[...bt];p.length=s;let g=0;for(let x=l;x<d;x+=6,g++){const b=p[g];b.candidate=e[x+2*f],b.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:B}=b;for(let _=0;_<3;_++)B[_]=1/0,B[_+3]=-1/0,T[_]=1/0,T[_+3]=-1/0,S[_]=1/0,S[_+3]=-1/0;Le(x,e,S)}p.sort(Nr);let w=s;for(let x=0;x<w;x++){const b=p[x];for(;x+1<w&&p[x+1].candidate===b.candidate;)p.splice(x+1,1),w--}for(let x=l;x<d;x+=6){const b=e[x+2*f];for(let S=0;S<w;S++){const T=p[S];b>=T.candidate?Le(x,e,T.rightCacheBounds):(Le(x,e,T.leftCacheBounds),T.count++)}}for(let x=0;x<w;x++){const b=p[x],S=b.count,T=s-b.count,B=b.leftCacheBounds,_=b.rightCacheBounds;let M=0;S!==0&&(M=ue(B)/o);let L=0;T!==0&&(L=ue(_)/o);const P=zs+wn*(M*S+L*T);P<u&&(c=f,u=P,a=b.candidate)}}else{for(let w=0;w<gt;w++){const x=bt[w];x.count=0,x.candidate=h+y+w*y;const b=x.bounds;for(let S=0;S<3;S++)b[S]=1/0,b[S+3]=-1/0}for(let w=l;w<d;w+=6){let S=~~((e[w+2*f]-h)/y);S>=gt&&(S=gt-1);const T=bt[S];T.count++,Le(w,e,T.bounds)}const p=bt[gt-1];Rs(p.bounds,p.rightCacheBounds);for(let w=gt-2;w>=0;w--){const x=bt[w],b=bt[w+1];Us(x.bounds,b.rightCacheBounds,x.rightCacheBounds)}let g=0;for(let w=0;w<gt-1;w++){const x=bt[w],b=x.count,S=x.bounds,B=bt[w+1].rightCacheBounds;b!==0&&(g===0?Rs(S,ve):Us(S,ve,ve)),g+=b;let _=0,M=0;g!==0&&(_=ue(ve)/o);const L=s-g;L!==0&&(M=ue(B)/o);const P=zs+wn*(_*g+M*L);P<u&&(c=f,u=P,a=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:c,pos:a}}function kr(i,t,e,n){let s=0;for(let r=t,c=t+e;r<c;r++)s+=i[r*6+n*2];return s/e}class An{constructor(){this.boundingData=new Float32Array(6)}}function jr(i,t,e,n,s,r){let c=n,a=n+s-1;const o=r.pos,u=r.axis*2;for(;;){for(;c<=a&&e[c*6+u]<o;)c++;for(;c<=a&&e[a*6+u]>=o;)a--;if(c<a){for(let l=0;l<3;l++){let d=t[c*3+l];t[c*3+l]=t[a*3+l],t[a*3+l]=d}for(let l=0;l<6;l++){let d=e[c*6+l];e[c*6+l]=e[a*6+l],e[a*6+l]=d}c++,a--}else return c}}function Hr(i,t,e,n,s,r){let c=n,a=n+s-1;const o=r.pos,u=r.axis*2;for(;;){for(;c<=a&&e[c*6+u]<o;)c++;for(;c<=a&&e[a*6+u]>=o;)a--;if(c<a){let l=i[c];i[c]=i[a],i[a]=l;for(let d=0;d<6;d++){let f=e[c*6+d];e[c*6+d]=e[a*6+d],e[a*6+d]=f}c++,a--}else return c}}function O(i,t){return t[i+15]===65535}function W(i,t){return t[i+6]}function J(i,t){return t[i+14]}function K(i){return i+8}function Q(i,t){return t[i+6]}function Vi(i,t){return t[i+7]}let Ri,ye,Ze,Ui;const Gr=Math.pow(2,32);function Hn(i){return"count"in i?1:1+Hn(i.left)+Hn(i.right)}function $r(i,t,e){return Ri=new Float32Array(e),ye=new Uint32Array(e),Ze=new Uint16Array(e),Ui=new Uint8Array(e),Gn(i,t)}function Gn(i,t){const e=i/4,n=i/2,s="count"in t,r=t.boundingData;for(let c=0;c<6;c++)Ri[e+c]=r[c];if(s)if(t.buffer){const c=t.buffer;Ui.set(new Uint8Array(c),i);for(let a=i,o=i+c.byteLength;a<o;a+=we){const u=a/2;O(u,Ze)||(ye[a/4+6]+=e)}return i+c.byteLength}else{const c=t.offset,a=t.count;return ye[e+6]=c,Ze[n+14]=a,Ze[n+15]=an,i+we}else{const c=t.left,a=t.right,o=t.splitAxis;let u;if(u=Gn(i+we,c),u/4>Gr)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return ye[e+6]=u/4,u=Gn(u,a),ye[e+7]=o,u}}function Or(i,t){const e=(i.index?i.index.count:i.attributes.position.count)/3,n=e>2**16,s=n?4:2,r=t?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),c=n?new Uint32Array(r):new Uint16Array(r);for(let a=0,o=c.length;a<o;a++)c[a]=a;return c}function Xr(i,t,e,n,s){const{maxDepth:r,verbose:c,maxLeafTris:a,strategy:o,onProgress:u,indirect:l}=s,d=i._indirectBuffer,f=i.geometry,h=f.index?f.index.array:null,m=l?Hr:jr,A=re(f),y=new Float32Array(6);let p=!1;const g=new An;return bn(t,e,n,g.boundingData,y),x(g,e,n,y),g;function w(b){u&&u(b/A)}function x(b,S,T,B=null,_=0){if(!p&&_>=r&&(p=!0,c&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),T<=a||_>=r)return w(S+T),b.offset=S,b.count=T,b;const M=Dr(b.boundingData,B,t,S,T,o);if(M.axis===-1)return w(S+T),b.offset=S,b.count=T,b;const L=m(d,h,t,S,T,M);if(L===S||L===S+T)w(S+T),b.offset=S,b.count=T;else{b.splitAxis=M.axis;const P=new An,I=S,E=L-S;b.left=P,bn(t,I,E,P.boundingData,y),x(P,I,E,y,_+1);const C=new An,z=L,j=T-E;b.right=C,bn(t,z,j,C.boundingData,y),x(C,z,j,y,_+1)}return b}}function Wr(i,t){const e=i.geometry;t.indirect&&(i._indirectBuffer=Or(e,t.useSharedArrayBuffer),Ur(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),i._indirectBuffer||Rr(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Fr(e),r=t.indirect?Ci(e):zi(e);i._roots=r.map(c=>{const a=Xr(i,s,c.offset,c.count,t),o=Hn(a),u=new n(we*o);return $r(0,a,u),u})}class yt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let r=0,c=t.length;r<c;r++){const o=t[r][e];n=o<n?o:n,s=o>s?o:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let r=0,c=e.length;r<c;r++){const a=e[r],o=t.dot(a);n=o<n?o:n,s=o>s?o:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}yt.prototype.setFromBox=function(){const i=new v;return function(e,n){const s=n.min,r=n.max;let c=1/0,a=-1/0;for(let o=0;o<=1;o++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){i.x=s.x*o+r.x*(1-o),i.y=s.y*u+r.y*(1-u),i.z=s.z*l+r.z*(1-l);const d=e.dot(i);c=Math.min(d,c),a=Math.max(d,a)}this.min=c,this.max=a}}();const qr=function(){const i=new v,t=new v,e=new v;return function(s,r,c){const a=s.start,o=i,u=r.start,l=t;e.subVectors(a,u),i.subVectors(s.end,s.start),t.subVectors(r.end,r.start);const d=e.dot(l),f=l.dot(o),h=l.dot(l),m=e.dot(o),y=o.dot(o)*h-f*f;let p,g;y!==0?p=(d*f-m*h)/y:p=0,g=(d+p*f)/h,c.x=p,c.y=g}}(),es=function(){const i=new Dt,t=new v,e=new v;return function(s,r,c,a){qr(s,r,i);let o=i.x,u=i.y;if(o>=0&&o<=1&&u>=0&&u<=1){s.at(o,c),r.at(u,a);return}else if(o>=0&&o<=1){u<0?r.at(0,a):r.at(1,a),s.closestPointToPoint(a,!0,c);return}else if(u>=0&&u<=1){o<0?s.at(0,c):s.at(1,c),r.closestPointToPoint(c,!0,a);return}else{let l;o<0?l=s.start:l=s.end;let d;u<0?d=r.start:d=r.end;const f=t,h=e;if(s.closestPointToPoint(d,!0,t),r.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=h.distanceToSquared(l)){c.copy(f),a.copy(d);return}else{c.copy(l),a.copy(h);return}}}}(),Zr=function(){const i=new v,t=new v,e=new Kn,n=new et;return function(r,c){const{radius:a,center:o}=r,{a:u,b:l,c:d}=c;if(n.start=u,n.end=l,n.closestPointToPoint(o,!0,i).distanceTo(o)<=a||(n.start=u,n.end=d,n.closestPointToPoint(o,!0,i).distanceTo(o)<=a)||(n.start=l,n.end=d,n.closestPointToPoint(o,!0,i).distanceTo(o)<=a))return!0;const A=c.getPlane(e);if(Math.abs(A.distanceToPoint(o))<=a){const p=A.projectPoint(o,t);if(c.containsPoint(p))return!0}return!1}}(),Yr=1e-15;function Tn(i){return Math.abs(i)<Yr}class nt extends X{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new v),this.satBounds=new Array(4).fill().map(()=>new yt),this.points=[this.a,this.b,this.c],this.sphere=new mr,this.plane=new Kn,this.needsUpdate=!0}intersectsSphere(t){return Zr(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,r=this.satAxes,c=this.satBounds,a=r[0],o=c[0];this.getNormal(a),o.setFromPoints(a,s);const u=r[1],l=c[1];u.subVectors(t,e),l.setFromPoints(u,s);const d=r[2],f=c[2];d.subVectors(e,n),f.setFromPoints(d,s);const h=r[3],m=c[3];h.subVectors(n,t),m.setFromPoints(h,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}nt.prototype.closestPointToSegment=function(){const i=new v,t=new v,e=new et;return function(s,r=null,c=null){const{start:a,end:o}=s,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),es(e,s,i,t),l=i.distanceToSquared(t),l<d&&(d=l,r&&r.copy(i),c&&c.copy(t))}return this.closestPointToPoint(a,i),l=a.distanceToSquared(i),l<d&&(d=l,r&&r.copy(i),c&&c.copy(a)),this.closestPointToPoint(o,i),l=o.distanceToSquared(i),l<d&&(d=l,r&&r.copy(i),c&&c.copy(o)),Math.sqrt(d)}}();nt.prototype.intersectsTriangle=function(){const i=new nt,t=new Array(3),e=new Array(3),n=new yt,s=new yt,r=new v,c=new v,a=new v,o=new v,u=new v,l=new et,d=new et,f=new et,h=new v;function m(A,y,p){const g=A.points;let w=0,x=-1;for(let b=0;b<3;b++){const{start:S,end:T}=l;S.copy(g[b]),T.copy(g[(b+1)%3]),l.delta(c);const B=Tn(y.distanceToPoint(S));if(Tn(y.normal.dot(c))&&B){p.copy(l),w=2;break}const _=y.intersectLine(l,h);if(!_&&B&&h.copy(S),(_||B)&&!Tn(h.distanceTo(T))){if(w<=1)(w===1?p.start:p.end).copy(h),B&&(x=w);else if(w>=2){(x===1?p.start:p.end).copy(h),w=2;break}if(w++,w===2&&x===-1)break}}return w}return function(y,p=null,g=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(i.copy(y),i.update(),y=i);const w=this.plane,x=y.plane;if(Math.abs(w.normal.dot(x.normal))>1-1e-10){const b=this.satBounds,S=this.satAxes;e[0]=y.a,e[1]=y.b,e[2]=y.c;for(let _=0;_<4;_++){const M=b[_],L=S[_];if(n.setFromPoints(L,e),M.isSeparated(n))return!1}const T=y.satBounds,B=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let _=0;_<4;_++){const M=T[_],L=B[_];if(n.setFromPoints(L,t),M.isSeparated(n))return!1}for(let _=0;_<4;_++){const M=S[_];for(let L=0;L<4;L++){const P=B[L];if(r.crossVectors(M,P),n.setFromPoints(r,t),s.setFromPoints(r,e),n.isSeparated(s))return!1}}return p&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const b=m(this,x,d);if(b===1&&y.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(b!==2)return!1;const S=m(y,w,f);if(S===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(S!==2)return!1;if(d.delta(a),f.delta(o),a.dot(o)<0){let I=f.start;f.start=f.end,f.end=I}const T=d.start.dot(a),B=d.end.dot(a),_=f.start.dot(a),M=f.end.dot(a),L=B<_,P=T<M;return T!==M&&_!==B&&L===P?!1:(p&&(u.subVectors(d.start,f.start),u.dot(a)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();nt.prototype.distanceToPoint=function(){const i=new v;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();nt.prototype.distanceToTriangle=function(){const i=new v,t=new v,e=["a","b","c"],n=new et,s=new et;return function(c,a=null,o=null){const u=a||o?n:null;if(this.intersectsTriangle(c,u))return(a||o)&&(a&&u.getCenter(a),o&&u.getCenter(o)),0;let l=1/0;for(let d=0;d<3;d++){let f;const h=e[d],m=c[h];this.closestPointToPoint(m,i),f=m.distanceToSquared(i),f<l&&(l=f,a&&a.copy(i),o&&o.copy(m));const A=this[h];c.closestPointToPoint(A,i),f=A.distanceToSquared(i),f<l&&(l=f,a&&a.copy(A),o&&o.copy(i))}for(let d=0;d<3;d++){const f=e[d],h=e[(d+1)%3];n.set(this[f],this[h]);for(let m=0;m<3;m++){const A=e[m],y=e[(m+1)%3];s.set(c[A],c[y]),es(n,s,i,t);const p=i.distanceToSquared(t);p<l&&(l=p,a&&a.copy(i),o&&o.copy(t))}}return Math.sqrt(l)}}();class ${constructor(t,e,n){this.isOrientedBox=!0,this.min=new v,this.max=new v,this.matrix=new lt,this.invMatrix=new lt,this.points=new Array(8).fill().map(()=>new v),this.satAxes=new Array(3).fill().map(()=>new v),this.satBounds=new Array(3).fill().map(()=>new yt),this.alignedSatBounds=new Array(3).fill().map(()=>new yt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}$.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,h=s[f];h.x=u?n.x:e.x,h.y=l?n.y:e.y,h.z=d?n.z:e.z,h.applyMatrix4(t)}const r=this.satBounds,c=this.satAxes,a=s[0];for(let u=0;u<3;u++){const l=c[u],d=r[u],f=1<<u,h=s[f];l.subVectors(a,h),d.setFromPoints(l,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();$.prototype.intersectsBox=function(){const i=new yt;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,r=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(i.min=n.x,i.max=s.x,a[0].isSeparated(i)||(i.min=n.y,i.max=s.y,a[1].isSeparated(i))||(i.min=n.z,i.max=s.z,a[2].isSeparated(i)))return!1;for(let o=0;o<3;o++){const u=c[o],l=r[o];if(i.setFromBox(u,e),l.isSeparated(i))return!1}return!0}}();$.prototype.intersectsTriangle=function(){const i=new nt,t=new Array(3),e=new yt,n=new yt,s=new v;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(i.copy(c),i.update(),c=i);const a=this.satBounds,o=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let f=0;f<3;f++){const h=a[f],m=o[f];if(e.setFromPoints(m,t),h.isSeparated(e))return!1}const u=c.satBounds,l=c.satAxes,d=this.points;for(let f=0;f<3;f++){const h=u[f],m=l[f];if(e.setFromPoints(m,d),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=o[f];for(let m=0;m<4;m++){const A=l[m];if(s.crossVectors(h,A),e.setFromPoints(s,t),n.setFromPoints(s,d),e.isSeparated(n))return!1}}return!0}}();$.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();$.prototype.distanceToPoint=function(){const i=new v;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();$.prototype.distanceToBox=function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new et),e=new Array(12).fill().map(()=>new et),n=new v,s=new v;return function(c,a=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(o||u)&&(c.getCenter(s),this.closestPointToPoint(s,n),c.closestPointToPoint(n,s),o&&o.copy(n),u&&u.copy(s)),0;const l=a*a,d=c.min,f=c.max,h=this.points;let m=1/0;for(let y=0;y<8;y++){const p=h[y];s.copy(p).clamp(d,f);const g=p.distanceToSquared(s);if(g<m&&(m=g,o&&o.copy(p),u&&u.copy(s),g<l))return Math.sqrt(g)}let A=0;for(let y=0;y<3;y++)for(let p=0;p<=1;p++)for(let g=0;g<=1;g++){const w=(y+1)%3,x=(y+2)%3,b=p<<w|g<<x,S=1<<y|p<<w|g<<x,T=h[b],B=h[S];t[A].set(T,B);const M=i[y],L=i[w],P=i[x],I=e[A],E=I.start,C=I.end;E[M]=d[M],E[L]=p?d[L]:f[L],E[P]=g?d[P]:f[L],C[M]=f[M],C[L]=p?d[L]:f[L],C[P]=g?d[P]:f[L],A++}for(let y=0;y<=1;y++)for(let p=0;p<=1;p++)for(let g=0;g<=1;g++){s.x=y?f.x:d.x,s.y=p?f.y:d.y,s.z=g?f.z:d.z,this.closestPointToPoint(s,n);const w=s.distanceToSquared(n);if(w<m&&(m=w,o&&o.copy(n),u&&u.copy(s),w<l))return Math.sqrt(w)}for(let y=0;y<12;y++){const p=t[y];for(let g=0;g<12;g++){const w=e[g];es(p,w,n,s);const x=n.distanceToSquared(s);if(x<m&&(m=x,o&&o.copy(n),u&&u.copy(s),x<l))return Math.sqrt(x)}}return Math.sqrt(m)}}();class ns{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Jr extends ns{constructor(){super(()=>new nt)}}const tt=new Jr;class Kr{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const U=new Kr;let Bt,te;const $t=[],Ee=new ns(()=>new at);function Qr(i,t,e,n,s,r){Bt=Ee.getPrimitive(),te=Ee.getPrimitive(),$t.push(Bt,te),U.setBuffer(i._roots[t]);const c=$n(0,i.geometry,e,n,s,r);U.clearBuffer(),Ee.releasePrimitive(Bt),Ee.releasePrimitive(te),$t.pop(),$t.pop();const a=$t.length;return a>0&&(te=$t[a-1],Bt=$t[a-2]),c}function $n(i,t,e,n,s=null,r=0,c=0){const{float32Array:a,uint16Array:o,uint32Array:u}=U;let l=i*2;if(O(l,o)){const f=W(i,u),h=J(l,o);return N(i,a,Bt),n(f,h,!1,c,r+i,Bt)}else{let M=function(P){const{uint16Array:I,uint32Array:E}=U;let C=P*2;for(;!O(C,I);)P=K(P),C=P*2;return W(P,E)},L=function(P){const{uint16Array:I,uint32Array:E}=U;let C=P*2;for(;!O(C,I);)P=Q(P,E),C=P*2;return W(P,E)+J(C,I)};const f=K(i),h=Q(i,u);let m=f,A=h,y,p,g,w;if(s&&(g=Bt,w=te,N(m,a,g),N(A,a,w),y=s(g),p=s(w),p<y)){m=h,A=f;const P=y;y=p,p=P,g=w}g||(g=Bt,N(m,a,g));const x=O(m*2,o),b=e(g,x,y,c+1,r+m);let S;if(b===Cs){const P=M(m),E=L(m)-P;S=n(P,E,!0,c+1,r+m,g)}else S=b&&$n(m,t,e,n,s,r,c+1);if(S)return!0;w=te,N(A,a,w);const T=O(A*2,o),B=e(w,T,p,c+1,r+A);let _;if(B===Cs){const P=M(A),E=L(A)-P;_=n(P,E,!0,c+1,r+A,w)}else _=B&&$n(A,t,e,n,s,r,c+1);return!!_}}const fe=new v,Sn=new v;function to(i,t,e={},n=0,s=1/0){const r=n*n,c=s*s;let a=1/0,o=null;if(i.shapecast({boundsTraverseOrder:l=>(fe.copy(t).clamp(l.min,l.max),fe.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<a&&f<c,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,fe);const f=t.distanceToSquared(fe);return f<a&&(Sn.copy(fe),a=f,o=d),f<r}}),a===1/0)return null;const u=Math.sqrt(a);return e.point?e.point.copy(Sn):e.point=Sn.clone(),e.distance=u,e.faceIndex=o,e}const Ot=new v,Xt=new v,Wt=new v,Ce=new Dt,ze=new Dt,Ve=new Dt,Fs=new v,Ns=new v,Ds=new v,Re=new v;function eo(i,t,e,n,s,r){let c;return r===gr?c=i.intersectTriangle(n,e,t,!0,s):c=i.intersectTriangle(t,e,n,r!==Qn,s),c===null?null:{distance:i.origin.distanceTo(s),point:s.clone()}}function no(i,t,e,n,s,r,c,a,o){Ot.fromBufferAttribute(t,r),Xt.fromBufferAttribute(t,c),Wt.fromBufferAttribute(t,a);const u=eo(i,Ot,Xt,Wt,Re,o);if(u){n&&(Ce.fromBufferAttribute(n,r),ze.fromBufferAttribute(n,c),Ve.fromBufferAttribute(n,a),u.uv=X.getInterpolation(Re,Ot,Xt,Wt,Ce,ze,Ve,new Dt)),s&&(Ce.fromBufferAttribute(s,r),ze.fromBufferAttribute(s,c),Ve.fromBufferAttribute(s,a),u.uv1=X.getInterpolation(Re,Ot,Xt,Wt,Ce,ze,Ve,new Dt)),e&&(Fs.fromBufferAttribute(e,r),Ns.fromBufferAttribute(e,c),Ds.fromBufferAttribute(e,a),u.normal=X.getInterpolation(Re,Ot,Xt,Wt,Fs,Ns,Ds,new v),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const l={a:r,b:c,c:a,normal:new v,materialIndex:0};X.getNormal(Ot,Xt,Wt,l.normal),u.face=l,u.faceIndex=r}return u}function cn(i,t,e,n,s){const r=n*3;let c=r+0,a=r+1,o=r+2;const u=i.index;i.index&&(c=u.getX(c),a=u.getX(a),o=u.getX(o));const{position:l,normal:d,uv:f,uv1:h}=i.attributes,m=no(e,l,d,f,h,c,a,o,t);return m?(m.faceIndex=n,s&&s.push(m),m):null}function k(i,t,e,n){const s=i.a,r=i.b,c=i.c;let a=t,o=t+1,u=t+2;e&&(a=e.getX(a),o=e.getX(o),u=e.getX(u)),s.x=n.getX(a),s.y=n.getY(a),s.z=n.getZ(a),r.x=n.getX(o),r.y=n.getY(o),r.z=n.getZ(o),c.x=n.getX(u),c.y=n.getY(u),c.z=n.getZ(u)}function so(i,t,e,n,s,r){const{geometry:c,_indirectBuffer:a}=i;for(let o=n,u=n+s;o<u;o++)cn(c,t,e,o,r)}function io(i,t,e,n,s){const{geometry:r,_indirectBuffer:c}=i;let a=1/0,o=null;for(let u=n,l=n+s;u<l;u++){let d;d=cn(r,t,e,u),d&&d.distance<a&&(o=d,a=d.distance)}return o}function ro(i,t,e,n,s,r,c){const{geometry:a}=e,{index:o}=a,u=a.attributes.position;for(let l=i,d=t+i;l<d;l++){let f;if(f=l,k(c,f*3,o,u),c.needsUpdate=!0,n(c,f,s,r))return!0}return!1}function oo(i,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=i.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let r,c,a,o,u=0;const l=i._roots;for(let f=0,h=l.length;f<h;f++)r=l[f],c=new Uint32Array(r),a=new Uint16Array(r),o=new Float32Array(r),d(0,u),u+=r.byteLength;function d(f,h,m=!1){const A=f*2;if(a[A+15]===an){const p=c[f+6],g=a[A+14];let w=1/0,x=1/0,b=1/0,S=-1/0,T=-1/0,B=-1/0;for(let _=3*p,M=3*(p+g);_<M;_++){let L=n[_];const P=s.getX(L),I=s.getY(L),E=s.getZ(L);P<w&&(w=P),P>S&&(S=P),I<x&&(x=I),I>T&&(T=I),E<b&&(b=E),E>B&&(B=E)}return o[f+0]!==w||o[f+1]!==x||o[f+2]!==b||o[f+3]!==S||o[f+4]!==T||o[f+5]!==B?(o[f+0]=w,o[f+1]=x,o[f+2]=b,o[f+3]=S,o[f+4]=T,o[f+5]=B,!0):!1}else{const p=f+8,g=c[f+6],w=p+h,x=g+h;let b=m,S=!1,T=!1;t?b||(S=t.has(w),T=t.has(x),b=!S&&!T):(S=!0,T=!0);const B=b||S,_=b||T;let M=!1;B&&(M=d(p,h,b));let L=!1;_&&(L=d(g,h,b));const P=M||L;if(P)for(let I=0;I<3;I++){const E=p+I,C=g+I,z=o[E],j=o[E+3],Ht=o[C],Ct=o[C+3];o[f+I]=z<Ht?z:Ht,o[f+I+3]=j>Ct?j:Ct}return P}}}const ks=new at;function Pt(i,t,e,n){return N(i,t,ks),e.intersectBox(ks,n)}function ao(i,t,e,n,s,r){const{geometry:c,_indirectBuffer:a}=i;for(let o=n,u=n+s;o<u;o++){let l=a?a[o]:o;cn(c,t,e,l,r)}}function co(i,t,e,n,s){const{geometry:r,_indirectBuffer:c}=i;let a=1/0,o=null;for(let u=n,l=n+s;u<l;u++){let d;d=cn(r,t,e,c?c[u]:u),d&&d.distance<a&&(o=d,a=d.distance)}return o}function lo(i,t,e,n,s,r,c){const{geometry:a}=e,{index:o}=a,u=a.attributes.position;for(let l=i,d=t+i;l<d;l++){let f;if(f=e.resolveTriangleIndex(l),k(c,f*3,o,u),c.needsUpdate=!0,n(c,f,s,r))return!0}return!1}const js=new v;function uo(i,t,e,n,s){U.setBuffer(i._roots[t]),On(0,i,e,n,s),U.clearBuffer()}function On(i,t,e,n,s){const{float32Array:r,uint16Array:c,uint32Array:a}=U,o=i*2;if(O(o,c)){const l=W(i,a),d=J(o,c);so(t,e,n,l,d,s)}else{const l=K(i);Pt(l,r,n,js)&&On(l,t,e,n,s);const d=Q(i,a);Pt(d,r,n,js)&&On(d,t,e,n,s)}}const Hs=new v,fo=["x","y","z"];function po(i,t,e,n){U.setBuffer(i._roots[t]);const s=Xn(0,i,e,n);return U.clearBuffer(),s}function Xn(i,t,e,n){const{float32Array:s,uint16Array:r,uint32Array:c}=U;let a=i*2;if(O(a,r)){const u=W(i,c),l=J(a,r);return io(t,e,n,u,l)}else{const u=Vi(i,c),l=fo[u],f=n.direction[l]>=0;let h,m;f?(h=K(i),m=Q(i,c)):(h=Q(i,c),m=K(i));const y=Pt(h,s,n,Hs)?Xn(h,t,e,n):null;if(y){const w=y.point[l];if(f?w<=s[m+u]:w>=s[m+u+3])return y}const g=Pt(m,s,n,Hs)?Xn(m,t,e,n):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const Ue=new at,qt=new nt,Zt=new nt,de=new lt,Gs=new $,Fe=new $;function ho(i,t,e,n){U.setBuffer(i._roots[t]);const s=Wn(0,i,e,n);return U.clearBuffer(),s}function Wn(i,t,e,n,s=null){const{float32Array:r,uint16Array:c,uint32Array:a}=U;let o=i*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Gs.set(e.boundingBox.min,e.boundingBox.max,n),s=Gs),O(o,c)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,m=e.attributes.position,A=W(i,a),y=J(o,c);if(de.copy(n).invert(),e.boundsTree)return N(i,r,Fe),Fe.matrix.copy(de),Fe.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>Fe.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(n),g.b.applyMatrix4(n),g.c.applyMatrix4(n),g.needsUpdate=!0;for(let w=A*3,x=(y+A)*3;w<x;w+=3)if(k(Zt,w,d,f),Zt.needsUpdate=!0,g.intersectsTriangle(Zt))return!0;return!1}});for(let p=A*3,g=(y+A)*3;p<g;p+=3){k(qt,p,d,f),qt.a.applyMatrix4(de),qt.b.applyMatrix4(de),qt.c.applyMatrix4(de),qt.needsUpdate=!0;for(let w=0,x=h.count;w<x;w+=3)if(k(Zt,w,h,m),Zt.needsUpdate=!0,qt.intersectsTriangle(Zt))return!0}}else{const l=i+8,d=a[i+6];return N(l,r,Ue),!!(s.intersectsBox(Ue)&&Wn(l,t,e,n,s)||(N(d,r,Ue),s.intersectsBox(Ue)&&Wn(d,t,e,n,s)))}}const Ne=new lt,Bn=new $,pe=new $,mo=new v,go=new v,yo=new v,wo=new v;function xo(i,t,e,n={},s={},r=0,c=1/0){t.boundingBox||t.computeBoundingBox(),Bn.set(t.boundingBox.min,t.boundingBox.max,e),Bn.needsUpdate=!0;const a=i.geometry,o=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=tt.getPrimitive(),h=tt.getPrimitive();let m=mo,A=go,y=null,p=null;s&&(y=yo,p=wo);let g=1/0,w=null,x=null;return Ne.copy(e).invert(),pe.matrix.copy(Ne),i.shapecast({boundsTraverseOrder:b=>Bn.distanceToBox(b),intersectsBounds:(b,S,T)=>T<g&&T<c?(S&&(pe.min.copy(b.min),pe.max.copy(b.max),pe.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>pe.distanceToBox(B),intersectsBounds:(B,_,M)=>M<g&&M<c,intersectsRange:(B,_)=>{for(let M=B,L=B+_;M<L;M++){k(h,3*M,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let P=b,I=b+S;P<I;P++){k(f,3*P,u,o),f.needsUpdate=!0;const E=f.distanceToTriangle(h,m,y);if(E<g&&(A.copy(m),p&&p.copy(y),g=E,w=P,x=M),E<r)return!0}}}});{const T=re(t);for(let B=0,_=T;B<_;B++){k(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=b,L=b+S;M<L;M++){k(f,3*M,u,o),f.needsUpdate=!0;const P=f.distanceToTriangle(h,m,y);if(P<g&&(A.copy(m),p&&p.copy(y),g=P,w=M,x=B),P<r)return!0}}}}}),tt.releasePrimitive(f),tt.releasePrimitive(h),g===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=g,n.faceIndex=w,s&&(s.point?s.point.copy(p):s.point=p.clone(),s.point.applyMatrix4(Ne),A.applyMatrix4(Ne),s.distance=A.sub(s.point).length(),s.faceIndex=x),n)}function bo(i,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=i.geometry,n=e.index?e.index.array:null,s=e.attributes.position;let r,c,a,o,u=0;const l=i._roots;for(let f=0,h=l.length;f<h;f++)r=l[f],c=new Uint32Array(r),a=new Uint16Array(r),o=new Float32Array(r),d(0,u),u+=r.byteLength;function d(f,h,m=!1){const A=f*2;if(a[A+15]===an){const p=c[f+6],g=a[A+14];let w=1/0,x=1/0,b=1/0,S=-1/0,T=-1/0,B=-1/0;for(let _=p,M=p+g;_<M;_++){const L=3*i.resolveTriangleIndex(_);for(let P=0;P<3;P++){let I=L+P;I=n?n[I]:I;const E=s.getX(I),C=s.getY(I),z=s.getZ(I);E<w&&(w=E),E>S&&(S=E),C<x&&(x=C),C>T&&(T=C),z<b&&(b=z),z>B&&(B=z)}}return o[f+0]!==w||o[f+1]!==x||o[f+2]!==b||o[f+3]!==S||o[f+4]!==T||o[f+5]!==B?(o[f+0]=w,o[f+1]=x,o[f+2]=b,o[f+3]=S,o[f+4]=T,o[f+5]=B,!0):!1}else{const p=f+8,g=c[f+6],w=p+h,x=g+h;let b=m,S=!1,T=!1;t?b||(S=t.has(w),T=t.has(x),b=!S&&!T):(S=!0,T=!0);const B=b||S,_=b||T;let M=!1;B&&(M=d(p,h,b));let L=!1;_&&(L=d(g,h,b));const P=M||L;if(P)for(let I=0;I<3;I++){const E=p+I,C=g+I,z=o[E],j=o[E+3],Ht=o[C],Ct=o[C+3];o[f+I]=z<Ht?z:Ht,o[f+I+3]=j>Ct?j:Ct}return P}}}const $s=new v;function Ao(i,t,e,n,s){U.setBuffer(i._roots[t]),qn(0,i,e,n,s),U.clearBuffer()}function qn(i,t,e,n,s){const{float32Array:r,uint16Array:c,uint32Array:a}=U,o=i*2;if(O(o,c)){const l=W(i,a),d=J(o,c);ao(t,e,n,l,d,s)}else{const l=K(i);Pt(l,r,n,$s)&&qn(l,t,e,n,s);const d=Q(i,a);Pt(d,r,n,$s)&&qn(d,t,e,n,s)}}const Os=new v,To=["x","y","z"];function So(i,t,e,n){U.setBuffer(i._roots[t]);const s=Zn(0,i,e,n);return U.clearBuffer(),s}function Zn(i,t,e,n){const{float32Array:s,uint16Array:r,uint32Array:c}=U;let a=i*2;if(O(a,r)){const u=W(i,c),l=J(a,r);return co(t,e,n,u,l)}else{const u=Vi(i,c),l=To[u],f=n.direction[l]>=0;let h,m;f?(h=K(i),m=Q(i,c)):(h=Q(i,c),m=K(i));const y=Pt(h,s,n,Os)?Zn(h,t,e,n):null;if(y){const w=y.point[l];if(f?w<=s[m+u]:w>=s[m+u+3])return y}const g=Pt(m,s,n,Os)?Zn(m,t,e,n):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const De=new at,Yt=new nt,Jt=new nt,he=new lt,Xs=new $,ke=new $;function Bo(i,t,e,n){U.setBuffer(i._roots[t]);const s=Yn(0,i,e,n);return U.clearBuffer(),s}function Yn(i,t,e,n,s=null){const{float32Array:r,uint16Array:c,uint32Array:a}=U;let o=i*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Xs.set(e.boundingBox.min,e.boundingBox.max,n),s=Xs),O(o,c)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,m=e.attributes.position,A=W(i,a),y=J(o,c);if(he.copy(n).invert(),e.boundsTree)return N(i,r,ke),ke.matrix.copy(he),ke.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>ke.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(n),g.b.applyMatrix4(n),g.c.applyMatrix4(n),g.needsUpdate=!0;for(let w=A,x=y+A;w<x;w++)if(k(Jt,3*t.resolveTriangleIndex(w),d,f),Jt.needsUpdate=!0,g.intersectsTriangle(Jt))return!0;return!1}});for(let p=A,g=y+A;p<g;p++){const w=t.resolveTriangleIndex(p);k(Yt,3*w,d,f),Yt.a.applyMatrix4(he),Yt.b.applyMatrix4(he),Yt.c.applyMatrix4(he),Yt.needsUpdate=!0;for(let x=0,b=h.count;x<b;x+=3)if(k(Jt,x,h,m),Jt.needsUpdate=!0,Yt.intersectsTriangle(Jt))return!0}}else{const l=i+8,d=a[i+6];return N(l,r,De),!!(s.intersectsBox(De)&&Yn(l,t,e,n,s)||(N(d,r,De),s.intersectsBox(De)&&Yn(d,t,e,n,s)))}}const je=new lt,_n=new $,me=new $,_o=new v,Po=new v,Mo=new v,Io=new v;function Lo(i,t,e,n={},s={},r=0,c=1/0){t.boundingBox||t.computeBoundingBox(),_n.set(t.boundingBox.min,t.boundingBox.max,e),_n.needsUpdate=!0;const a=i.geometry,o=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=tt.getPrimitive(),h=tt.getPrimitive();let m=_o,A=Po,y=null,p=null;s&&(y=Mo,p=Io);let g=1/0,w=null,x=null;return je.copy(e).invert(),me.matrix.copy(je),i.shapecast({boundsTraverseOrder:b=>_n.distanceToBox(b),intersectsBounds:(b,S,T)=>T<g&&T<c?(S&&(me.min.copy(b.min),me.max.copy(b.max),me.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:B=>me.distanceToBox(B),intersectsBounds:(B,_,M)=>M<g&&M<c,intersectsRange:(B,_)=>{for(let M=B,L=B+_;M<L;M++){const P=T.resolveTriangleIndex(M);k(h,3*P,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let I=b,E=b+S;I<E;I++){const C=i.resolveTriangleIndex(I);k(f,3*C,u,o),f.needsUpdate=!0;const z=f.distanceToTriangle(h,m,y);if(z<g&&(A.copy(m),p&&p.copy(y),g=z,w=I,x=M),z<r)return!0}}}})}else{const T=re(t);for(let B=0,_=T;B<_;B++){k(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=b,L=b+S;M<L;M++){const P=i.resolveTriangleIndex(M);k(f,3*P,u,o),f.needsUpdate=!0;const I=f.distanceToTriangle(h,m,y);if(I<g&&(A.copy(m),p&&p.copy(y),g=I,w=M,x=B),I<r)return!0}}}}}),tt.releasePrimitive(f),tt.releasePrimitive(h),g===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=g,n.faceIndex=w,s&&(s.point?s.point.copy(p):s.point=p.clone(),s.point.applyMatrix4(je),A.applyMatrix4(je),s.distance=A.sub(s.point).length(),s.faceIndex=x),n)}function vo(){return typeof SharedArrayBuffer<"u"}const xe=new U.constructor,Qe=new U.constructor,Tt=new ns(()=>new at),Kt=new at,Qt=new at,Pn=new at,Mn=new at;let In=!1;function Eo(i,t,e,n){if(In)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");In=!0;const s=i._roots,r=t._roots;let c,a=0,o=0;const u=new lt().copy(e).invert();for(let l=0,d=s.length;l<d;l++){xe.setBuffer(s[l]),o=0;const f=Tt.getPrimitive();N(0,xe.float32Array,f),f.applyMatrix4(u);for(let h=0,m=r.length;h<m&&(Qe.setBuffer(r[l]),c=it(0,0,e,u,n,a,o,0,0,f),Qe.clearBuffer(),o+=r[h].length,!c);h++);if(Tt.releasePrimitive(f),xe.clearBuffer(),a+=s[l].length,c)break}return In=!1,c}function it(i,t,e,n,s,r=0,c=0,a=0,o=0,u=null,l=!1){let d,f;l?(d=Qe,f=xe):(d=xe,f=Qe);const h=d.float32Array,m=d.uint32Array,A=d.uint16Array,y=f.float32Array,p=f.uint32Array,g=f.uint16Array,w=i*2,x=t*2,b=O(w,A),S=O(x,g);let T=!1;if(S&&b)l?T=s(W(t,p),J(t*2,g),W(i,m),J(i*2,A),o,c+t,a,r+i):T=s(W(i,m),J(i*2,A),W(t,p),J(t*2,g),a,r+i,o,c+t);else if(S){const B=Tt.getPrimitive();N(t,y,B),B.applyMatrix4(e);const _=K(i),M=Q(i,m);N(_,h,Kt),N(M,h,Qt);const L=B.intersectsBox(Kt),P=B.intersectsBox(Qt);T=L&&it(t,_,n,e,s,c,r,o,a+1,B,!l)||P&&it(t,M,n,e,s,c,r,o,a+1,B,!l),Tt.releasePrimitive(B)}else{const B=K(t),_=Q(t,p);N(B,y,Pn),N(_,y,Mn);const M=u.intersectsBox(Pn),L=u.intersectsBox(Mn);if(M&&L)T=it(i,B,e,n,s,r,c,a,o+1,u,l)||it(i,_,e,n,s,r,c,a,o+1,u,l);else if(M)if(b)T=it(i,B,e,n,s,r,c,a,o+1,u,l);else{const P=Tt.getPrimitive();P.copy(Pn).applyMatrix4(e);const I=K(i),E=Q(i,m);N(I,h,Kt),N(E,h,Qt);const C=P.intersectsBox(Kt),z=P.intersectsBox(Qt);T=C&&it(B,I,n,e,s,c,r,o,a+1,P,!l)||z&&it(B,E,n,e,s,c,r,o,a+1,P,!l),Tt.releasePrimitive(P)}else if(L)if(b)T=it(i,_,e,n,s,r,c,a,o+1,u,l);else{const P=Tt.getPrimitive();P.copy(Mn).applyMatrix4(e);const I=K(i),E=Q(i,m);N(I,h,Kt),N(E,h,Qt);const C=P.intersectsBox(Kt),z=P.intersectsBox(Qt);T=C&&it(_,I,n,e,s,c,r,o,a+1,P,!l)||z&&it(_,E,n,e,s,c,r,o,a+1,P,!l),Tt.releasePrimitive(P)}}return T}const He=new $,Ws=new at,Co={strategy:Ei,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class ss{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,r=t._indirectBuffer,c=n.getIndex();let a;return e.cloneBuffers?a={roots:s.map(o=>o.slice()),index:c.array.slice(),indirectBuffer:r?r.slice():null}:a={roots:s,index:c.array,indirectBuffer:r},a}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:s,roots:r,indirectBuffer:c}=t,a=new ss(e,{...n,[xn]:!0});if(a._roots=r,a._indirectBuffer=c||null,n.setIndex){const o=e.getIndex();if(o===null){const u=new rn(t.index,1,!1);e.setIndex(u)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...Co,[xn]:!1},e),e.useSharedArrayBuffer&&!vo())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[xn]||(Wr(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new at)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?s=>n[s]:s=>s}refit(t=null){return(this.indirect?bo:oo)(this,t)}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),r=new Uint16Array(n);c(0);function c(a,o=0){const u=a*2,l=r[u+15]===an;if(l){const d=s[a+6],f=r[u+14];t(o,l,new Float32Array(n,a*4,6),d,f)}else{const d=a+we/4,f=s[a+6],h=s[a+7];t(o,l,new Float32Array(n,a*4,6),h)||(c(d,o+1),c(f,o+1))}}}raycast(t,e=_s){const n=this._roots,s=this.geometry,r=[],c=e.isMaterial,a=Array.isArray(e),o=s.groups,u=c?e.side:e,l=this.indirect?Ao:uo;for(let d=0,f=n.length;d<f;d++){const h=a?e[o[d].materialIndex].side:u,m=r.length;if(l(this,d,h,t,r),a){const A=o[d].materialIndex;for(let y=m,p=r.length;y<p;y++)r[y].face.materialIndex=A}}return r}raycastFirst(t,e=_s){const n=this._roots,s=this.geometry,r=e.isMaterial,c=Array.isArray(e);let a=null;const o=s.groups,u=r?e.side:e,l=this.indirect?So:po;for(let d=0,f=n.length;d<f;d++){const h=c?e[o[d].materialIndex].side:u,m=l(this,d,h,t);m!=null&&(a==null||m.distance<a.distance)&&(a=m,c&&(m.face.materialIndex=o[d].materialIndex))}return a}intersectsGeometry(t,e){let n=!1;const s=this._roots,r=this.indirect?Bo:ho;for(let c=0,a=s.length;c<a&&(n=r(this,c,t,e),!n);c++);return n}shapecast(t){const e=tt.getPrimitive(),n=this.indirect?lo:ro;let{boundsTraverseOrder:s,intersectsBounds:r,intersectsRange:c,intersectsTriangle:a}=t;if(c&&a){const d=c;c=(f,h,m,A,y)=>d(f,h,m,A,y)?!0:n(f,h,this,a,m,A,e)}else c||(a?c=(d,f,h,m)=>n(d,f,this,a,h,m,e):c=(d,f,h)=>h);let o=!1,u=0;const l=this._roots;for(let d=0,f=l.length;d<f;d++){const h=l[d];if(o=Qr(this,d,r,c,s,u),o)break;u+=h.byteLength}return tt.releasePrimitive(e),o}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:r}=n;const c=tt.getPrimitive(),a=this.geometry.index,o=this.geometry.attributes.position,u=this.indirect?m=>{const A=this.resolveTriangleIndex(m);k(c,A*3,a,o)}:m=>{k(c,m*3,a,o)},l=tt.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?m=>{const A=t.resolveTriangleIndex(m);k(l,A*3,d,f)}:m=>{k(l,m*3,d,f)};if(r){const m=(A,y,p,g,w,x,b,S)=>{for(let T=p,B=p+g;T<B;T++){h(T),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let _=A,M=A+y;_<M;_++)if(u(_),c.needsUpdate=!0,r(c,l,_,T,w,x,b,S))return!0}return!1};if(s){const A=s;s=function(y,p,g,w,x,b,S,T){return A(y,p,g,w,x,b,S,T)?!0:m(y,p,g,w,x,b,S,T)}}else s=m}return Eo(this,t,e,s)}intersectsBox(t,e){return He.set(t.min,t.max,e),He.needsUpdate=!0,this.shapecast({intersectsBounds:n=>He.intersectsBox(n),intersectsTriangle:n=>He.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},r=0,c=1/0){return(this.indirect?Lo:xo)(this,t,e,n,s,r,c)}closestPointToPoint(t,e={},n=0,s=1/0){return to(this,t,e,n,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{N(0,new Float32Array(n),Ws),t.union(Ws)}),t}}const Fi=1e-6,zo=Fi*.5,Ni=Math.pow(10,-Math.log10(Fi)),Vo=zo*Ni;function ct(i){return~~(i*Ni+Vo)}function Ro(i){return`${ct(i.x)},${ct(i.y)}`}function qs(i){return`${ct(i.x)},${ct(i.y)},${ct(i.z)}`}function Uo(i){return`${ct(i.x)},${ct(i.y)},${ct(i.z)},${ct(i.w)}`}function Fo(i,t,e){e.direction.subVectors(t,i).normalize();const n=i.dot(e.direction);return e.origin.copy(i).addScaledVector(e.direction,-n),e}function Di(){return typeof SharedArrayBuffer<"u"}function No(i){if(i.buffer instanceof SharedArrayBuffer)return i;const t=i.constructor,e=i.buffer,n=new SharedArrayBuffer(e.byteLength),s=new Uint8Array(e);return new Uint8Array(n).set(s,0),new t(n)}function Do(i,t=ArrayBuffer){return i>65535?new Uint32Array(new t(4*i)):new Uint16Array(new t(2*i))}function ko(i,t){if(!i.index){const e=i.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Do(e,n);i.setIndex(new rn(s,1));for(let r=0;r<e;r++)s[r]=r}}function jo(i){return i.index?i.index.count:i.attributes.position.count}function is(i){return jo(i)/3}const Ho=1e-8,Go=new v;function $o(i){return~~(i/3)}function Oo(i){return i%3}function Zs(i,t){return i.start-t.start}function Ys(i,t){return Go.subVectors(t,i.origin).dot(i.direction)}function Xo(i,t,e,n=Ho){i.sort(Zs),t.sort(Zs);for(let a=0;a<i.length;a++){const o=i[a];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>o.end)){if(o.end<l.start||l.end<o.start)continue;if(o.start<=l.start&&o.end>=l.end)r(l.end,o.end)||i.splice(a+1,0,{start:l.end,end:o.end,index:o.index}),o.end=l.start,l.start=0,l.end=0;else if(o.start>=l.start&&o.end<=l.end)r(o.end,l.end)||t.splice(u+1,0,{start:o.end,end:l.end,index:l.index}),l.end=o.start,o.start=0,o.end=0;else if(o.start<=l.start&&o.end<=l.end){const d=o.end;o.end=l.start,l.start=d}else if(o.start>=l.start&&o.end>=l.end){const d=l.end;l.end=o.start,o.start=d}else throw new Error}if(e.has(o.index)||e.set(o.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(o.index).push(l.index),e.get(l.index).push(o.index),c(l)&&(t.splice(u,1),u--),c(o)){i.splice(a,1),a--;break}}}s(i),s(t);function s(a){for(let o=0;o<a.length;o++)c(a[o])&&(a.splice(o,1),o--)}function r(a,o){return Math.abs(o-a)<n}function c(a){return Math.abs(a.end-a.start)<n}}const Js=1e-5,Ks=1e-4;class Wo{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let s=1/0,r=null;for(let o=0,u=e.length;o<u;o++){const l=e[o];if(c(l,t)&&c(l,n))continue;const d=a(l,t),f=a(l,n),h=Math.min(d,f);h<s&&(s=h,r=l)}return r;function c(o,u){const l=o.origin.distanceTo(u.origin)>Js;return o.direction.angleTo(u.direction)>Ks||l}function a(o,u){const l=o.origin.distanceTo(u.origin),d=o.direction.angleTo(u.direction);return l/Js+d/Ks}}}const Ln=new v,vn=new v,Ge=new mi;function qo(i,t,e){const n=i.attributes,s=i.index,r=n.position,c=new Map,a=new Map,o=Array.from(t),u=new Wo;for(let l=0,d=o.length;l<d;l++){const f=o[l],h=$o(f),m=Oo(f);let A=3*h+m,y=3*h+(m+1)%3;s&&(A=s.getX(A),y=s.getX(y)),Ln.fromBufferAttribute(r,A),vn.fromBufferAttribute(r,y),Fo(Ln,vn,Ge);let p,g=u.findClosestRay(Ge);g===null&&(g=Ge.clone(),u.addRay(g)),a.has(g)||a.set(g,{forward:[],reverse:[],ray:g}),p=a.get(g);let w=Ys(g,Ln),x=Ys(g,vn);w>x&&([w,x]=[x,w]),Ge.direction.dot(g.direction)<0?p.reverse.push({start:w,end:x,index:f}):p.forward.push({start:w,end:x,index:f})}return a.forEach(({forward:l,reverse:d},f)=>{Xo(l,d,c,e),l.length===0&&d.length===0&&a.delete(f)}),{disjointConnectivityMap:c,fragmentMap:a}}const Zo=new Dt,En=new v,Yo=new kt,Cn=["","",""];class Jo{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(r=>~~(r/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,s=this.disjointConnections.get(n);return s?s.map(r=>r%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:s,degenerateEpsilon:r}=this,c=e?w:g,a=new Map,{attributes:o}=t,u=e?Object.keys(o):null,l=t.index,d=o.position;let f=is(t);const h=f;let m=0;n&&(m=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let A=this.data;(!A||A.length<3*h)&&(A=new Int32Array(3*h)),A.fill(-1);let y=0,p=new Set;for(let x=m,b=f*3+m;x<b;x+=3){const S=x;for(let T=0;T<3;T++){let B=S+T;l&&(B=l.getX(B)),Cn[T]=c(B)}for(let T=0;T<3;T++){const B=(T+1)%3,_=Cn[T],M=Cn[B],L=`${M}_${_}`;if(a.has(L)){const P=S+T,I=a.get(L);A[P]=I,A[I]=P,a.delete(L),y+=2,p.delete(I)}else{const P=`${_}_${M}`,I=S+T;a.set(P,I),p.add(I)}}}if(s){const{fragmentMap:x,disjointConnectivityMap:b}=qo(t,p,r);p.clear(),x.forEach(({forward:S,reverse:T})=>{S.forEach(({index:B})=>p.add(B)),T.forEach(({index:B})=>p.add(B))}),this.unmatchedDisjointEdges=x,this.disjointConnections=b,y=f*3-p.size}this.matchedEdges=y,this.unmatchedEdges=p.size,this.data=A;function g(x){return En.fromBufferAttribute(d,x),qs(En)}function w(x){let b="";for(let S=0,T=u.length;S<T;S++){const B=o[u[S]];let _;switch(B.itemSize){case 1:_=ct(B.getX(x));break;case 2:_=Ro(Zo.fromBufferAttribute(B,x));break;case 3:_=qs(En.fromBufferAttribute(B,x));break;case 4:_=Uo(Yo.fromBufferAttribute(B,x));break}b!==""&&(b+="|"),b+=_}return b}}}class st extends ee{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new lt,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,s=e.elements;for(let r=0;r<16;r++)if(n[r]!==s[r])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=Di();if(n)for(const s in e){const r=e[s];if(r.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");r.array=No(r.array)}if(t.boundsTree||(ko(t,{useSharedArrayBuffer:n}),t.boundsTree=new ss(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Jo(t)),!t.groupIndices){const s=is(t),r=new Uint16Array(s),c=t.groups;for(let a=0,o=c.length;a<o;a++){const{start:u,count:l}=c[a];for(let d=u/3,f=(u+l)/3;d<f;d++)r[d]=a}t.groupIndices=r}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Ko=1e-14,zn=new v,Qs=new v,ti=new v;function St(i,t=Ko){zn.subVectors(i.b,i.a),Qs.subVectors(i.c,i.a),ti.subVectors(i.b,i.c);const e=zn.angleTo(Qs),n=zn.angleTo(ti),s=Math.PI-e-n;return Math.abs(e)<t||Math.abs(n)<t||Math.abs(s)<t||i.a.distanceToSquared(i.b)<t||i.a.distanceToSquared(i.c)<t||i.b.distanceToSquared(i.c)<t}const Vn=1e-10,ge=1e-10,Qo=1e-10,pt=new et,D=new et,ht=new v,Rn=new v,ei=new v,$e=new Kn,Un=new nt;class ta{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new X),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class ea{constructor(){this.trianglePool=new ta,this.triangles=[],this.normal=new v,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:s}=this;if(Array.isArray(t))for(let r=0,c=t.length;r<c;r++){const a=t[r];if(r===0)a.getNormal(s);else if(Math.abs(1-a.getNormal(ht).dot(s))>Vn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const o=n.getTriangle();o.copy(a),e.push(o)}else{t.getNormal(s);const r=n.getTriangle();r.copy(t),e.push(r)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(Rn).normalize(),Math.abs(1-Math.abs(Rn.dot(e)))<Qo){this.coplanarTriangleUsed=!0;for(let r=0,c=n.length;r<c;r++){const a=n[r];a.coplanarCount=0}const s=[t.a,t.b,t.c];for(let r=0;r<3;r++){const c=(r+1)%3,a=s[r],o=s[c];ht.subVectors(o,a).normalize(),ei.crossVectors(Rn,ht),$e.setFromNormalAndCoplanarPoint(ei,a),this.splitByPlane($e,t)}}else t.getPlane($e),this.splitByPlane($e,t)}splitByPlane(t,e){const{triangles:n,trianglePool:s}=this;Un.copy(e),Un.needsUpdate=!0;for(let r=0,c=n.length;r<c;r++){const a=n[r];if(!Un.intersectsTriangle(a,pt,!0))continue;const{a:o,b:u,c:l}=a;let d=0,f=-1,h=!1,m=[],A=[];const y=[o,u,l];for(let p=0;p<3;p++){const g=(p+1)%3;pt.start.copy(y[p]),pt.end.copy(y[g]);const w=t.distanceToPoint(pt.start),x=t.distanceToPoint(pt.end);if(Math.abs(w)<ge&&Math.abs(x)<ge){h=!0;break}if(w>0?m.push(p):A.push(p),Math.abs(w)<ge)continue;let b=!!t.intersectLine(pt,ht);!b&&Math.abs(x)<ge&&(ht.copy(pt.end),b=!0),b&&!(ht.distanceTo(pt.start)<Vn)&&(ht.distanceTo(pt.end)<Vn&&(f=p),d===0?D.start.copy(ht):D.end.copy(ht),d++)}if(!h&&d===2&&D.distance()>ge)if(f!==-1){f=(f+1)%3;let p=0;p===f&&(p=(p+1)%3);let g=p+1;g===f&&(g=(g+1)%3);const w=s.getTriangle();w.a.copy(y[g]),w.b.copy(D.end),w.c.copy(D.start),St(w)||n.push(w),a.a.copy(y[p]),a.b.copy(D.start),a.c.copy(D.end),St(a)&&(n.splice(r,1),r--,c--)}else{const p=m.length>=2?A[0]:m[0];if(p===0){let S=D.start;D.start=D.end,D.end=S}const g=(p+1)%3,w=(p+2)%3,x=s.getTriangle(),b=s.getTriangle();y[g].distanceToSquared(D.start)<y[w].distanceToSquared(D.end)?(x.a.copy(y[g]),x.b.copy(D.start),x.c.copy(D.end),b.a.copy(y[g]),b.b.copy(y[w]),b.c.copy(D.start)):(x.a.copy(y[w]),x.b.copy(D.start),x.c.copy(D.end),b.a.copy(y[g]),b.b.copy(y[w]),b.c.copy(D.end)),a.a.copy(y[p]),a.b.copy(D.end),a.c.copy(D.start),St(x)||n.push(x),St(b)||n.push(b),St(a)&&(n.splice(r,1),r--,c--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function na(i){return i=~~i,i+4-i%4}class ni{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=Di()?SharedArrayBuffer:ArrayBuffer,s=new e(new n(na(t*e.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let s=0,r=t.length;s<r;s++)e[n+s]=t[s];this.length+=t.length}clear(){this.length=0}}class sa{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let s=0;for(let r=0;r<e;r++){const c=n[r];s+=c[t].length}return s}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const s={};e.push(s);for(const r in n){const c=n[r],a=new ni(c.type);a.itemSize=c.itemSize,a.normalized=c.normalized,s[r]=a}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,s){const{groupAttributes:r}=this,a=r[0][t];if(a){if(a.type!==e)for(let o=0,u=r.length;o<u;o++){const l=r[o][t];l.setType(e),l.itemSize=n,l.normalized=s}}else for(let o=0,u=r.length;o<u;o++){const l=new ni(e);l.itemSize=n,l.normalized=s,r[o][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const n in e)e[n].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class si{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:s}=this;n[t]||(n[t]=[],s.push(t)),n[t].push(e)}}const Et=0,rs=1,ia=2,ra=3,oa=4,ki=5,ji=6,Y=new mi,ii=new lt,H=new X,mt=new v,ri=new kt,oi=new kt,ai=new kt,Fn=new kt,Oe=new kt,Xe=new kt,ci=new et,Nn=new v,Dn=1e-8,aa=1e-15,Rt=-1,Ut=1,Ye=-2,Je=2,be=0,zt=1,os=2,ca=1e-14;let Ke=null;function li(i){Ke=i}function Hi(i,t){i.getMidpoint(Y.origin),i.getNormal(Y.direction);const e=t.raycastFirst(Y,Qn);return!!(e&&Y.direction.dot(e.face.normal)>0)?Rt:Ut}function la(i,t){function e(){return Math.random()-.5}i.getNormal(Nn),Y.direction.copy(Nn),i.getMidpoint(Y.origin);const n=3;let s=0,r=1/0;for(let c=0;c<n;c++){Y.direction.x+=e()*Dn,Y.direction.y+=e()*Dn,Y.direction.z+=e()*Dn,Y.direction.multiplyScalar(-1);const a=t.raycastFirst(Y,Qn);if(!!(a&&Y.direction.dot(a.face.normal)>0)&&s++,a!==null&&(r=Math.min(r,a.distance)),r<=aa)return a.face.normal.dot(Nn)>0?Je:Ye;if(s/n>.5||(c-s+1)/n>.5)break}return s/n>.5?Rt:Ut}function ua(i,t){const e=new si,n=new si;return ii.copy(i.matrixWorld).invert().multiply(t.matrixWorld),i.geometry.boundsTree.bvhcast(t.geometry.boundsTree,ii,{intersectsTriangles(s,r,c,a){if(!St(s)&&!St(r)){let o=s.intersectsTriangle(r,ci,!0);if(!o){const u=s.plane,l=r.plane,d=u.normal,f=l.normal;d.dot(f)===1&&Math.abs(u.constant-l.constant)<ca&&(o=!0)}if(o){let u=i.geometry.boundsTree.resolveTriangleIndex(c),l=t.geometry.boundsTree.resolveTriangleIndex(a);e.add(u,l),n.add(l,u),Ke&&(Ke.addEdge(ci),Ke.addIntersectingTriangles(c,s,a,r))}}return!1}}),{aIntersections:e,bIntersections:n}}function fa(i,t,e,n,s,r,c=!1){const a=e.attributes,o=e.index,u=i*3,l=o.getX(u+0),d=o.getX(u+1),f=o.getX(u+2);for(const h in r){const m=a[h],A=r[h];if(!(h in a))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const y=m.itemSize;h==="position"?(H.a.fromBufferAttribute(m,l).applyMatrix4(n),H.b.fromBufferAttribute(m,d).applyMatrix4(n),H.c.fromBufferAttribute(m,f).applyMatrix4(n),kn(H.a,H.b,H.c,t,3,A,c)):h==="normal"?(H.a.fromBufferAttribute(m,l).applyNormalMatrix(s),H.b.fromBufferAttribute(m,d).applyNormalMatrix(s),H.c.fromBufferAttribute(m,f).applyNormalMatrix(s),c&&(H.a.multiplyScalar(-1),H.b.multiplyScalar(-1),H.c.multiplyScalar(-1)),kn(H.a,H.b,H.c,t,3,A,c,!0)):(ri.fromBufferAttribute(m,l),oi.fromBufferAttribute(m,d),ai.fromBufferAttribute(m,f),kn(ri,oi,ai,t,y,A,c))}}function da(i,t,e,n,s,r,c,a=!1){jn(i,n,s,r,c,a),jn(a?e:t,n,s,r,c,a),jn(a?t:e,n,s,r,c,a)}function Gi(i,t,e=!1){switch(i){case Et:if(t===Ut||t===Je&&!e)return zt;break;case rs:if(e){if(t===Rt)return be}else if(t===Ut||t===Ye)return zt;break;case ia:if(e){if(t===Ut||t===Ye)return zt}else if(t===Rt)return be;break;case oa:if(t===Rt)return be;if(t===Ut)return zt;break;case ra:if(t===Rt||t===Je&&!e)return zt;break;case ki:if(!e&&(t===Ut||t===Ye))return zt;break;case ji:if(!e&&(t===Rt||t===Je))return zt;break;default:throw new Error(`Unrecognized CSG operation enum "${i}".`)}return os}function kn(i,t,e,n,s,r,c=!1,a=!1){const o=u=>{r.push(u.x),s>1&&r.push(u.y),s>2&&r.push(u.z),s>3&&r.push(u.w)};Fn.set(0,0,0,0).addScaledVector(i,n.a.x).addScaledVector(t,n.a.y).addScaledVector(e,n.a.z),Oe.set(0,0,0,0).addScaledVector(i,n.b.x).addScaledVector(t,n.b.y).addScaledVector(e,n.b.z),Xe.set(0,0,0,0).addScaledVector(i,n.c.x).addScaledVector(t,n.c.y).addScaledVector(e,n.c.z),a&&(Fn.normalize(),Oe.normalize(),Xe.normalize()),o(Fn),c?(o(Xe),o(Oe)):(o(Oe),o(Xe))}function jn(i,t,e,n,s,r=!1){for(const c in s){const a=t[c],o=s[c];if(!(c in t))throw new Error(`CSG Operations: Attribute ${c} no available on geometry.`);const u=a.itemSize;c==="position"?(mt.fromBufferAttribute(a,i).applyMatrix4(e),o.push(mt.x,mt.y,mt.z)):c==="normal"?(mt.fromBufferAttribute(a,i).applyNormalMatrix(n),r&&mt.multiplyScalar(-1),o.push(mt.x,mt.y,mt.z)):(o.push(a.getX(i)),u>1&&o.push(a.getY(i)),u>2&&o.push(a.getZ(i)),u>3&&o.push(a.getW(i)))}}class pa{constructor(t){this.triangle=new X().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new X().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class ui{constructor(){this.data={}}addTriangleIntersection(t,e,n,s){const{data:r}=this;r[t]||(r[t]=new pa(e)),r[t].addTriangle(n,s)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const s in e)n.push(e[s].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,s=new Set,r=[],c=a=>{if(n[a])if(e!==null)n[a].intersects[e]&&r.push(n[a].intersects[e]);else{const o=n[a].intersects;for(const u in o)s.has(u)||(s.add(u),r.push(o[u]))}};if(t!==null)c(t);else for(const a in n)c(a);return r}reset(){this.data={}}}class ha{constructor(){this.enabled=!1,this.triangleIntersectsA=new ui,this.triangleIntersectsB=new ui,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,s){const{triangleIntersectsA:r,triangleIntersectsB:c}=this;r.addTriangleIntersection(t,e,n,s),c.addTriangleIntersection(n,s,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),li(this))}complete(){this.enabled&&li(null)}}const _t=new lt,tn=new yr,Vt=new X,We=new X,At=new X,qe=new X,rt=[],Nt=[];function ma(i){for(const t of i)return t}function ga(i,t,e,n,s,r={}){const{useGroups:c=!0}=r,{aIntersections:a,bIntersections:o}=ua(i,t),u=[];let l=null,d;return d=c?0:-1,fi(i,t,a,e,!1,n,s,d),di(i,t,a,e,!1,s,d),e.findIndex(h=>h!==ji&&h!==ki)!==-1&&(d=c?i.geometry.groups.length||1:-1,fi(t,i,o,e,!0,n,s,d),di(t,i,o,e,!0,s,d)),rt.length=0,Nt.length=0,{groups:u,materials:l}}function fi(i,t,e,n,s,r,c,a=0){const o=i.matrixWorld.determinant()<0;_t.copy(t.matrixWorld).invert().multiply(i.matrixWorld),tn.getNormalMatrix(i.matrixWorld).multiplyScalar(o?-1:1);const u=i.geometry.groupIndices,l=i.geometry.index,d=i.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,m=t.geometry.attributes.position,A=e.ids,y=e.intersectionSet;for(let p=0,g=A.length;p<g;p++){const w=A[p],x=a===-1?0:u[w]+a,b=3*w,S=l.getX(b+0),T=l.getX(b+1),B=l.getX(b+2);Vt.a.fromBufferAttribute(d,S).applyMatrix4(_t),Vt.b.fromBufferAttribute(d,T).applyMatrix4(_t),Vt.c.fromBufferAttribute(d,B).applyMatrix4(_t),r.reset(),r.initialize(Vt);const _=y[w];for(let L=0,P=_.length;L<P;L++){const I=3*_[L],E=h.getX(I+0),C=h.getX(I+1),z=h.getX(I+2);We.a.fromBufferAttribute(m,E),We.b.fromBufferAttribute(m,C),We.c.fromBufferAttribute(m,z),r.splitByTriangle(We)}const M=r.triangles;for(let L=0,P=M.length;L<P;L++){const I=M[L],E=r.coplanarTriangleUsed?la(I,f):Hi(I,f);rt.length=0,Nt.length=0;for(let C=0,z=n.length;C<z;C++){const j=Gi(n[C],E,s);j!==os&&(Nt.push(j),rt.push(c[C].getGroupAttrSet(x)))}if(rt.length!==0){Vt.getBarycoord(I.a,qe.a),Vt.getBarycoord(I.b,qe.b),Vt.getBarycoord(I.c,qe.c);for(let C=0,z=rt.length;C<z;C++){const j=rt[C],Ct=Nt[C]===be;fa(w,qe,i.geometry,i.matrixWorld,tn,j,o!==Ct)}}}}return A.length}function di(i,t,e,n,s,r,c=0){const a=i.matrixWorld.determinant()<0;_t.copy(t.matrixWorld).invert().multiply(i.matrixWorld),tn.getNormalMatrix(i.matrixWorld).multiplyScalar(a?-1:1);const o=t.geometry.boundsTree,u=i.geometry.groupIndices,l=i.geometry.index,d=i.geometry.attributes,f=d.position,h=[],m=i.geometry.halfEdges,A=new Set,y=is(i.geometry);for(let p=0,g=y;p<g;p++)p in e.intersectionSet||A.add(p);for(;A.size>0;){const p=ma(A);A.delete(p),h.push(p);const g=3*p,w=l.getX(g+0),x=l.getX(g+1),b=l.getX(g+2);At.a.fromBufferAttribute(f,w).applyMatrix4(_t),At.b.fromBufferAttribute(f,x).applyMatrix4(_t),At.c.fromBufferAttribute(f,b).applyMatrix4(_t);const S=Hi(At,o);Nt.length=0,rt.length=0;for(let T=0,B=n.length;T<B;T++){const _=Gi(n[T],S,s);_!==os&&(Nt.push(_),rt.push(r[T]))}for(;h.length>0;){const T=h.pop();for(let B=0;B<3;B++){const _=m.getSiblingTriangleIndex(T,B);_!==-1&&A.has(_)&&(h.push(_),A.delete(_))}if(rt.length!==0){const B=3*T,_=l.getX(B+0),M=l.getX(B+1),L=l.getX(B+2),P=c===-1?0:u[T]+c;if(At.a.fromBufferAttribute(f,_),At.b.fromBufferAttribute(f,M),At.c.fromBufferAttribute(f,L),!St(At))for(let I=0,E=rt.length;I<E;I++){const C=Nt[I],z=rt[I].getGroupAttrSet(P),j=C===be;da(_,M,L,d,i.matrixWorld,tn,z,j!==a)}}}}}function ya(i){for(let t=0;t<i.length-1;t++){const e=i[t],n=i[t+1];if(e.materialIndex===n.materialIndex){const s=e.start,r=n.start+n.count;n.start=s,n.count=r-s,i.splice(t,1),t--}}}function wa(i,t,e,n){e.clear();const s=i.attributes;for(let r=0,c=n.length;r<c;r++){const a=n[r],o=s[a];e.initializeArray(a,o.array.constructor,o.itemSize,o.normalized)}for(const r in e.attributes)n.includes(r)||e.delete(r);for(const r in t.attributes)n.includes(r)||(t.deleteAttribute(r),t.dispose())}function xa(i,t,e){let n=!1,s=-1;const r=i.attributes,c=t.groupAttributes[0];for(const o in c){const u=t.getTotalLength(o),l=t.getType(o),d=t.getItemSize(o),f=t.getNormalized(o);let h=r[o];(!h||h.array.length<u)&&(h=new rn(new l(u),d,f),i.setAttribute(o,h),n=!0);let m=0;for(let A=0,y=Math.min(e.length,t.groupCount);A<y;A++){const p=e[A].index,{array:g,type:w,length:x}=t.groupAttributes[p][o],b=new w(g.buffer,0,x);h.array.set(b,m),m+=b.length}h.needsUpdate=!0,s=u/h.itemSize}if(i.index){const o=i.index.array;if(o.length<s)i.index=null,n=!0;else for(let u=0,l=o.length;u<l;u++)o[u]=u}let a=0;i.clearGroups();for(let o=0,u=Math.min(e.length,t.groupCount);o<u;o++){const{index:l,materialIndex:d}=e[o],f=t.getCount(l);f!==0&&(i.addGroup(a,f,d),a+=f)}i.setDrawRange(0,s),i.boundsTree=null,n&&i.dispose()}function pi(i,t){let e=t;return Array.isArray(t)||(e=[],i.forEach(n=>{e[n.materialIndex]=t})),e}class $i{constructor(){this.triangleSplitter=new ea,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new ha}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,n,s=new st){let r=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(s)||(s=[s],r=!1),s.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:c,attributeData:a,attributes:o,useGroups:u,consolidateGroups:l,debug:d}=this;for(;a.length<s.length;)a.push(new sa);s.forEach((p,g)=>{wa(t.geometry,p.geometry,a[g],o)}),d.init(),ga(t,e,n,c,a,{useGroups:u}),d.complete();const f=this.getGroupRanges(t.geometry),h=pi(f,t.material),m=this.getGroupRanges(e.geometry),A=pi(m,e.material);m.forEach(p=>p.materialIndex+=h.length);let y=[...f,...m].map((p,g)=>({...p,index:g}));if(u){const p=[...h,...A];l&&(y=y.map(w=>{const x=p[w.materialIndex];return w.materialIndex=p.indexOf(x),w}).sort((w,x)=>w.materialIndex-x.materialIndex));const g=[];for(let w=0,x=p.length;w<x;w++){let b=!1;for(let S=0,T=y.length;S<T;S++){const B=y[S];B.materialIndex===w&&(b=!0,B.materialIndex=g.length)}b&&g.push(p[w])}s.forEach(w=>{w.material=g})}else y=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach(p=>{p.material=h[0]});return s.forEach((p,g)=>{const w=p.geometry;xa(w,a[g],y),l&&ya(w.groups)}),r?s:s[0]}evaluateHierarchy(t,e=new st){t.updateMatrixWorld(!0);const n=(r,c)=>{const a=r.children;for(let o=0,u=a.length;o<u;o++){const l=a[o];l.isOperationGroup?n(l,c):c(l)}},s=r=>{const c=r.children;let a=!1;for(let u=0,l=c.length;u<l;u++){const d=c[u];a=s(d)||a}const o=r.isDirty();if(o&&r.markUpdated(),a&&!r.isOperationGroup){let u;return n(r,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(r,l,l.operation)}),r._cachedGeometry=u.geometry,r._cachedMaterials=u.material,!0}else return a||o};return s(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const{frameThickness:as,frameWidthOuter:Oi,frameHeightOuter:Xi,slatWidth:ne,x:ba,y:Aa,frameWidthInner:Wi,frameHeightInner:qi}=Ft,oe=new Se({roughness:.5,metalness:.7,wireframe:Be,color:34918}),Zi=new st(new en(Oi,Xi,as),oe);Zi.updateMatrixWorld();const Yi=new st(new en(Wi,qi,as),oe);Yi.updateMatrixWorld();const Pe=new $i,Ta=Pe.evaluate(Zi,Yi,rs),cs=new st(new ut(Wi+1,ne*2,ne*2,R.roundSegments,R.roundRadius/2),oe);cs.position.set(0,-2.2,0);cs.updateMatrixWorld();const ls=new st(new ut(.6,qi+1,.6,R.roundSegments,R.roundRadius/2),oe);ls.position.set(0,0,0);ls.updateMatrixWorld();let Te=Pe.evaluate(cs,ls,Et);const us=new st(new ut(ne,13.4,ne,R.roundSegments,R.roundRadius/2),oe);us.position.set(-8.2,4.6,0);us.updateMatrixWorld();Te=Pe.evaluate(Te,us,Et);const fs=new st(new ut(ne,13.4,ne,R.roundSegments,R.roundRadius/2),oe);fs.position.set(8.2,4.6,0);fs.updateMatrixWorld();Te=Pe.evaluate(Te,fs,Et);const ds=Pe.evaluate(Ta,Te,Et);ds.position.set(Oi/2+ba,Xi/2+Aa,-(R.wallThickness-as/2));ds.updateMatrixWorld();const{floorXLength:ft,floorZLength:dt,wallHeight:xt,wallThickness:V,roundRadius:ae,roundSegments:ce,ny:Sa}=R,ln=new $i,ps=new Se({roughness:1,metalness:0,wireframe:Be,transparent:!0,opacity:0}),Ba=new ut(ft+1,V,dt+1,ce,ae),_a=new Se({roughness:1,metalness:0,wireframe:Be}),hs=new st(Ba,_a);hs.position.set(ft/2-1/2,-V/2,dt/2-1/2);hs.updateMatrixWorld();const ms=new Se({roughness:1,metalness:0,wireframe:Be}),Pa=new ut(V,xt,dt+1,ce,ae),gs=new st(Pa,ms);gs.position.set(-V/2,xt/2-V,dt/2-1/2);gs.updateMatrixWorld();const Ma=new ut(ft+V,xt,V,ce,ae),ys=new st(Ma,ms);ys.position.set(ft/2-V/2,xt/2-V,-V/2);ys.updateMatrixWorld();const Ia=new en(Ft.frameWidthOuter,Ft.frameHeightOuter,V),ws=new st(Ia,ms);ws.position.set(Ft.frameWidthOuter/2+Ft.x,Ft.frameHeightOuter/2+Ft.y,-V/2);ws.updateMatrixWorld();const Ji=ln.evaluate(ys,ws,rs);Ji.updateMatrixWorld();const un=ln.evaluate(Ji,ds,Et);un.receiveShadow=!0;un.castShadow=!0;un.updateMatrixWorld();const La=new ut(ft+V+V,xt,V,ce,ae),fn=new ee(La,ps);fn.position.set(ft/2,xt/2-V,dt+V/2);fn.receiveShadow=!0;fn.castShadow=!0;const va=new ut(V,xt,dt+V,ce,ae),dn=new ee(va,ps);dn.position.set(ft+V/2,xt/2-V,dt/2-V/2);dn.receiveShadow=!0;dn.castShadow=!0;const Ea=new ut(ft+V+V,V,dt+V+V,ce,ae),pn=new ee(Ea,ps);pn.position.set(ft/2,xt-V/2,dt/2);pn.receiveShadow=!0;pn.castShadow=!0;const jt=new Jn;jt.position.set(-ft/2,-Sa,-dt/2);let se=ln.evaluate(gs,un,Et);se.updateMatrixWorld();se=ln.evaluate(se,hs,Et);se.castShadow=!0;se.receiveShadow=!0;jt.add(se);jt.add(fn);jt.add(dn);jt.add(pn);F.add(jt);const xs=new wr(jt);xs.visible=!1;F.add(xs);const Ca=new xr,Ki=()=>{Ps.begin(),ot.clear(),xs.update(),ts.update();const i=Ca.getDelta();yn.animating&&yn.update(i),ot.render(F,_e),yn.render(ot),Ps.end(),requestAnimationFrame(Ki)},{floorXLength:za,floorZLength:Va,ny:Ra}=R,bs=new br(42);bs.position.set(-za/2,-Ra,-Va/2);bs.visible=!1;F.add(bs);const{floorXLength:Ua,floorZLength:Fa,ny:Na}=R,As=new Jn;As.position.set(-Ua/2,-Na,-Fa/2);const Da=gi({title:"Sofa"}),ka=new Lr(Da);ka.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/ikeaSofa.obj",i=>{i.scale.set(10,10,10),i.rotation.y=-Math.PI/2,i.position.set(33,0,15);const e=i.children[0],n=i.children[1];hi(e),hi(n);const s=gi({title:"Sofa texture",onLoad:()=>{const l=new Se({map:c,normalMap:a,aoMap:o,roughnessMap:u});e.material=l,As.add(i)}}),r=new Ar(s),c=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/Fabric030_1K-JPG_Color.jpg");c.colorSpace=Tr,c.wrapS=Ms,c.wrapT=Ms;const a=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/Fabric030_1K-JPG_NormalGL.jpg"),o=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/Fabric030_1K-JPG_AmbientOcclusion.jpg"),u=r.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/Fabric030_1K-JPG_Roughness.jpg")});const hi=i=>{i.castShadow=!0,i.receiveShadow=!0,i.material.wireframe=Be};F.add(As);Ki();Sr(Ae,_e,ot);on.add(ts,"autoRotate");

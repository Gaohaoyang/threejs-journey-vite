import"./modulepreload-polyfill-B5Qt9EMX.js";import{v as C,aP as Oe,S as xi,aQ as Ai,p as bi,aR as Ti,aS as Ws,o as Si,aT as Bi,G as Pi,P as _i,W as Mi,aU as Ii,O as Ei,c as Ci,B as We,V as vt,aV as Un,aW as Q,aX as W,aq as zi,u as at,ap as rt,aY as Li,X as Fn,aj as os,aZ as Gs,a_ as Nt,M as Ge,a$ as Ri,a as Xe,a3 as vi,b0 as Ni,s as cs,b as Ui,A as Fi,l as Vi}from"./OrbitControls-DYPXcrj1.js";const ee=new C;function q(n,t,e,s,i,o){const a=2*Math.PI*i/4,c=Math.max(o-2*i,0),r=Math.PI/4;ee.copy(t),ee[s]=0,ee.normalize();const u=.5*a/(a+c),l=1-ee.angleTo(n)/r;return Math.sign(ee[e])===1?l*u:c/(a+c)+u+u*(1-l)}class lt extends Oe{constructor(t=1,e=1,s=1,i=2,o=.1){if(i=i*2+1,o=Math.min(t/2,e/2,s/2,o),super(1,1,1,i,i,i),i===1)return;const a=this.toNonIndexed();this.index=null,this.attributes.position=a.attributes.position,this.attributes.normal=a.attributes.normal,this.attributes.uv=a.attributes.uv;const c=new C,r=new C,u=new C(t,e,s).divideScalar(2).subScalar(o),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,y=new C,T=.5/i;for(let w=0,p=0;w<l.length;w+=3,p+=2)switch(c.fromArray(l,w),r.copy(c),r.x-=Math.sign(r.x)*T,r.y-=Math.sign(r.y)*T,r.z-=Math.sign(r.z)*T,r.normalize(),l[w+0]=u.x*Math.sign(c.x)+r.x*o,l[w+1]=u.y*Math.sign(c.y)+r.y*o,l[w+2]=u.z*Math.sign(c.z)+r.z*o,d[w+0]=r.x,d[w+1]=r.y,d[w+2]=r.z,Math.floor(w/h)){case 0:y.set(1,0,0),f[p+0]=q(y,r,"z","y",o,s),f[p+1]=1-q(y,r,"y","z",o,e);break;case 1:y.set(-1,0,0),f[p+0]=1-q(y,r,"z","y",o,s),f[p+1]=1-q(y,r,"y","z",o,e);break;case 2:y.set(0,1,0),f[p+0]=1-q(y,r,"x","z",o,t),f[p+1]=q(y,r,"z","x",o,s);break;case 3:y.set(0,-1,0),f[p+0]=1-q(y,r,"x","z",o,t),f[p+1]=1-q(y,r,"z","x",o,s);break;case 4:y.set(0,0,1),f[p+0]=1-q(y,r,"x","y",o,t),f[p+1]=1-q(y,r,"y","x",o,e);break;case 5:y.set(0,0,-1),f[p+0]=q(y,r,"x","y",o,t),f[p+1]=1-q(y,r,"y","x",o,e);break}}}const ot=new xi,qe=!1,X={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},Lt={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},ki=new Ai("#ffffff",.3);ot.add(ki);const H=new bi("#ffffff",1);H.position.set(20,20,-30);H.castShadow=!0;H.shadow.mapSize.width=1024;H.shadow.mapSize.height=1024;H.shadow.camera.near=1;H.shadow.camera.far=100;H.shadow.camera.top=50;H.shadow.camera.right=50;H.shadow.camera.bottom=-50;H.shadow.camera.left=-50;H.shadow.normalBias=.1;ot.add(H);const Xs=new Ti(H,10);ot.add(Xs);Xs.visible=!1;const qs=new Ws(H.shadow.camera);ot.add(qs);qs.visible=!1;const Pt=new Si(16777215,20,40,1);Pt.position.set(X.wallThickness,6,X.wallThickness);Pt.castShadow=!0;Pt.shadow.camera.near=1;Pt.shadow.camera.far=30;ot.add(Pt);const js=new Bi(Pt,10);ot.add(js);js.visible=!1;const Zs=new Ws(Pt.shadow.camera);ot.add(Zs);Zs.visible=!1;const Vn=new Pi;Vn.add(H,"visible").name("directionalLight");Vn.add(Pt,"visible").name("pointLight");const pe={width:window.innerWidth,height:window.innerHeight},ye=new _i(20,pe.width/pe.height,.1,1e5);ye.position.set(120,30,120);const Ys=document.querySelector("canvas.webgl");if(Ys===null)throw new Error("Cannot find the canvas element");const it=new Mi({canvas:Ys,antialias:!0});it.setSize(pe.width,pe.height);it.setPixelRatio(Math.min(window.devicePixelRatio,2));it.autoClear=!1;it.shadowMap.enabled=!0;it.shadowMap.type=Ii;const kn=new Ei(ye,it.domElement);kn.enableDamping=!0;const en=Ci(ye,it.domElement),Ks=0,Di=1,Hi=2,as=2,nn=1.25,ls=1,ue=6*4+4+4,je=65535,$i=Math.pow(2,-24),sn=Symbol("SKIP_GENERATION");function Oi(n){return n.index?n.index.count:n.attributes.position.count}function Kt(n){return Oi(n)/3}function Wi(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Gi(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Wi(e,s);n.setIndex(new We(i,1));for(let o=0;o<e;o++)i[o]=o}}function Js(n){const t=Kt(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,o=Math.max(0,s),a=Math.min(t,i)-o;return[{offset:Math.floor(o),count:Math.floor(a)}]}function Qs(n){if(!n.groups||!n.groups.length)return Js(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,o=(s.start+s.count)/3;for(const c of n.groups){const r=c.start/3,u=(c.start+c.count)/3;e.add(Math.max(i,r)),e.add(Math.min(o,u))}const a=Array.from(e.values()).sort((c,r)=>c-r);for(let c=0;c<a.length-1;c++){const r=a[c],u=a[c+1];t.push({offset:Math.floor(r),count:Math.floor(u-r)})}return t}function Xi(n){if(n.groups.length===0)return!1;const t=Kt(n),e=Qs(n).sort((o,a)=>o.offset-a.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:o})=>i+=o),t!==i}function rn(n,t,e,s,i){let o=1/0,a=1/0,c=1/0,r=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,y=-1/0,T=-1/0,w=-1/0;for(let p=t*6,m=(t+e)*6;p<m;p+=6){const g=n[p+0],A=n[p+1],x=g-A,S=g+A;x<o&&(o=x),S>r&&(r=S),g<d&&(d=g),g>y&&(y=g);const b=n[p+2],B=n[p+3],P=b-B,M=b+B;P<a&&(a=P),M>u&&(u=M),b<f&&(f=b),b>T&&(T=b);const E=n[p+4],_=n[p+5],I=E-_,z=E+_;I<c&&(c=I),z>l&&(l=z),E<h&&(h=E),E>w&&(w=E)}s[0]=o,s[1]=a,s[2]=c,s[3]=r,s[4]=u,s[5]=l,i[0]=d,i[1]=f,i[2]=h,i[3]=y,i[4]=T,i[5]=w}function qi(n,t=null,e=null,s=null){const i=n.attributes.position,o=n.index?n.index.array:null,a=Kt(n),c=i.normalized;let r;t===null?(r=new Float32Array(a*6*4),e=0,s=a):(r=t,e=e||0,s=s||a);const u=i.array,l=i.offset||0;let d=3;i.isInterleavedBufferAttribute&&(d=i.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+s;h++){const y=h*3,T=h*6;let w=y+0,p=y+1,m=y+2;o&&(w=o[w],p=o[p],m=o[m]),c||(w=w*d+l,p=p*d+l,m=m*d+l);for(let g=0;g<3;g++){let A,x,S;c?(A=i[f[g]](w),x=i[f[g]](p),S=i[f[g]](m)):(A=u[w+g],x=u[p+g],S=u[m+g]);let b=A;x<b&&(b=x),S<b&&(b=S);let B=A;x>B&&(B=x),S>B&&(B=S);const P=(B-b)/2,M=g*2;r[T+M+0]=b+P,r[T+M+1]=P+(Math.abs(b)+P)*$i}}return r}function U(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function us(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function fs(n,t){t.set(n)}function ds(n,t,e){let s,i;for(let o=0;o<3;o++){const a=o+3;s=n[o],i=t[o],e[o]=s<i?s:i,s=n[a],i=t[a],e[a]=s>i?s:i}}function me(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],o=t[n+2*s+1],a=i-o,c=i+o;a<e[s]&&(e[s]=a),c>e[s+3]&&(e[s+3]=c)}}function ne(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const yt=32,ji=(n,t)=>n.candidate-t.candidate,wt=new Array(yt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),we=new Float32Array(6);function Zi(n,t,e,s,i,o){let a=-1,c=0;if(o===Ks)a=us(t),a!==-1&&(c=(t[a]+t[a+3])/2);else if(o===Di)a=us(n),a!==-1&&(c=Yi(e,s,i,a));else if(o===Hi){const r=ne(n);let u=nn*i;const l=s*6,d=(s+i)*6;for(let f=0;f<3;f++){const h=t[f],w=(t[f+3]-h)/yt;if(i<yt/4){const p=[...wt];p.length=i;let m=0;for(let A=l;A<d;A+=6,m++){const x=p[m];x.candidate=e[A+2*f],x.count=0;const{bounds:S,leftCacheBounds:b,rightCacheBounds:B}=x;for(let P=0;P<3;P++)B[P]=1/0,B[P+3]=-1/0,b[P]=1/0,b[P+3]=-1/0,S[P]=1/0,S[P+3]=-1/0;me(A,e,S)}p.sort(ji);let g=i;for(let A=0;A<g;A++){const x=p[A];for(;A+1<g&&p[A+1].candidate===x.candidate;)p.splice(A+1,1),g--}for(let A=l;A<d;A+=6){const x=e[A+2*f];for(let S=0;S<g;S++){const b=p[S];x>=b.candidate?me(A,e,b.rightCacheBounds):(me(A,e,b.leftCacheBounds),b.count++)}}for(let A=0;A<g;A++){const x=p[A],S=x.count,b=i-x.count,B=x.leftCacheBounds,P=x.rightCacheBounds;let M=0;S!==0&&(M=ne(B)/r);let E=0;b!==0&&(E=ne(P)/r);const _=ls+nn*(M*S+E*b);_<u&&(a=f,u=_,c=x.candidate)}}else{for(let g=0;g<yt;g++){const A=wt[g];A.count=0,A.candidate=h+w+g*w;const x=A.bounds;for(let S=0;S<3;S++)x[S]=1/0,x[S+3]=-1/0}for(let g=l;g<d;g+=6){let S=~~((e[g+2*f]-h)/w);S>=yt&&(S=yt-1);const b=wt[S];b.count++,me(g,e,b.bounds)}const p=wt[yt-1];fs(p.bounds,p.rightCacheBounds);for(let g=yt-2;g>=0;g--){const A=wt[g],x=wt[g+1];ds(A.bounds,x.rightCacheBounds,A.rightCacheBounds)}let m=0;for(let g=0;g<yt-1;g++){const A=wt[g],x=A.count,S=A.bounds,B=wt[g+1].rightCacheBounds;x!==0&&(m===0?fs(S,we):ds(S,we,we)),m+=x;let P=0,M=0;m!==0&&(P=ne(we)/r);const E=i-m;E!==0&&(M=ne(B)/r);const _=ls+nn*(P*m+M*E);_<u&&(a=f,u=_,c=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:a,pos:c}}function Yi(n,t,e,s){let i=0;for(let o=t,a=t+e;o<a;o++)i+=n[o*6+s*2];return i/e}class on{constructor(){this.boundingData=new Float32Array(6)}}function Ki(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;a<=c&&e[a*6+u]<r;)a++;for(;a<=c&&e[c*6+u]>=r;)c--;if(a<c){for(let l=0;l<3;l++){let d=t[a*3+l];t[a*3+l]=t[c*3+l],t[c*3+l]=d}for(let l=0;l<6;l++){let d=e[a*6+l];e[a*6+l]=e[c*6+l],e[c*6+l]=d}a++,c--}else return a}}function Ji(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;a<=c&&e[a*6+u]<r;)a++;for(;a<=c&&e[c*6+u]>=r;)c--;if(a<c){let l=n[a];n[a]=n[c],n[c]=l;for(let d=0;d<6;d++){let f=e[a*6+d];e[a*6+d]=e[c*6+d],e[c*6+d]=f}a++,c--}else return a}}function O(n,t){return t[n+15]===65535}function G(n,t){return t[n+6]}function Z(n,t){return t[n+14]}function Y(n){return n+8}function K(n,t){return t[n+6]}function ti(n,t){return t[n+7]}let ei,le,Fe,ni;const Qi=Math.pow(2,32);function Mn(n){return"count"in n?1:1+Mn(n.left)+Mn(n.right)}function tr(n,t,e){return ei=new Float32Array(e),le=new Uint32Array(e),Fe=new Uint16Array(e),ni=new Uint8Array(e),In(n,t)}function In(n,t){const e=n/4,s=n/2,i="count"in t,o=t.boundingData;for(let a=0;a<6;a++)ei[e+a]=o[a];if(i)if(t.buffer){const a=t.buffer;ni.set(new Uint8Array(a),n);for(let c=n,r=n+a.byteLength;c<r;c+=ue){const u=c/2;O(u,Fe)||(le[c/4+6]+=e)}return n+a.byteLength}else{const a=t.offset,c=t.count;return le[e+6]=a,Fe[s+14]=c,Fe[s+15]=je,n+ue}else{const a=t.left,c=t.right,r=t.splitAxis;let u;if(u=In(n+ue,a),u/4>Qi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return le[e+6]=u/4,u=In(u,c),le[e+7]=r,u}}function er(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),a=s?new Uint32Array(o):new Uint16Array(o);for(let c=0,r=a.length;c<r;c++)a[c]=c;return a}function nr(n,t,e,s,i){const{maxDepth:o,verbose:a,maxLeafTris:c,strategy:r,onProgress:u,indirect:l}=i,d=n._indirectBuffer,f=n.geometry,h=f.index?f.index.array:null,y=l?Ji:Ki,T=Kt(f),w=new Float32Array(6);let p=!1;const m=new on;return rn(t,e,s,m.boundingData,w),A(m,e,s,w),m;function g(x){u&&u(x/T)}function A(x,S,b,B=null,P=0){if(!p&&P>=o&&(p=!0,a&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),b<=c||P>=o)return g(S+b),x.offset=S,x.count=b,x;const M=Zi(x.boundingData,B,t,S,b,r);if(M.axis===-1)return g(S+b),x.offset=S,x.count=b,x;const E=y(d,h,t,S,b,M);if(E===S||E===S+b)g(S+b),x.offset=S,x.count=b;else{x.splitAxis=M.axis;const _=new on,I=S,z=E-S;x.left=_,rn(t,I,z,_.boundingData,w),A(_,I,z,w,P+1);const L=new on,R=E,k=b-z;x.right=L,rn(t,R,k,L.boundingData,w),A(L,R,k,w,P+1)}return x}}function sr(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=er(e,t.useSharedArrayBuffer),Xi(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Gi(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=qi(e),o=t.indirect?Js(e):Qs(e);n._roots=o.map(a=>{const c=nr(n,i,a.offset,a.count,t),r=Mn(c),u=new s(ue*r);return tr(0,c,u),u})}class gt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let o=0,a=t.length;o<a;o++){const r=t[o][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let o=0,a=e.length;o<a;o++){const c=e[o],r=t.dot(c);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}gt.prototype.setFromBox=function(){const n=new C;return function(e,s){const i=s.min,o=s.max;let a=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){n.x=i.x*r+o.x*(1-r),n.y=i.y*u+o.y*(1-u),n.z=i.z*l+o.z*(1-l);const d=e.dot(n);a=Math.min(d,a),c=Math.max(d,c)}this.min=a,this.max=c}}();const ir=function(){const n=new C,t=new C,e=new C;return function(i,o,a){const c=i.start,r=n,u=o.start,l=t;e.subVectors(c,u),n.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const d=e.dot(l),f=l.dot(r),h=l.dot(l),y=e.dot(r),w=r.dot(r)*h-f*f;let p,m;w!==0?p=(d*f-y*h)/w:p=0,m=(d+p*f)/h,a.x=p,a.y=m}}(),Dn=function(){const n=new vt,t=new C,e=new C;return function(i,o,a,c){ir(i,o,n);let r=n.x,u=n.y;if(r>=0&&r<=1&&u>=0&&u<=1){i.at(r,a),o.at(u,c);return}else if(r>=0&&r<=1){u<0?o.at(0,c):o.at(1,c),i.closestPointToPoint(c,!0,a);return}else if(u>=0&&u<=1){r<0?i.at(0,a):i.at(1,a),o.closestPointToPoint(a,!0,c);return}else{let l;r<0?l=i.start:l=i.end;let d;u<0?d=o.start:d=o.end;const f=t,h=e;if(i.closestPointToPoint(d,!0,t),o.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=h.distanceToSquared(l)){a.copy(f),c.copy(d);return}else{a.copy(l),c.copy(h);return}}}}(),rr=function(){const n=new C,t=new C,e=new Un,s=new Q;return function(o,a){const{radius:c,center:r}=o,{a:u,b:l,c:d}=a;if(s.start=u,s.end=l,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c||(s.start=u,s.end=d,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c)||(s.start=l,s.end=d,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c))return!0;const T=a.getPlane(e);if(Math.abs(T.distanceToPoint(r))<=c){const p=T.projectPoint(r,t);if(a.containsPoint(p))return!0}return!1}}(),or=1e-15;function cn(n){return Math.abs(n)<or}class tt extends W{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new C),this.satBounds=new Array(4).fill().map(()=>new gt),this.points=[this.a,this.b,this.c],this.sphere=new zi,this.plane=new Un,this.needsUpdate=!0}intersectsSphere(t){return rr(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,o=this.satAxes,a=this.satBounds,c=o[0],r=a[0];this.getNormal(c),r.setFromPoints(c,i);const u=o[1],l=a[1];u.subVectors(t,e),l.setFromPoints(u,i);const d=o[2],f=a[2];d.subVectors(e,s),f.setFromPoints(d,i);const h=o[3],y=a[3];h.subVectors(s,t),y.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}tt.prototype.closestPointToSegment=function(){const n=new C,t=new C,e=new Q;return function(i,o=null,a=null){const{start:c,end:r}=i,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),Dn(e,i,n,t),l=n.distanceToSquared(t),l<d&&(d=l,o&&o.copy(n),a&&a.copy(t))}return this.closestPointToPoint(c,n),l=c.distanceToSquared(n),l<d&&(d=l,o&&o.copy(n),a&&a.copy(c)),this.closestPointToPoint(r,n),l=r.distanceToSquared(n),l<d&&(d=l,o&&o.copy(n),a&&a.copy(r)),Math.sqrt(d)}}();tt.prototype.intersectsTriangle=function(){const n=new tt,t=new Array(3),e=new Array(3),s=new gt,i=new gt,o=new C,a=new C,c=new C,r=new C,u=new C,l=new Q,d=new Q,f=new Q,h=new C;function y(T,w,p){const m=T.points;let g=0,A=-1;for(let x=0;x<3;x++){const{start:S,end:b}=l;S.copy(m[x]),b.copy(m[(x+1)%3]),l.delta(a);const B=cn(w.distanceToPoint(S));if(cn(w.normal.dot(a))&&B){p.copy(l),g=2;break}const P=w.intersectLine(l,h);if(!P&&B&&h.copy(S),(P||B)&&!cn(h.distanceTo(b))){if(g<=1)(g===1?p.start:p.end).copy(h),B&&(A=g);else if(g>=2){(A===1?p.start:p.end).copy(h),g=2;break}if(g++,g===2&&A===-1)break}}return g}return function(w,p=null,m=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(n.copy(w),n.update(),w=n);const g=this.plane,A=w.plane;if(Math.abs(g.normal.dot(A.normal))>1-1e-10){const x=this.satBounds,S=this.satAxes;e[0]=w.a,e[1]=w.b,e[2]=w.c;for(let P=0;P<4;P++){const M=x[P],E=S[P];if(s.setFromPoints(E,e),M.isSeparated(s))return!1}const b=w.satBounds,B=w.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const M=b[P],E=B[P];if(s.setFromPoints(E,t),M.isSeparated(s))return!1}for(let P=0;P<4;P++){const M=S[P];for(let E=0;E<4;E++){const _=B[E];if(o.crossVectors(M,_),s.setFromPoints(o,t),i.setFromPoints(o,e),s.isSeparated(i))return!1}}return p&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const x=y(this,A,d);if(x===1&&w.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(x!==2)return!1;const S=y(w,g,f);if(S===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(S!==2)return!1;if(d.delta(c),f.delta(r),c.dot(r)<0){let I=f.start;f.start=f.end,f.end=I}const b=d.start.dot(c),B=d.end.dot(c),P=f.start.dot(c),M=f.end.dot(c),E=B<P,_=b<M;return b!==M&&P!==B&&E===_?!1:(p&&(u.subVectors(d.start,f.start),u.dot(c)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(c)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();tt.prototype.distanceToPoint=function(){const n=new C;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();tt.prototype.distanceToTriangle=function(){const n=new C,t=new C,e=["a","b","c"],s=new Q,i=new Q;return function(a,c=null,r=null){const u=c||r?s:null;if(this.intersectsTriangle(a,u))return(c||r)&&(c&&u.getCenter(c),r&&u.getCenter(r)),0;let l=1/0;for(let d=0;d<3;d++){let f;const h=e[d],y=a[h];this.closestPointToPoint(y,n),f=y.distanceToSquared(n),f<l&&(l=f,c&&c.copy(n),r&&r.copy(y));const T=this[h];a.closestPointToPoint(T,n),f=T.distanceToSquared(n),f<l&&(l=f,c&&c.copy(T),r&&r.copy(n))}for(let d=0;d<3;d++){const f=e[d],h=e[(d+1)%3];s.set(this[f],this[h]);for(let y=0;y<3;y++){const T=e[y],w=e[(y+1)%3];i.set(a[T],a[w]),Dn(s,i,n,t);const p=n.distanceToSquared(t);p<l&&(l=p,c&&c.copy(n),r&&r.copy(t))}}return Math.sqrt(l)}}();class ${constructor(t,e,s){this.isOrientedBox=!0,this.min=new C,this.max=new C,this.matrix=new at,this.invMatrix=new at,this.points=new Array(8).fill().map(()=>new C),this.satAxes=new Array(3).fill().map(()=>new C),this.satBounds=new Array(3).fill().map(()=>new gt),this.alignedSatBounds=new Array(3).fill().map(()=>new gt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}$.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,h=i[f];h.x=u?s.x:e.x,h.y=l?s.y:e.y,h.z=d?s.z:e.z,h.applyMatrix4(t)}const o=this.satBounds,a=this.satAxes,c=i[0];for(let u=0;u<3;u++){const l=a[u],d=o[u],f=1<<u,h=i[f];l.subVectors(c,h),d.setFromPoints(l,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();$.prototype.intersectsBox=function(){const n=new gt;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,o=this.satBounds,a=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const u=a[r],l=o[r];if(n.setFromBox(u,e),l.isSeparated(n))return!1}return!0}}();$.prototype.intersectsTriangle=function(){const n=new tt,t=new Array(3),e=new gt,s=new gt,i=new C;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(n.copy(a),n.update(),a=n);const c=this.satBounds,r=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let f=0;f<3;f++){const h=c[f],y=r[f];if(e.setFromPoints(y,t),h.isSeparated(e))return!1}const u=a.satBounds,l=a.satAxes,d=this.points;for(let f=0;f<3;f++){const h=u[f],y=l[f];if(e.setFromPoints(y,d),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=r[f];for(let y=0;y<4;y++){const T=l[y];if(i.crossVectors(h,T),e.setFromPoints(i,t),s.setFromPoints(i,d),e.isSeparated(s))return!1}}return!0}}();$.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();$.prototype.distanceToPoint=function(){const n=new C;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();$.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new Q),e=new Array(12).fill().map(()=>new Q),s=new C,i=new C;return function(a,c=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(r||u)&&(a.getCenter(i),this.closestPointToPoint(i,s),a.closestPointToPoint(s,i),r&&r.copy(s),u&&u.copy(i)),0;const l=c*c,d=a.min,f=a.max,h=this.points;let y=1/0;for(let w=0;w<8;w++){const p=h[w];i.copy(p).clamp(d,f);const m=p.distanceToSquared(i);if(m<y&&(y=m,r&&r.copy(p),u&&u.copy(i),m<l))return Math.sqrt(m)}let T=0;for(let w=0;w<3;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){const g=(w+1)%3,A=(w+2)%3,x=p<<g|m<<A,S=1<<w|p<<g|m<<A,b=h[x],B=h[S];t[T].set(b,B);const M=n[w],E=n[g],_=n[A],I=e[T],z=I.start,L=I.end;z[M]=d[M],z[E]=p?d[E]:f[E],z[_]=m?d[_]:f[E],L[M]=f[M],L[E]=p?d[E]:f[E],L[_]=m?d[_]:f[E],T++}for(let w=0;w<=1;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){i.x=w?f.x:d.x,i.y=p?f.y:d.y,i.z=m?f.z:d.z,this.closestPointToPoint(i,s);const g=i.distanceToSquared(s);if(g<y&&(y=g,r&&r.copy(s),u&&u.copy(i),g<l))return Math.sqrt(g)}for(let w=0;w<12;w++){const p=t[w];for(let m=0;m<12;m++){const g=e[m];Dn(p,g,s,i);const A=s.distanceToSquared(i);if(A<y&&(y=A,r&&r.copy(s),u&&u.copy(i),A<l))return Math.sqrt(A)}}return Math.sqrt(y)}}();class Hn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class cr extends Hn{constructor(){super(()=>new tt)}}const J=new cr;class ar{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const N=new ar;let Tt,jt;const Vt=[],xe=new Hn(()=>new rt);function lr(n,t,e,s,i,o){Tt=xe.getPrimitive(),jt=xe.getPrimitive(),Vt.push(Tt,jt),N.setBuffer(n._roots[t]);const a=En(0,n.geometry,e,s,i,o);N.clearBuffer(),xe.releasePrimitive(Tt),xe.releasePrimitive(jt),Vt.pop(),Vt.pop();const c=Vt.length;return c>0&&(jt=Vt[c-1],Tt=Vt[c-2]),a}function En(n,t,e,s,i=null,o=0,a=0){const{float32Array:c,uint16Array:r,uint32Array:u}=N;let l=n*2;if(O(l,r)){const f=G(n,u),h=Z(l,r);return U(n,c,Tt),s(f,h,!1,a,o+n,Tt)}else{let M=function(_){const{uint16Array:I,uint32Array:z}=N;let L=_*2;for(;!O(L,I);)_=Y(_),L=_*2;return G(_,z)},E=function(_){const{uint16Array:I,uint32Array:z}=N;let L=_*2;for(;!O(L,I);)_=K(_,z),L=_*2;return G(_,z)+Z(L,I)};const f=Y(n),h=K(n,u);let y=f,T=h,w,p,m,g;if(i&&(m=Tt,g=jt,U(y,c,m),U(T,c,g),w=i(m),p=i(g),p<w)){y=h,T=f;const _=w;w=p,p=_,m=g}m||(m=Tt,U(y,c,m));const A=O(y*2,r),x=e(m,A,w,a+1,o+y);let S;if(x===as){const _=M(y),z=E(y)-_;S=s(_,z,!0,a+1,o+y,m)}else S=x&&En(y,t,e,s,i,o,a+1);if(S)return!0;g=jt,U(T,c,g);const b=O(T*2,r),B=e(g,b,p,a+1,o+T);let P;if(B===as){const _=M(T),z=E(T)-_;P=s(_,z,!0,a+1,o+T,g)}else P=B&&En(T,t,e,s,i,o,a+1);return!!P}}const se=new C,an=new C;function ur(n,t,e={},s=0,i=1/0){const o=s*s,a=i*i;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(se.copy(t).clamp(l.min,l.max),se.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<c&&f<a,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,se);const f=t.distanceToSquared(se);return f<c&&(an.copy(se),c=f,r=d),f<o}}),c===1/0)return null;const u=Math.sqrt(c);return e.point?e.point.copy(an):e.point=an.clone(),e.distance=u,e.faceIndex=r,e}const kt=new C,Dt=new C,Ht=new C,Ae=new vt,be=new vt,Te=new vt,ps=new C,hs=new C,ys=new C,Se=new C;function fr(n,t,e,s,i,o){let a;return o===Li?a=n.intersectTriangle(s,e,t,!0,i):a=n.intersectTriangle(t,e,s,o!==Fn,i),a===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function dr(n,t,e,s,i,o,a,c,r){kt.fromBufferAttribute(t,o),Dt.fromBufferAttribute(t,a),Ht.fromBufferAttribute(t,c);const u=fr(n,kt,Dt,Ht,Se,r);if(u){s&&(Ae.fromBufferAttribute(s,o),be.fromBufferAttribute(s,a),Te.fromBufferAttribute(s,c),u.uv=W.getInterpolation(Se,kt,Dt,Ht,Ae,be,Te,new vt)),i&&(Ae.fromBufferAttribute(i,o),be.fromBufferAttribute(i,a),Te.fromBufferAttribute(i,c),u.uv1=W.getInterpolation(Se,kt,Dt,Ht,Ae,be,Te,new vt)),e&&(ps.fromBufferAttribute(e,o),hs.fromBufferAttribute(e,a),ys.fromBufferAttribute(e,c),u.normal=W.getInterpolation(Se,kt,Dt,Ht,ps,hs,ys,new C),u.normal.dot(n.direction)>0&&u.normal.multiplyScalar(-1));const l={a:o,b:a,c,normal:new C,materialIndex:0};W.getNormal(kt,Dt,Ht,l.normal),u.face=l,u.faceIndex=o}return u}function Ze(n,t,e,s,i){const o=s*3;let a=o+0,c=o+1,r=o+2;const u=n.index;n.index&&(a=u.getX(a),c=u.getX(c),r=u.getX(r));const{position:l,normal:d,uv:f,uv1:h}=n.attributes,y=dr(e,l,d,f,h,a,c,r,t);return y?(y.faceIndex=s,i&&i.push(y),y):null}function V(n,t,e,s){const i=n.a,o=n.b,a=n.c;let c=t,r=t+1,u=t+2;e&&(c=e.getX(c),r=e.getX(r),u=e.getX(u)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),o.x=s.getX(r),o.y=s.getY(r),o.z=s.getZ(r),a.x=s.getX(u),a.y=s.getY(u),a.z=s.getZ(u)}function pr(n,t,e,s,i,o){const{geometry:a,_indirectBuffer:c}=n;for(let r=s,u=s+i;r<u;r++)Ze(a,t,e,r,o)}function hr(n,t,e,s,i){const{geometry:o,_indirectBuffer:a}=n;let c=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let d;d=Ze(o,t,e,u),d&&d.distance<c&&(r=d,c=d.distance)}return r}function yr(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,u=c.attributes.position;for(let l=n,d=t+n;l<d;l++){let f;if(f=l,V(a,f*3,r,u),a.needsUpdate=!0,s(a,f,i,o))return!0}return!1}function gr(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,h,y=!1){const T=f*2;if(c[T+15]===je){const p=a[f+6],m=c[T+14];let g=1/0,A=1/0,x=1/0,S=-1/0,b=-1/0,B=-1/0;for(let P=3*p,M=3*(p+m);P<M;P++){let E=s[P];const _=i.getX(E),I=i.getY(E),z=i.getZ(E);_<g&&(g=_),_>S&&(S=_),I<A&&(A=I),I>b&&(b=I),z<x&&(x=z),z>B&&(B=z)}return r[f+0]!==g||r[f+1]!==A||r[f+2]!==x||r[f+3]!==S||r[f+4]!==b||r[f+5]!==B?(r[f+0]=g,r[f+1]=A,r[f+2]=x,r[f+3]=S,r[f+4]=b,r[f+5]=B,!0):!1}else{const p=f+8,m=a[f+6],g=p+h,A=m+h;let x=y,S=!1,b=!1;t?x||(S=t.has(g),b=t.has(A),x=!S&&!b):(S=!0,b=!0);const B=x||S,P=x||b;let M=!1;B&&(M=d(p,h,x));let E=!1;P&&(E=d(m,h,x));const _=M||E;if(_)for(let I=0;I<3;I++){const z=p+I,L=m+I,R=r[z],k=r[z+3],Ft=r[L],Mt=r[L+3];r[f+I]=R<Ft?R:Ft,r[f+I+3]=k>Mt?k:Mt}return _}}}const gs=new rt;function Bt(n,t,e,s){return U(n,t,gs),e.intersectBox(gs,s)}function mr(n,t,e,s,i,o){const{geometry:a,_indirectBuffer:c}=n;for(let r=s,u=s+i;r<u;r++){let l=c?c[r]:r;Ze(a,t,e,l,o)}}function wr(n,t,e,s,i){const{geometry:o,_indirectBuffer:a}=n;let c=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let d;d=Ze(o,t,e,a?a[u]:u),d&&d.distance<c&&(r=d,c=d.distance)}return r}function xr(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,u=c.attributes.position;for(let l=n,d=t+n;l<d;l++){let f;if(f=e.resolveTriangleIndex(l),V(a,f*3,r,u),a.needsUpdate=!0,s(a,f,i,o))return!0}return!1}const ms=new C;function Ar(n,t,e,s,i){N.setBuffer(n._roots[t]),Cn(0,n,e,s,i),N.clearBuffer()}function Cn(n,t,e,s,i){const{float32Array:o,uint16Array:a,uint32Array:c}=N,r=n*2;if(O(r,a)){const l=G(n,c),d=Z(r,a);pr(t,e,s,l,d,i)}else{const l=Y(n);Bt(l,o,s,ms)&&Cn(l,t,e,s,i);const d=K(n,c);Bt(d,o,s,ms)&&Cn(d,t,e,s,i)}}const ws=new C,br=["x","y","z"];function Tr(n,t,e,s){N.setBuffer(n._roots[t]);const i=zn(0,n,e,s);return N.clearBuffer(),i}function zn(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:a}=N;let c=n*2;if(O(c,o)){const u=G(n,a),l=Z(c,o);return hr(t,e,s,u,l)}else{const u=ti(n,a),l=br[u],f=s.direction[l]>=0;let h,y;f?(h=Y(n),y=K(n,a)):(h=K(n,a),y=Y(n));const w=Bt(h,i,s,ws)?zn(h,t,e,s):null;if(w){const g=w.point[l];if(f?g<=i[y+u]:g>=i[y+u+3])return w}const m=Bt(y,i,s,ws)?zn(y,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const Be=new rt,$t=new tt,Ot=new tt,ie=new at,xs=new $,Pe=new $;function Sr(n,t,e,s){N.setBuffer(n._roots[t]);const i=Ln(0,n,e,s);return N.clearBuffer(),i}function Ln(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=N;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),xs.set(e.boundingBox.min,e.boundingBox.max,s),i=xs),O(r,a)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,y=e.attributes.position,T=G(n,c),w=Z(r,a);if(ie.copy(s).invert(),e.boundsTree)return U(n,o,Pe),Pe.matrix.copy(ie),Pe.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Pe.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let g=T*3,A=(w+T)*3;g<A;g+=3)if(V(Ot,g,d,f),Ot.needsUpdate=!0,m.intersectsTriangle(Ot))return!0;return!1}});for(let p=T*3,m=(w+T)*3;p<m;p+=3){V($t,p,d,f),$t.a.applyMatrix4(ie),$t.b.applyMatrix4(ie),$t.c.applyMatrix4(ie),$t.needsUpdate=!0;for(let g=0,A=h.count;g<A;g+=3)if(V(Ot,g,h,y),Ot.needsUpdate=!0,$t.intersectsTriangle(Ot))return!0}}else{const l=n+8,d=c[n+6];return U(l,o,Be),!!(i.intersectsBox(Be)&&Ln(l,t,e,s,i)||(U(d,o,Be),i.intersectsBox(Be)&&Ln(d,t,e,s,i)))}}const _e=new at,ln=new $,re=new $,Br=new C,Pr=new C,_r=new C,Mr=new C;function Ir(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),ln.set(t.boundingBox.min,t.boundingBox.max,e),ln.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,u=c.index,l=t.attributes.position,d=t.index,f=J.getPrimitive(),h=J.getPrimitive();let y=Br,T=Pr,w=null,p=null;i&&(w=_r,p=Mr);let m=1/0,g=null,A=null;return _e.copy(e).invert(),re.matrix.copy(_e),n.shapecast({boundsTraverseOrder:x=>ln.distanceToBox(x),intersectsBounds:(x,S,b)=>b<m&&b<a?(S&&(re.min.copy(x.min),re.max.copy(x.max),re.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>re.distanceToBox(B),intersectsBounds:(B,P,M)=>M<m&&M<a,intersectsRange:(B,P)=>{for(let M=B,E=B+P;M<E;M++){V(h,3*M,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let _=x,I=x+S;_<I;_++){V(f,3*_,u,r),f.needsUpdate=!0;const z=f.distanceToTriangle(h,y,w);if(z<m&&(T.copy(y),p&&p.copy(w),m=z,g=_,A=M),z<o)return!0}}}});{const b=Kt(t);for(let B=0,P=b;B<P;B++){V(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=x,E=x+S;M<E;M++){V(f,3*M,u,r),f.needsUpdate=!0;const _=f.distanceToTriangle(h,y,w);if(_<m&&(T.copy(y),p&&p.copy(w),m=_,g=M,A=B),_<o)return!0}}}}}),J.releasePrimitive(f),J.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=m,s.faceIndex=g,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(_e),T.applyMatrix4(_e),i.distance=T.sub(i.point).length(),i.faceIndex=A),s)}function Er(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,h,y=!1){const T=f*2;if(c[T+15]===je){const p=a[f+6],m=c[T+14];let g=1/0,A=1/0,x=1/0,S=-1/0,b=-1/0,B=-1/0;for(let P=p,M=p+m;P<M;P++){const E=3*n.resolveTriangleIndex(P);for(let _=0;_<3;_++){let I=E+_;I=s?s[I]:I;const z=i.getX(I),L=i.getY(I),R=i.getZ(I);z<g&&(g=z),z>S&&(S=z),L<A&&(A=L),L>b&&(b=L),R<x&&(x=R),R>B&&(B=R)}}return r[f+0]!==g||r[f+1]!==A||r[f+2]!==x||r[f+3]!==S||r[f+4]!==b||r[f+5]!==B?(r[f+0]=g,r[f+1]=A,r[f+2]=x,r[f+3]=S,r[f+4]=b,r[f+5]=B,!0):!1}else{const p=f+8,m=a[f+6],g=p+h,A=m+h;let x=y,S=!1,b=!1;t?x||(S=t.has(g),b=t.has(A),x=!S&&!b):(S=!0,b=!0);const B=x||S,P=x||b;let M=!1;B&&(M=d(p,h,x));let E=!1;P&&(E=d(m,h,x));const _=M||E;if(_)for(let I=0;I<3;I++){const z=p+I,L=m+I,R=r[z],k=r[z+3],Ft=r[L],Mt=r[L+3];r[f+I]=R<Ft?R:Ft,r[f+I+3]=k>Mt?k:Mt}return _}}}const As=new C;function Cr(n,t,e,s,i){N.setBuffer(n._roots[t]),Rn(0,n,e,s,i),N.clearBuffer()}function Rn(n,t,e,s,i){const{float32Array:o,uint16Array:a,uint32Array:c}=N,r=n*2;if(O(r,a)){const l=G(n,c),d=Z(r,a);mr(t,e,s,l,d,i)}else{const l=Y(n);Bt(l,o,s,As)&&Rn(l,t,e,s,i);const d=K(n,c);Bt(d,o,s,As)&&Rn(d,t,e,s,i)}}const bs=new C,zr=["x","y","z"];function Lr(n,t,e,s){N.setBuffer(n._roots[t]);const i=vn(0,n,e,s);return N.clearBuffer(),i}function vn(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:a}=N;let c=n*2;if(O(c,o)){const u=G(n,a),l=Z(c,o);return wr(t,e,s,u,l)}else{const u=ti(n,a),l=zr[u],f=s.direction[l]>=0;let h,y;f?(h=Y(n),y=K(n,a)):(h=K(n,a),y=Y(n));const w=Bt(h,i,s,bs)?vn(h,t,e,s):null;if(w){const g=w.point[l];if(f?g<=i[y+u]:g>=i[y+u+3])return w}const m=Bt(y,i,s,bs)?vn(y,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const Me=new rt,Wt=new tt,Gt=new tt,oe=new at,Ts=new $,Ie=new $;function Rr(n,t,e,s){N.setBuffer(n._roots[t]);const i=Nn(0,n,e,s);return N.clearBuffer(),i}function Nn(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=N;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Ts.set(e.boundingBox.min,e.boundingBox.max,s),i=Ts),O(r,a)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,y=e.attributes.position,T=G(n,c),w=Z(r,a);if(oe.copy(s).invert(),e.boundsTree)return U(n,o,Ie),Ie.matrix.copy(oe),Ie.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Ie.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let g=T,A=w+T;g<A;g++)if(V(Gt,3*t.resolveTriangleIndex(g),d,f),Gt.needsUpdate=!0,m.intersectsTriangle(Gt))return!0;return!1}});for(let p=T,m=w+T;p<m;p++){const g=t.resolveTriangleIndex(p);V(Wt,3*g,d,f),Wt.a.applyMatrix4(oe),Wt.b.applyMatrix4(oe),Wt.c.applyMatrix4(oe),Wt.needsUpdate=!0;for(let A=0,x=h.count;A<x;A+=3)if(V(Gt,A,h,y),Gt.needsUpdate=!0,Wt.intersectsTriangle(Gt))return!0}}else{const l=n+8,d=c[n+6];return U(l,o,Me),!!(i.intersectsBox(Me)&&Nn(l,t,e,s,i)||(U(d,o,Me),i.intersectsBox(Me)&&Nn(d,t,e,s,i)))}}const Ee=new at,un=new $,ce=new $,vr=new C,Nr=new C,Ur=new C,Fr=new C;function Vr(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),un.set(t.boundingBox.min,t.boundingBox.max,e),un.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,u=c.index,l=t.attributes.position,d=t.index,f=J.getPrimitive(),h=J.getPrimitive();let y=vr,T=Nr,w=null,p=null;i&&(w=Ur,p=Fr);let m=1/0,g=null,A=null;return Ee.copy(e).invert(),ce.matrix.copy(Ee),n.shapecast({boundsTraverseOrder:x=>un.distanceToBox(x),intersectsBounds:(x,S,b)=>b<m&&b<a?(S&&(ce.min.copy(x.min),ce.max.copy(x.max),ce.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree){const b=t.boundsTree;return b.shapecast({boundsTraverseOrder:B=>ce.distanceToBox(B),intersectsBounds:(B,P,M)=>M<m&&M<a,intersectsRange:(B,P)=>{for(let M=B,E=B+P;M<E;M++){const _=b.resolveTriangleIndex(M);V(h,3*_,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let I=x,z=x+S;I<z;I++){const L=n.resolveTriangleIndex(I);V(f,3*L,u,r),f.needsUpdate=!0;const R=f.distanceToTriangle(h,y,w);if(R<m&&(T.copy(y),p&&p.copy(w),m=R,g=I,A=M),R<o)return!0}}}})}else{const b=Kt(t);for(let B=0,P=b;B<P;B++){V(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=x,E=x+S;M<E;M++){const _=n.resolveTriangleIndex(M);V(f,3*_,u,r),f.needsUpdate=!0;const I=f.distanceToTriangle(h,y,w);if(I<m&&(T.copy(y),p&&p.copy(w),m=I,g=M,A=B),I<o)return!0}}}}}),J.releasePrimitive(f),J.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=m,s.faceIndex=g,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Ee),T.applyMatrix4(Ee),i.distance=T.sub(i.point).length(),i.faceIndex=A),s)}function kr(){return typeof SharedArrayBuffer<"u"}const fe=new N.constructor,He=new N.constructor,At=new Hn(()=>new rt),Xt=new rt,qt=new rt,fn=new rt,dn=new rt;let pn=!1;function Dr(n,t,e,s){if(pn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");pn=!0;const i=n._roots,o=t._roots;let a,c=0,r=0;const u=new at().copy(e).invert();for(let l=0,d=i.length;l<d;l++){fe.setBuffer(i[l]),r=0;const f=At.getPrimitive();U(0,fe.float32Array,f),f.applyMatrix4(u);for(let h=0,y=o.length;h<y&&(He.setBuffer(o[l]),a=nt(0,0,e,u,s,c,r,0,0,f),He.clearBuffer(),r+=o[h].length,!a);h++);if(At.releasePrimitive(f),fe.clearBuffer(),c+=i[l].length,a)break}return pn=!1,a}function nt(n,t,e,s,i,o=0,a=0,c=0,r=0,u=null,l=!1){let d,f;l?(d=He,f=fe):(d=fe,f=He);const h=d.float32Array,y=d.uint32Array,T=d.uint16Array,w=f.float32Array,p=f.uint32Array,m=f.uint16Array,g=n*2,A=t*2,x=O(g,T),S=O(A,m);let b=!1;if(S&&x)l?b=i(G(t,p),Z(t*2,m),G(n,y),Z(n*2,T),r,a+t,c,o+n):b=i(G(n,y),Z(n*2,T),G(t,p),Z(t*2,m),c,o+n,r,a+t);else if(S){const B=At.getPrimitive();U(t,w,B),B.applyMatrix4(e);const P=Y(n),M=K(n,y);U(P,h,Xt),U(M,h,qt);const E=B.intersectsBox(Xt),_=B.intersectsBox(qt);b=E&&nt(t,P,s,e,i,a,o,r,c+1,B,!l)||_&&nt(t,M,s,e,i,a,o,r,c+1,B,!l),At.releasePrimitive(B)}else{const B=Y(t),P=K(t,p);U(B,w,fn),U(P,w,dn);const M=u.intersectsBox(fn),E=u.intersectsBox(dn);if(M&&E)b=nt(n,B,e,s,i,o,a,c,r+1,u,l)||nt(n,P,e,s,i,o,a,c,r+1,u,l);else if(M)if(x)b=nt(n,B,e,s,i,o,a,c,r+1,u,l);else{const _=At.getPrimitive();_.copy(fn).applyMatrix4(e);const I=Y(n),z=K(n,y);U(I,h,Xt),U(z,h,qt);const L=_.intersectsBox(Xt),R=_.intersectsBox(qt);b=L&&nt(B,I,s,e,i,a,o,r,c+1,_,!l)||R&&nt(B,z,s,e,i,a,o,r,c+1,_,!l),At.releasePrimitive(_)}else if(E)if(x)b=nt(n,P,e,s,i,o,a,c,r+1,u,l);else{const _=At.getPrimitive();_.copy(dn).applyMatrix4(e);const I=Y(n),z=K(n,y);U(I,h,Xt),U(z,h,qt);const L=_.intersectsBox(Xt),R=_.intersectsBox(qt);b=L&&nt(P,I,s,e,i,a,o,r,c+1,_,!l)||R&&nt(P,z,s,e,i,a,o,r,c+1,_,!l),At.releasePrimitive(_)}}return b}const Ce=new $,Ss=new rt,Hr={strategy:Ks,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class $n{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,o=t._indirectBuffer,a=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(r=>r.slice()),index:a.array.slice(),indirectBuffer:o?o.slice():null}:c={roots:i,index:a.array,indirectBuffer:o},c}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:o,indirectBuffer:a}=t,c=new $n(e,{...s,[sn]:!0});if(c._roots=o,c._indirectBuffer=a||null,s.setIndex){const r=e.getIndex();if(r===null){const u=new We(t.index,1,!1);e.setIndex(u)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...Hr,[sn]:!1},e),e.useSharedArrayBuffer&&!kr())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[sn]||(sr(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new rt)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?Er:gr)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),o=new Uint16Array(s);a(0);function a(c,r=0){const u=c*2,l=o[u+15]===je;if(l){const d=i[c+6],f=o[u+14];t(r,l,new Float32Array(s,c*4,6),d,f)}else{const d=c+ue/4,f=i[c+6],h=i[c+7];t(r,l,new Float32Array(s,c*4,6),h)||(a(d,r+1),a(f,r+1))}}}raycast(t,e=os){const s=this._roots,i=this.geometry,o=[],a=e.isMaterial,c=Array.isArray(e),r=i.groups,u=a?e.side:e,l=this.indirect?Cr:Ar;for(let d=0,f=s.length;d<f;d++){const h=c?e[r[d].materialIndex].side:u,y=o.length;if(l(this,d,h,t,o),c){const T=r[d].materialIndex;for(let w=y,p=o.length;w<p;w++)o[w].face.materialIndex=T}}return o}raycastFirst(t,e=os){const s=this._roots,i=this.geometry,o=e.isMaterial,a=Array.isArray(e);let c=null;const r=i.groups,u=o?e.side:e,l=this.indirect?Lr:Tr;for(let d=0,f=s.length;d<f;d++){const h=a?e[r[d].materialIndex].side:u,y=l(this,d,h,t);y!=null&&(c==null||y.distance<c.distance)&&(c=y,a&&(y.face.materialIndex=r[d].materialIndex))}return c}intersectsGeometry(t,e){let s=!1;const i=this._roots,o=this.indirect?Rr:Sr;for(let a=0,c=i.length;a<c&&(s=o(this,a,t,e),!s);a++);return s}shapecast(t){const e=J.getPrimitive(),s=this.indirect?xr:yr;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const d=a;a=(f,h,y,T,w)=>d(f,h,y,T,w)?!0:s(f,h,this,c,y,T,e)}else a||(c?a=(d,f,h,y)=>s(d,f,this,c,h,y,e):a=(d,f,h)=>h);let r=!1,u=0;const l=this._roots;for(let d=0,f=l.length;d<f;d++){const h=l[d];if(r=lr(this,d,o,a,i,u),r)break;u+=h.byteLength}return J.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const a=J.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,u=this.indirect?y=>{const T=this.resolveTriangleIndex(y);V(a,T*3,c,r)}:y=>{V(a,y*3,c,r)},l=J.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?y=>{const T=t.resolveTriangleIndex(y);V(l,T*3,d,f)}:y=>{V(l,y*3,d,f)};if(o){const y=(T,w,p,m,g,A,x,S)=>{for(let b=p,B=p+m;b<B;b++){h(b),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let P=T,M=T+w;P<M;P++)if(u(P),a.needsUpdate=!0,o(a,l,P,b,g,A,x,S))return!0}return!1};if(i){const T=i;i=function(w,p,m,g,A,x,S,b){return T(w,p,m,g,A,x,S,b)?!0:y(w,p,m,g,A,x,S,b)}}else i=y}return Dr(this,t,e,i)}intersectsBox(t,e){return Ce.set(t.min,t.max,e),Ce.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Ce.intersectsBox(s),intersectsTriangle:s=>Ce.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},o=0,a=1/0){return(this.indirect?Vr:Ir)(this,t,e,s,i,o,a)}closestPointToPoint(t,e={},s=0,i=1/0){return ur(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),Ss),t.union(Ss)}),t}}const si=1e-6,$r=si*.5,ii=Math.pow(10,-Math.log10(si)),Or=$r*ii;function ct(n){return~~(n*ii+Or)}function Wr(n){return`${ct(n.x)},${ct(n.y)}`}function Bs(n){return`${ct(n.x)},${ct(n.y)},${ct(n.z)}`}function Gr(n){return`${ct(n.x)},${ct(n.y)},${ct(n.z)},${ct(n.w)}`}function Xr(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}function ri(){return typeof SharedArrayBuffer<"u"}function qr(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,s=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(s).set(i,0),new t(s)}function jr(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Zr(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=jr(e,s);n.setIndex(new We(i,1));for(let o=0;o<e;o++)i[o]=o}}function Yr(n){return n.index?n.index.count:n.attributes.position.count}function On(n){return Yr(n)/3}const Kr=1e-8,Jr=new C;function Qr(n){return~~(n/3)}function to(n){return n%3}function Ps(n,t){return n.start-t.start}function _s(n,t){return Jr.subVectors(t,n.origin).dot(n.direction)}function eo(n,t,e,s=Kr){n.sort(Ps),t.sort(Ps);for(let c=0;c<n.length;c++){const r=n[c];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)o(l.end,r.end)||n.splice(c+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)o(r.end,l.end)||t.splice(u+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const d=r.end;r.end=l.start,l.start=d}else if(r.start>=l.start&&r.end>=l.end){const d=l.end;l.end=r.start,r.start=d}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),a(l)&&(t.splice(u,1),u--),a(r)){n.splice(c,1),c--;break}}}i(n),i(t);function i(c){for(let r=0;r<c.length;r++)a(c[r])&&(c.splice(r,1),r--)}function o(c,r){return Math.abs(r-c)<s}function a(c){return Math.abs(c.end-c.start)<s}}const Ms=1e-5,Is=1e-4;class no{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,o=null;for(let r=0,u=e.length;r<u;r++){const l=e[r];if(a(l,t)&&a(l,s))continue;const d=c(l,t),f=c(l,s),h=Math.min(d,f);h<i&&(i=h,o=l)}return o;function a(r,u){const l=r.origin.distanceTo(u.origin)>Ms;return r.direction.angleTo(u.direction)>Is||l}function c(r,u){const l=r.origin.distanceTo(u.origin),d=r.direction.angleTo(u.direction);return l/Ms+d/Is}}}const hn=new C,yn=new C,ze=new Gs;function so(n,t,e){const s=n.attributes,i=n.index,o=s.position,a=new Map,c=new Map,r=Array.from(t),u=new no;for(let l=0,d=r.length;l<d;l++){const f=r[l],h=Qr(f),y=to(f);let T=3*h+y,w=3*h+(y+1)%3;i&&(T=i.getX(T),w=i.getX(w)),hn.fromBufferAttribute(o,T),yn.fromBufferAttribute(o,w),Xr(hn,yn,ze);let p,m=u.findClosestRay(ze);m===null&&(m=ze.clone(),u.addRay(m)),c.has(m)||c.set(m,{forward:[],reverse:[],ray:m}),p=c.get(m);let g=_s(m,hn),A=_s(m,yn);g>A&&([g,A]=[A,g]),ze.direction.dot(m.direction)<0?p.reverse.push({start:g,end:A,index:f}):p.forward.push({start:g,end:A,index:f})}return c.forEach(({forward:l,reverse:d},f)=>{eo(l,d,a,e),l.length===0&&d.length===0&&c.delete(f)}),{disjointConnectivityMap:a,fragmentMap:c}}const io=new vt,gn=new C,ro=new Nt,mn=["","",""];class oo{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>~~(o/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>o%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:o}=this,a=e?g:m,c=new Map,{attributes:r}=t,u=e?Object.keys(r):null,l=t.index,d=r.position;let f=On(t);const h=f;let y=0;s&&(y=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let T=this.data;(!T||T.length<3*h)&&(T=new Int32Array(3*h)),T.fill(-1);let w=0,p=new Set;for(let A=y,x=f*3+y;A<x;A+=3){const S=A;for(let b=0;b<3;b++){let B=S+b;l&&(B=l.getX(B)),mn[b]=a(B)}for(let b=0;b<3;b++){const B=(b+1)%3,P=mn[b],M=mn[B],E=`${M}_${P}`;if(c.has(E)){const _=S+b,I=c.get(E);T[_]=I,T[I]=_,c.delete(E),w+=2,p.delete(I)}else{const _=`${P}_${M}`,I=S+b;c.set(_,I),p.add(I)}}}if(i){const{fragmentMap:A,disjointConnectivityMap:x}=so(t,p,o);p.clear(),A.forEach(({forward:S,reverse:b})=>{S.forEach(({index:B})=>p.add(B)),b.forEach(({index:B})=>p.add(B))}),this.unmatchedDisjointEdges=A,this.disjointConnections=x,w=f*3-p.size}this.matchedEdges=w,this.unmatchedEdges=p.size,this.data=T;function m(A){return gn.fromBufferAttribute(d,A),Bs(gn)}function g(A){let x="";for(let S=0,b=u.length;S<b;S++){const B=r[u[S]];let P;switch(B.itemSize){case 1:P=ct(B.getX(A));break;case 2:P=Wr(io.fromBufferAttribute(B,A));break;case 3:P=Bs(gn.fromBufferAttribute(B,A));break;case 4:P=Gr(ro.fromBufferAttribute(B,A));break}x!==""&&(x+="|"),x+=P}return x}}}class et extends Ge{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new at,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let o=0;o<16;o++)if(s[o]!==i[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=ri();if(s)for(const i in e){const o=e[i];if(o.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");o.array=qr(o.array)}if(t.boundsTree||(Zr(t,{useSharedArrayBuffer:s}),t.boundsTree=new $n(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new oo(t)),!t.groupIndices){const i=On(t),o=new Uint16Array(i),a=t.groups;for(let c=0,r=a.length;c<r;c++){const{start:u,count:l}=a[c];for(let d=u/3,f=(u+l)/3;d<f;d++)o[d]=c}t.groupIndices=o}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const co=1e-14,wn=new C,Es=new C,Cs=new C;function bt(n,t=co){wn.subVectors(n.b,n.a),Es.subVectors(n.c,n.a),Cs.subVectors(n.b,n.c);const e=wn.angleTo(Es),s=wn.angleTo(Cs),i=Math.PI-e-s;return Math.abs(e)<t||Math.abs(s)<t||Math.abs(i)<t||n.a.distanceToSquared(n.b)<t||n.a.distanceToSquared(n.c)<t||n.b.distanceToSquared(n.c)<t}const xn=1e-10,ae=1e-10,ao=1e-10,dt=new Q,F=new Q,pt=new C,An=new C,zs=new C,Le=new Un,bn=new tt;class lo{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new W),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class uo{constructor(){this.trianglePool=new lo,this.triangles=[],this.normal=new C,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:s,normal:i}=this;if(Array.isArray(t))for(let o=0,a=t.length;o<a;o++){const c=t[o];if(o===0)c.getNormal(i);else if(Math.abs(1-c.getNormal(pt).dot(i))>xn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const r=s.getTriangle();r.copy(c),e.push(r)}else{t.getNormal(i);const o=s.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:s}=this;if(t.getNormal(An).normalize(),Math.abs(1-Math.abs(An.dot(e)))<ao){this.coplanarTriangleUsed=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];c.coplanarCount=0}const i=[t.a,t.b,t.c];for(let o=0;o<3;o++){const a=(o+1)%3,c=i[o],r=i[a];pt.subVectors(r,c).normalize(),zs.crossVectors(An,pt),Le.setFromNormalAndCoplanarPoint(zs,c),this.splitByPlane(Le,t)}}else t.getPlane(Le),this.splitByPlane(Le,t)}splitByPlane(t,e){const{triangles:s,trianglePool:i}=this;bn.copy(e),bn.needsUpdate=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];if(!bn.intersectsTriangle(c,dt,!0))continue;const{a:r,b:u,c:l}=c;let d=0,f=-1,h=!1,y=[],T=[];const w=[r,u,l];for(let p=0;p<3;p++){const m=(p+1)%3;dt.start.copy(w[p]),dt.end.copy(w[m]);const g=t.distanceToPoint(dt.start),A=t.distanceToPoint(dt.end);if(Math.abs(g)<ae&&Math.abs(A)<ae){h=!0;break}if(g>0?y.push(p):T.push(p),Math.abs(g)<ae)continue;let x=!!t.intersectLine(dt,pt);!x&&Math.abs(A)<ae&&(pt.copy(dt.end),x=!0),x&&!(pt.distanceTo(dt.start)<xn)&&(pt.distanceTo(dt.end)<xn&&(f=p),d===0?F.start.copy(pt):F.end.copy(pt),d++)}if(!h&&d===2&&F.distance()>ae)if(f!==-1){f=(f+1)%3;let p=0;p===f&&(p=(p+1)%3);let m=p+1;m===f&&(m=(m+1)%3);const g=i.getTriangle();g.a.copy(w[m]),g.b.copy(F.end),g.c.copy(F.start),bt(g)||s.push(g),c.a.copy(w[p]),c.b.copy(F.start),c.c.copy(F.end),bt(c)&&(s.splice(o,1),o--,a--)}else{const p=y.length>=2?T[0]:y[0];if(p===0){let S=F.start;F.start=F.end,F.end=S}const m=(p+1)%3,g=(p+2)%3,A=i.getTriangle(),x=i.getTriangle();w[m].distanceToSquared(F.start)<w[g].distanceToSquared(F.end)?(A.a.copy(w[m]),A.b.copy(F.start),A.c.copy(F.end),x.a.copy(w[m]),x.b.copy(w[g]),x.c.copy(F.start)):(A.a.copy(w[g]),A.b.copy(F.start),A.c.copy(F.end),x.a.copy(w[m]),x.b.copy(w[g]),x.c.copy(F.end)),c.a.copy(w[p]),c.b.copy(F.end),c.c.copy(F.start),bt(A)||s.push(A),bt(x)||s.push(x),bt(c)&&(s.splice(o,1),o--,a--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function fo(n){return n=~~n,n+4-n%4}class Ls{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,s=ri()?SharedArrayBuffer:ArrayBuffer,i=new e(new s(fo(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:s}=this;s+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,o=t.length;i<o;i++)e[s+i]=t[i];this.length+=t.length}clear(){this.length=0}}class po{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:s}=this;let i=0;for(let o=0;o<e;o++){const a=s[o];i+=a[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const s=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const o in s){const a=s[o],c=new Ls(a.type);c.itemSize=a.itemSize,c.normalized=a.normalized,i[o]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:s}=this;if(!s[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,s,i){const{groupAttributes:o}=this,c=o[0][t];if(c){if(c.type!==e)for(let r=0,u=o.length;r<u;r++){const l=o[r][t];l.setType(e),l.itemSize=s,l.normalized=i}}else for(let r=0,u=o.length;r<u;r++){const l=new Ls(e);l.itemSize=s,l.normalized=i,o[r][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const s in e)e[s].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Rs{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:s,ids:i}=this;s[t]||(s[t]=[],i.push(t)),s[t].push(e)}}const _t=0,Wn=1,ho=2,yo=3,go=4,oi=5,ci=6,j=new Gs,vs=new at,D=new W,ht=new C,Ns=new Nt,Us=new Nt,Fs=new Nt,Tn=new Nt,Re=new Nt,ve=new Nt,Vs=new Q,Sn=new C,Bn=1e-8,mo=1e-15,Ct=-1,zt=1,Ve=-2,ke=2,de=0,It=1,Gn=2,wo=1e-14;let De=null;function ks(n){De=n}function ai(n,t){n.getMidpoint(j.origin),n.getNormal(j.direction);const e=t.raycastFirst(j,Fn);return!!(e&&j.direction.dot(e.face.normal)>0)?Ct:zt}function xo(n,t){function e(){return Math.random()-.5}n.getNormal(Sn),j.direction.copy(Sn),n.getMidpoint(j.origin);const s=3;let i=0,o=1/0;for(let a=0;a<s;a++){j.direction.x+=e()*Bn,j.direction.y+=e()*Bn,j.direction.z+=e()*Bn,j.direction.multiplyScalar(-1);const c=t.raycastFirst(j,Fn);if(!!(c&&j.direction.dot(c.face.normal)>0)&&i++,c!==null&&(o=Math.min(o,c.distance)),o<=mo)return c.face.normal.dot(Sn)>0?ke:Ve;if(i/s>.5||(a-i+1)/s>.5)break}return i/s>.5?Ct:zt}function Ao(n,t){const e=new Rs,s=new Rs;return vs.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,vs,{intersectsTriangles(i,o,a,c){if(!bt(i)&&!bt(o)){let r=i.intersectsTriangle(o,Vs,!0);if(!r){const u=i.plane,l=o.plane,d=u.normal,f=l.normal;d.dot(f)===1&&Math.abs(u.constant-l.constant)<wo&&(r=!0)}if(r){let u=n.geometry.boundsTree.resolveTriangleIndex(a),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(u,l),s.add(l,u),De&&(De.addEdge(Vs),De.addIntersectingTriangles(a,i,c,o))}}return!1}}),{aIntersections:e,bIntersections:s}}function bo(n,t,e,s,i,o,a=!1){const c=e.attributes,r=e.index,u=n*3,l=r.getX(u+0),d=r.getX(u+1),f=r.getX(u+2);for(const h in o){const y=c[h],T=o[h];if(!(h in c))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const w=y.itemSize;h==="position"?(D.a.fromBufferAttribute(y,l).applyMatrix4(s),D.b.fromBufferAttribute(y,d).applyMatrix4(s),D.c.fromBufferAttribute(y,f).applyMatrix4(s),Pn(D.a,D.b,D.c,t,3,T,a)):h==="normal"?(D.a.fromBufferAttribute(y,l).applyNormalMatrix(i),D.b.fromBufferAttribute(y,d).applyNormalMatrix(i),D.c.fromBufferAttribute(y,f).applyNormalMatrix(i),a&&(D.a.multiplyScalar(-1),D.b.multiplyScalar(-1),D.c.multiplyScalar(-1)),Pn(D.a,D.b,D.c,t,3,T,a,!0)):(Ns.fromBufferAttribute(y,l),Us.fromBufferAttribute(y,d),Fs.fromBufferAttribute(y,f),Pn(Ns,Us,Fs,t,w,T,a))}}function To(n,t,e,s,i,o,a,c=!1){_n(n,s,i,o,a,c),_n(c?e:t,s,i,o,a,c),_n(c?t:e,s,i,o,a,c)}function li(n,t,e=!1){switch(n){case _t:if(t===zt||t===ke&&!e)return It;break;case Wn:if(e){if(t===Ct)return de}else if(t===zt||t===Ve)return It;break;case ho:if(e){if(t===zt||t===Ve)return It}else if(t===Ct)return de;break;case go:if(t===Ct)return de;if(t===zt)return It;break;case yo:if(t===Ct||t===ke&&!e)return It;break;case oi:if(!e&&(t===zt||t===Ve))return It;break;case ci:if(!e&&(t===Ct||t===ke))return It;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return Gn}function Pn(n,t,e,s,i,o,a=!1,c=!1){const r=u=>{o.push(u.x),i>1&&o.push(u.y),i>2&&o.push(u.z),i>3&&o.push(u.w)};Tn.set(0,0,0,0).addScaledVector(n,s.a.x).addScaledVector(t,s.a.y).addScaledVector(e,s.a.z),Re.set(0,0,0,0).addScaledVector(n,s.b.x).addScaledVector(t,s.b.y).addScaledVector(e,s.b.z),ve.set(0,0,0,0).addScaledVector(n,s.c.x).addScaledVector(t,s.c.y).addScaledVector(e,s.c.z),c&&(Tn.normalize(),Re.normalize(),ve.normalize()),r(Tn),a?(r(ve),r(Re)):(r(Re),r(ve))}function _n(n,t,e,s,i,o=!1){for(const a in i){const c=t[a],r=i[a];if(!(a in t))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const u=c.itemSize;a==="position"?(ht.fromBufferAttribute(c,n).applyMatrix4(e),r.push(ht.x,ht.y,ht.z)):a==="normal"?(ht.fromBufferAttribute(c,n).applyNormalMatrix(s),o&&ht.multiplyScalar(-1),r.push(ht.x,ht.y,ht.z)):(r.push(c.getX(n)),u>1&&r.push(c.getY(n)),u>2&&r.push(c.getZ(n)),u>3&&r.push(c.getW(n)))}}class So{constructor(t){this.triangle=new W().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new W().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const s in e)t.push(e[s]);return t}}class Ds{constructor(){this.data={}}addTriangleIntersection(t,e,s,i){const{data:o}=this;o[t]||(o[t]=new So(e)),o[t].addTriangle(s,i)}getTrianglesAsArray(t=null){const{data:e}=this,s=[];if(t!==null)t in e&&s.push(e[t].triangle);else for(const i in e)s.push(e[i].triangle);return s}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(s=>parseInt(s)):[]}getIntersectionsAsArray(t=null,e=null){const{data:s}=this,i=new Set,o=[],a=c=>{if(s[c])if(e!==null)s[c].intersects[e]&&o.push(s[c].intersects[e]);else{const r=s[c].intersects;for(const u in r)i.has(u)||(i.add(u),o.push(r[u]))}};if(t!==null)a(t);else for(const c in s)a(c);return o}reset(){this.data={}}}class Bo{constructor(){this.enabled=!1,this.triangleIntersectsA=new Ds,this.triangleIntersectsB=new Ds,this.intersectionEdges=[]}addIntersectingTriangles(t,e,s,i){const{triangleIntersectsA:o,triangleIntersectsB:a}=this;o.addTriangleIntersection(t,e,s,i),a.addTriangleIntersection(s,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),ks(this))}complete(){this.enabled&&ks(null)}}const St=new at,$e=new Ri,Et=new W,Ne=new W,xt=new W,Ue=new W,st=[],Rt=[];function Po(n){for(const t of n)return t}function _o(n,t,e,s,i,o={}){const{useGroups:a=!0}=o,{aIntersections:c,bIntersections:r}=Ao(n,t),u=[];let l=null,d;return d=a?0:-1,Hs(n,t,c,e,!1,s,i,d),$s(n,t,c,e,!1,i,d),e.findIndex(h=>h!==ci&&h!==oi)!==-1&&(d=a?n.geometry.groups.length||1:-1,Hs(t,n,r,e,!0,s,i,d),$s(t,n,r,e,!0,i,d)),st.length=0,Rt.length=0,{groups:u,materials:l}}function Hs(n,t,e,s,i,o,a,c=0){const r=n.matrixWorld.determinant()<0;St.copy(t.matrixWorld).invert().multiply(n.matrixWorld),$e.getNormalMatrix(n.matrixWorld).multiplyScalar(r?-1:1);const u=n.geometry.groupIndices,l=n.geometry.index,d=n.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,y=t.geometry.attributes.position,T=e.ids,w=e.intersectionSet;for(let p=0,m=T.length;p<m;p++){const g=T[p],A=c===-1?0:u[g]+c,x=3*g,S=l.getX(x+0),b=l.getX(x+1),B=l.getX(x+2);Et.a.fromBufferAttribute(d,S).applyMatrix4(St),Et.b.fromBufferAttribute(d,b).applyMatrix4(St),Et.c.fromBufferAttribute(d,B).applyMatrix4(St),o.reset(),o.initialize(Et);const P=w[g];for(let E=0,_=P.length;E<_;E++){const I=3*P[E],z=h.getX(I+0),L=h.getX(I+1),R=h.getX(I+2);Ne.a.fromBufferAttribute(y,z),Ne.b.fromBufferAttribute(y,L),Ne.c.fromBufferAttribute(y,R),o.splitByTriangle(Ne)}const M=o.triangles;for(let E=0,_=M.length;E<_;E++){const I=M[E],z=o.coplanarTriangleUsed?xo(I,f):ai(I,f);st.length=0,Rt.length=0;for(let L=0,R=s.length;L<R;L++){const k=li(s[L],z,i);k!==Gn&&(Rt.push(k),st.push(a[L].getGroupAttrSet(A)))}if(st.length!==0){Et.getBarycoord(I.a,Ue.a),Et.getBarycoord(I.b,Ue.b),Et.getBarycoord(I.c,Ue.c);for(let L=0,R=st.length;L<R;L++){const k=st[L],Mt=Rt[L]===de;bo(g,Ue,n.geometry,n.matrixWorld,$e,k,r!==Mt)}}}}return T.length}function $s(n,t,e,s,i,o,a=0){const c=n.matrixWorld.determinant()<0;St.copy(t.matrixWorld).invert().multiply(n.matrixWorld),$e.getNormalMatrix(n.matrixWorld).multiplyScalar(c?-1:1);const r=t.geometry.boundsTree,u=n.geometry.groupIndices,l=n.geometry.index,d=n.geometry.attributes,f=d.position,h=[],y=n.geometry.halfEdges,T=new Set,w=On(n.geometry);for(let p=0,m=w;p<m;p++)p in e.intersectionSet||T.add(p);for(;T.size>0;){const p=Po(T);T.delete(p),h.push(p);const m=3*p,g=l.getX(m+0),A=l.getX(m+1),x=l.getX(m+2);xt.a.fromBufferAttribute(f,g).applyMatrix4(St),xt.b.fromBufferAttribute(f,A).applyMatrix4(St),xt.c.fromBufferAttribute(f,x).applyMatrix4(St);const S=ai(xt,r);Rt.length=0,st.length=0;for(let b=0,B=s.length;b<B;b++){const P=li(s[b],S,i);P!==Gn&&(Rt.push(P),st.push(o[b]))}for(;h.length>0;){const b=h.pop();for(let B=0;B<3;B++){const P=y.getSiblingTriangleIndex(b,B);P!==-1&&T.has(P)&&(h.push(P),T.delete(P))}if(st.length!==0){const B=3*b,P=l.getX(B+0),M=l.getX(B+1),E=l.getX(B+2),_=a===-1?0:u[b]+a;if(xt.a.fromBufferAttribute(f,P),xt.b.fromBufferAttribute(f,M),xt.c.fromBufferAttribute(f,E),!bt(xt))for(let I=0,z=st.length;I<z;I++){const L=Rt[I],R=st[I].getGroupAttrSet(_),k=L===de;To(P,M,E,d,n.matrixWorld,$e,R,k!==c)}}}}}function Mo(n){for(let t=0;t<n.length-1;t++){const e=n[t],s=n[t+1];if(e.materialIndex===s.materialIndex){const i=e.start,o=s.start+s.count;s.start=i,s.count=o-i,n.splice(t,1),t--}}}function Io(n,t,e,s){e.clear();const i=n.attributes;for(let o=0,a=s.length;o<a;o++){const c=s[o],r=i[c];e.initializeArray(c,r.array.constructor,r.itemSize,r.normalized)}for(const o in e.attributes)s.includes(o)||e.delete(o);for(const o in t.attributes)s.includes(o)||(t.deleteAttribute(o),t.dispose())}function Eo(n,t,e){let s=!1,i=-1;const o=n.attributes,a=t.groupAttributes[0];for(const r in a){const u=t.getTotalLength(r),l=t.getType(r),d=t.getItemSize(r),f=t.getNormalized(r);let h=o[r];(!h||h.array.length<u)&&(h=new We(new l(u),d,f),n.setAttribute(r,h),s=!0);let y=0;for(let T=0,w=Math.min(e.length,t.groupCount);T<w;T++){const p=e[T].index,{array:m,type:g,length:A}=t.groupAttributes[p][r],x=new g(m.buffer,0,A);h.array.set(x,y),y+=x.length}h.needsUpdate=!0,i=u/h.itemSize}if(n.index){const r=n.index.array;if(r.length<i)n.index=null,s=!0;else for(let u=0,l=r.length;u<l;u++)r[u]=u}let c=0;n.clearGroups();for(let r=0,u=Math.min(e.length,t.groupCount);r<u;r++){const{index:l,materialIndex:d}=e[r],f=t.getCount(l);f!==0&&(n.addGroup(c,f,d),c+=f)}n.setDrawRange(0,i),n.boundsTree=null,s&&n.dispose()}function Os(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(s=>{e[s.materialIndex]=t})),e}class ui{constructor(){this.triangleSplitter=new uo,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Bo}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,s,i=new et){let o=!0;if(Array.isArray(s)||(s=[s]),Array.isArray(i)||(i=[i],o=!1),i.length!==s.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:a,attributeData:c,attributes:r,useGroups:u,consolidateGroups:l,debug:d}=this;for(;c.length<i.length;)c.push(new po);i.forEach((p,m)=>{Io(t.geometry,p.geometry,c[m],r)}),d.init(),_o(t,e,s,a,c,{useGroups:u}),d.complete();const f=this.getGroupRanges(t.geometry),h=Os(f,t.material),y=this.getGroupRanges(e.geometry),T=Os(y,e.material);y.forEach(p=>p.materialIndex+=h.length);let w=[...f,...y].map((p,m)=>({...p,index:m}));if(u){const p=[...h,...T];l&&(w=w.map(g=>{const A=p[g.materialIndex];return g.materialIndex=p.indexOf(A),g}).sort((g,A)=>g.materialIndex-A.materialIndex));const m=[];for(let g=0,A=p.length;g<A;g++){let x=!1;for(let S=0,b=w.length;S<b;S++){const B=w[S];B.materialIndex===g&&(x=!0,B.materialIndex=m.length)}x&&m.push(p[g])}i.forEach(g=>{g.material=m})}else w=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(p=>{p.material=h[0]});return i.forEach((p,m)=>{const g=p.geometry;Eo(g,c[m],w),l&&Mo(g.groups)}),o?i:i[0]}evaluateHierarchy(t,e=new et){t.updateMatrixWorld(!0);const s=(o,a)=>{const c=o.children;for(let r=0,u=c.length;r<u;r++){const l=c[r];l.isOperationGroup?s(l,a):a(l)}},i=o=>{const a=o.children;let c=!1;for(let u=0,l=a.length;u<l;u++){const d=a[u];c=i(d)||c}const r=o.isDirty();if(r&&o.markUpdated(),c&&!o.isOperationGroup){let u;return s(o,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(o,l,l.operation)}),o._cachedGeometry=u.geometry,o._cachedMaterials=u.material,!0}else return c||r};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const{frameThickness:Xn,frameWidthOuter:fi,frameHeightOuter:di,slatWidth:Zt,x:Co,y:zo,frameWidthInner:pi,frameHeightInner:hi}=Lt,Jt=new Xe({roughness:.5,metalness:.7,wireframe:qe,color:34918}),yi=new et(new Oe(fi,di,Xn),Jt);yi.updateMatrixWorld();const gi=new et(new Oe(pi,hi,Xn),Jt);gi.updateMatrixWorld();const ge=new ui,Lo=ge.evaluate(yi,gi,Wn),qn=new et(new lt(pi+1,Zt*2,Zt*2,X.roundSegments,X.roundRadius),Jt);qn.position.set(0,-2.2,0);qn.updateMatrixWorld();const jn=new et(new lt(.6,hi+1,.6,X.roundSegments,X.roundRadius),Jt);jn.position.set(0,0,0);jn.updateMatrixWorld();let he=ge.evaluate(qn,jn,_t);const Zn=new et(new lt(Zt,13.4,Zt,X.roundSegments,X.roundRadius),Jt);Zn.position.set(-8.2,4.6,0);Zn.updateMatrixWorld();he=ge.evaluate(he,Zn,_t);const Yn=new et(new lt(Zt,13.4,Zt,X.roundSegments,X.roundRadius),Jt);Yn.position.set(8.2,4.6,0);Yn.updateMatrixWorld();he=ge.evaluate(he,Yn,_t);const Kn=ge.evaluate(Lo,he,_t);Kn.position.set(fi/2+Co,di/2+zo,-(X.wallThickness-Xn/2));Kn.updateMatrixWorld();const{floorXLength:ut,floorZLength:ft,wallHeight:mt,wallThickness:v,roundRadius:Qt,roundSegments:te,ny:Ro}=X,Ye=new ui,Jn=new Xe({roughness:1,metalness:0,wireframe:qe,transparent:!0,opacity:0}),vo=new lt(ut+1,v,ft+1,te,Qt),No=new Xe({roughness:1,metalness:0,wireframe:qe}),Qn=new et(vo,No);Qn.position.set(ut/2-1/2,-v/2,ft/2-1/2);Qn.updateMatrixWorld();const ts=new Xe({roughness:1,metalness:0,wireframe:qe}),Uo=new lt(v,mt,ft+1,te,Qt),es=new et(Uo,ts);es.position.set(-v/2,mt/2-v,ft/2-1/2);es.updateMatrixWorld();const Fo=new lt(ut+v,mt,v,te,Qt),ns=new et(Fo,ts);ns.position.set(ut/2-v/2,mt/2-v,-v/2);ns.updateMatrixWorld();const Vo=new Oe(Lt.frameWidthOuter,Lt.frameHeightOuter,v),ss=new et(Vo,ts);ss.position.set(Lt.frameWidthOuter/2+Lt.x,Lt.frameHeightOuter/2+Lt.y,-v/2);ss.updateMatrixWorld();const mi=Ye.evaluate(ns,ss,Wn);mi.updateMatrixWorld();const Ke=Ye.evaluate(mi,Kn,_t);Ke.receiveShadow=!0;Ke.castShadow=!0;Ke.updateMatrixWorld();const ko=new lt(ut+v+v,mt,v,te,Qt),Je=new Ge(ko,Jn);Je.position.set(ut/2,mt/2-v,ft+v/2);Je.receiveShadow=!0;Je.castShadow=!0;const Do=new lt(v,mt,ft+v,te,Qt),Qe=new Ge(Do,Jn);Qe.position.set(ut+v/2,mt/2-v,ft/2-v/2);Qe.receiveShadow=!0;Qe.castShadow=!0;const Ho=new lt(ut+v+v,v,ft+v+v,te,Qt),tn=new Ge(Ho,Jn);tn.position.set(ut/2,mt-v/2,ft/2);tn.receiveShadow=!0;tn.castShadow=!0;const Ut=new vi;Ut.position.set(-ut/2,-Ro,-ft/2);let Yt=Ye.evaluate(es,Ke,_t);Yt.updateMatrixWorld();Yt=Ye.evaluate(Yt,Qn,_t);Yt.castShadow=!0;Yt.receiveShadow=!0;Ut.add(Yt);Ut.add(Je);Ut.add(Qe);Ut.add(tn);ot.add(Ut);const is=new Ni(Ut);is.visible=!1;ot.add(is);const $o=new Ui,wi=()=>{cs.begin(),it.clear(),is.update(),kn.update();const n=$o.getDelta();en.animating&&en.update(n),it.render(ot,ye),en.render(it),cs.end(),requestAnimationFrame(wi)},{floorXLength:Oo,floorZLength:Wo,ny:Go}=X,rs=new Fi(42);rs.position.set(-Oo/2,-Go,-Wo/2);rs.visible=!1;ot.add(rs);wi();Vi(pe,ye,it);Vn.add(kn,"autoRotate");

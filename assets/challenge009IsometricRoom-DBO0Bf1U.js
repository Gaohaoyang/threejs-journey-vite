import"./modulepreload-polyfill-B5Qt9EMX.js";import{v as C,aP as He,G as pi,P as hi,W as yi,aQ as gi,O as mi,S as wi,c as xi,B as Oe,V as Rt,aR as vn,aS as J,aT as G,aq as Ai,u as ot,ap as it,aU as bi,X as Un,aj as ns,aV as ks,aW as Nt,M as jt,aX as Ti,a as Ge,a3 as Si,aY as Bi,s as ss,b as Pi,aZ as _i,p as Mi,a_ as Ii,a$ as Ei,A as Ci,l as zi}from"./OrbitControls-DZXoXUOl.js";const te=new C;function X(n,t,e,s,i,o){const a=2*Math.PI*i/4,c=Math.max(o-2*i,0),r=Math.PI/4;te.copy(t),te[s]=0,te.normalize();const u=.5*a/(a+c),l=1-te.angleTo(n)/r;return Math.sign(te[e])===1?l*u:c/(a+c)+u+u*(1-l)}class at extends He{constructor(t=1,e=1,s=1,i=2,o=.1){if(i=i*2+1,o=Math.min(t/2,e/2,s/2,o),super(1,1,1,i,i,i),i===1)return;const a=this.toNonIndexed();this.index=null,this.attributes.position=a.attributes.position,this.attributes.normal=a.attributes.normal,this.attributes.uv=a.attributes.uv;const c=new C,r=new C,u=new C(t,e,s).divideScalar(2).subScalar(o),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,y=new C,T=.5/i;for(let w=0,p=0;w<l.length;w+=3,p+=2)switch(c.fromArray(l,w),r.copy(c),r.x-=Math.sign(r.x)*T,r.y-=Math.sign(r.y)*T,r.z-=Math.sign(r.z)*T,r.normalize(),l[w+0]=u.x*Math.sign(c.x)+r.x*o,l[w+1]=u.y*Math.sign(c.y)+r.y*o,l[w+2]=u.z*Math.sign(c.z)+r.z*o,d[w+0]=r.x,d[w+1]=r.y,d[w+2]=r.z,Math.floor(w/h)){case 0:y.set(1,0,0),f[p+0]=X(y,r,"z","y",o,s),f[p+1]=1-X(y,r,"y","z",o,e);break;case 1:y.set(-1,0,0),f[p+0]=1-X(y,r,"z","y",o,s),f[p+1]=1-X(y,r,"y","z",o,e);break;case 2:y.set(0,1,0),f[p+0]=1-X(y,r,"x","z",o,t),f[p+1]=X(y,r,"z","x",o,s);break;case 3:y.set(0,-1,0),f[p+0]=1-X(y,r,"x","z",o,t),f[p+1]=1-X(y,r,"z","x",o,s);break;case 4:y.set(0,0,1),f[p+0]=1-X(y,r,"x","y",o,t),f[p+1]=1-X(y,r,"y","x",o,e);break;case 5:y.set(0,0,-1),f[p+0]=X(y,r,"x","y",o,t),f[p+1]=1-X(y,r,"y","x",o,e);break}}}const Li=new pi,de={width:window.innerWidth,height:window.innerHeight},he=new hi(20,de.width/de.height,.1,1e5);he.position.set(120,60,120);const $s=document.querySelector("canvas.webgl");if($s===null)throw new Error("Cannot find the canvas element");const nt=new yi({canvas:$s,antialias:!0});nt.setSize(de.width,de.height);nt.setPixelRatio(Math.min(window.devicePixelRatio,2));nt.autoClear=!1;nt.shadowMap.enabled=!0;nt.shadowMap.type=gi;const Fn=new mi(he,nt.domElement);Fn.enableDamping=!0;const Pt=new wi,tn=xi(he,nt.domElement),Hs=0,Ri=1,Ni=2,is=2,en=1.25,rs=1,le=6*4+4+4,We=65535,vi=Math.pow(2,-24),nn=Symbol("SKIP_GENERATION");function Ui(n){return n.index?n.index.count:n.attributes.position.count}function Zt(n){return Ui(n)/3}function Fi(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Vi(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Fi(e,s);n.setIndex(new Oe(i,1));for(let o=0;o<e;o++)i[o]=o}}function Os(n){const t=Zt(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,o=Math.max(0,s),a=Math.min(t,i)-o;return[{offset:Math.floor(o),count:Math.floor(a)}]}function Gs(n){if(!n.groups||!n.groups.length)return Os(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,o=(s.start+s.count)/3;for(const c of n.groups){const r=c.start/3,u=(c.start+c.count)/3;e.add(Math.max(i,r)),e.add(Math.min(o,u))}const a=Array.from(e.values()).sort((c,r)=>c-r);for(let c=0;c<a.length-1;c++){const r=a[c],u=a[c+1];t.push({offset:Math.floor(r),count:Math.floor(u-r)})}return t}function Di(n){if(n.groups.length===0)return!1;const t=Zt(n),e=Gs(n).sort((o,a)=>o.offset-a.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:o})=>i+=o),t!==i}function sn(n,t,e,s,i){let o=1/0,a=1/0,c=1/0,r=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,y=-1/0,T=-1/0,w=-1/0;for(let p=t*6,m=(t+e)*6;p<m;p+=6){const g=n[p+0],A=n[p+1],x=g-A,S=g+A;x<o&&(o=x),S>r&&(r=S),g<d&&(d=g),g>y&&(y=g);const b=n[p+2],B=n[p+3],P=b-B,M=b+B;P<a&&(a=P),M>u&&(u=M),b<f&&(f=b),b>T&&(T=b);const E=n[p+4],_=n[p+5],I=E-_,z=E+_;I<c&&(c=I),z>l&&(l=z),E<h&&(h=E),E>w&&(w=E)}s[0]=o,s[1]=a,s[2]=c,s[3]=r,s[4]=u,s[5]=l,i[0]=d,i[1]=f,i[2]=h,i[3]=y,i[4]=T,i[5]=w}function ki(n,t=null,e=null,s=null){const i=n.attributes.position,o=n.index?n.index.array:null,a=Zt(n),c=i.normalized;let r;t===null?(r=new Float32Array(a*6*4),e=0,s=a):(r=t,e=e||0,s=s||a);const u=i.array,l=i.offset||0;let d=3;i.isInterleavedBufferAttribute&&(d=i.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+s;h++){const y=h*3,T=h*6;let w=y+0,p=y+1,m=y+2;o&&(w=o[w],p=o[p],m=o[m]),c||(w=w*d+l,p=p*d+l,m=m*d+l);for(let g=0;g<3;g++){let A,x,S;c?(A=i[f[g]](w),x=i[f[g]](p),S=i[f[g]](m)):(A=u[w+g],x=u[p+g],S=u[m+g]);let b=A;x<b&&(b=x),S<b&&(b=S);let B=A;x>B&&(B=x),S>B&&(B=S);const P=(B-b)/2,M=g*2;r[T+M+0]=b+P,r[T+M+1]=P+(Math.abs(b)+P)*vi}}return r}function U(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function os(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function cs(n,t){t.set(n)}function as(n,t,e){let s,i;for(let o=0;o<3;o++){const a=o+3;s=n[o],i=t[o],e[o]=s<i?s:i,s=n[a],i=t[a],e[a]=s>i?s:i}}function ge(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],o=t[n+2*s+1],a=i-o,c=i+o;a<e[s]&&(e[s]=a),c>e[s+3]&&(e[s+3]=c)}}function ee(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const ht=32,$i=(n,t)=>n.candidate-t.candidate,wt=new Array(ht).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),me=new Float32Array(6);function Hi(n,t,e,s,i,o){let a=-1,c=0;if(o===Hs)a=os(t),a!==-1&&(c=(t[a]+t[a+3])/2);else if(o===Ri)a=os(n),a!==-1&&(c=Oi(e,s,i,a));else if(o===Ni){const r=ee(n);let u=en*i;const l=s*6,d=(s+i)*6;for(let f=0;f<3;f++){const h=t[f],w=(t[f+3]-h)/ht;if(i<ht/4){const p=[...wt];p.length=i;let m=0;for(let A=l;A<d;A+=6,m++){const x=p[m];x.candidate=e[A+2*f],x.count=0;const{bounds:S,leftCacheBounds:b,rightCacheBounds:B}=x;for(let P=0;P<3;P++)B[P]=1/0,B[P+3]=-1/0,b[P]=1/0,b[P+3]=-1/0,S[P]=1/0,S[P+3]=-1/0;ge(A,e,S)}p.sort($i);let g=i;for(let A=0;A<g;A++){const x=p[A];for(;A+1<g&&p[A+1].candidate===x.candidate;)p.splice(A+1,1),g--}for(let A=l;A<d;A+=6){const x=e[A+2*f];for(let S=0;S<g;S++){const b=p[S];x>=b.candidate?ge(A,e,b.rightCacheBounds):(ge(A,e,b.leftCacheBounds),b.count++)}}for(let A=0;A<g;A++){const x=p[A],S=x.count,b=i-x.count,B=x.leftCacheBounds,P=x.rightCacheBounds;let M=0;S!==0&&(M=ee(B)/r);let E=0;b!==0&&(E=ee(P)/r);const _=rs+en*(M*S+E*b);_<u&&(a=f,u=_,c=x.candidate)}}else{for(let g=0;g<ht;g++){const A=wt[g];A.count=0,A.candidate=h+w+g*w;const x=A.bounds;for(let S=0;S<3;S++)x[S]=1/0,x[S+3]=-1/0}for(let g=l;g<d;g+=6){let S=~~((e[g+2*f]-h)/w);S>=ht&&(S=ht-1);const b=wt[S];b.count++,ge(g,e,b.bounds)}const p=wt[ht-1];cs(p.bounds,p.rightCacheBounds);for(let g=ht-2;g>=0;g--){const A=wt[g],x=wt[g+1];as(A.bounds,x.rightCacheBounds,A.rightCacheBounds)}let m=0;for(let g=0;g<ht-1;g++){const A=wt[g],x=A.count,S=A.bounds,B=wt[g+1].rightCacheBounds;x!==0&&(m===0?cs(S,me):as(S,me,me)),m+=x;let P=0,M=0;m!==0&&(P=ee(me)/r);const E=i-m;E!==0&&(M=ee(B)/r);const _=rs+en*(P*m+M*E);_<u&&(a=f,u=_,c=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:a,pos:c}}function Oi(n,t,e,s){let i=0;for(let o=t,a=t+e;o<a;o++)i+=n[o*6+s*2];return i/e}class rn{constructor(){this.boundingData=new Float32Array(6)}}function Gi(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;a<=c&&e[a*6+u]<r;)a++;for(;a<=c&&e[c*6+u]>=r;)c--;if(a<c){for(let l=0;l<3;l++){let d=t[a*3+l];t[a*3+l]=t[c*3+l],t[c*3+l]=d}for(let l=0;l<6;l++){let d=e[a*6+l];e[a*6+l]=e[c*6+l],e[c*6+l]=d}a++,c--}else return a}}function Wi(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;a<=c&&e[a*6+u]<r;)a++;for(;a<=c&&e[c*6+u]>=r;)c--;if(a<c){let l=n[a];n[a]=n[c],n[c]=l;for(let d=0;d<6;d++){let f=e[a*6+d];e[a*6+d]=e[c*6+d],e[c*6+d]=f}a++,c--}else return a}}function H(n,t){return t[n+15]===65535}function W(n,t){return t[n+6]}function j(n,t){return t[n+14]}function Z(n){return n+8}function Y(n,t){return t[n+6]}function Ws(n,t){return t[n+7]}let Xs,ae,Ue,qs;const Xi=Math.pow(2,32);function _n(n){return"count"in n?1:1+_n(n.left)+_n(n.right)}function qi(n,t,e){return Xs=new Float32Array(e),ae=new Uint32Array(e),Ue=new Uint16Array(e),qs=new Uint8Array(e),Mn(n,t)}function Mn(n,t){const e=n/4,s=n/2,i="count"in t,o=t.boundingData;for(let a=0;a<6;a++)Xs[e+a]=o[a];if(i)if(t.buffer){const a=t.buffer;qs.set(new Uint8Array(a),n);for(let c=n,r=n+a.byteLength;c<r;c+=le){const u=c/2;H(u,Ue)||(ae[c/4+6]+=e)}return n+a.byteLength}else{const a=t.offset,c=t.count;return ae[e+6]=a,Ue[s+14]=c,Ue[s+15]=We,n+le}else{const a=t.left,c=t.right,r=t.splitAxis;let u;if(u=Mn(n+le,a),u/4>Xi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return ae[e+6]=u/4,u=Mn(u,c),ae[e+7]=r,u}}function ji(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),a=s?new Uint32Array(o):new Uint16Array(o);for(let c=0,r=a.length;c<r;c++)a[c]=c;return a}function Zi(n,t,e,s,i){const{maxDepth:o,verbose:a,maxLeafTris:c,strategy:r,onProgress:u,indirect:l}=i,d=n._indirectBuffer,f=n.geometry,h=f.index?f.index.array:null,y=l?Wi:Gi,T=Zt(f),w=new Float32Array(6);let p=!1;const m=new rn;return sn(t,e,s,m.boundingData,w),A(m,e,s,w),m;function g(x){u&&u(x/T)}function A(x,S,b,B=null,P=0){if(!p&&P>=o&&(p=!0,a&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),b<=c||P>=o)return g(S+b),x.offset=S,x.count=b,x;const M=Hi(x.boundingData,B,t,S,b,r);if(M.axis===-1)return g(S+b),x.offset=S,x.count=b,x;const E=y(d,h,t,S,b,M);if(E===S||E===S+b)g(S+b),x.offset=S,x.count=b;else{x.splitAxis=M.axis;const _=new rn,I=S,z=E-S;x.left=_,sn(t,I,z,_.boundingData,w),A(_,I,z,w,P+1);const L=new rn,R=E,D=b-z;x.right=L,sn(t,R,D,L.boundingData,w),A(L,R,D,w,P+1)}return x}}function Yi(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=ji(e,t.useSharedArrayBuffer),Di(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Vi(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=ki(e),o=t.indirect?Os(e):Gs(e);n._roots=o.map(a=>{const c=Zi(n,i,a.offset,a.count,t),r=_n(c),u=new s(le*r);return qi(0,c,u),u})}class yt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let o=0,a=t.length;o<a;o++){const r=t[o][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let o=0,a=e.length;o<a;o++){const c=e[o],r=t.dot(c);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}yt.prototype.setFromBox=function(){const n=new C;return function(e,s){const i=s.min,o=s.max;let a=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){n.x=i.x*r+o.x*(1-r),n.y=i.y*u+o.y*(1-u),n.z=i.z*l+o.z*(1-l);const d=e.dot(n);a=Math.min(d,a),c=Math.max(d,c)}this.min=a,this.max=c}}();const Ki=function(){const n=new C,t=new C,e=new C;return function(i,o,a){const c=i.start,r=n,u=o.start,l=t;e.subVectors(c,u),n.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const d=e.dot(l),f=l.dot(r),h=l.dot(l),y=e.dot(r),w=r.dot(r)*h-f*f;let p,m;w!==0?p=(d*f-y*h)/w:p=0,m=(d+p*f)/h,a.x=p,a.y=m}}(),Vn=function(){const n=new Rt,t=new C,e=new C;return function(i,o,a,c){Ki(i,o,n);let r=n.x,u=n.y;if(r>=0&&r<=1&&u>=0&&u<=1){i.at(r,a),o.at(u,c);return}else if(r>=0&&r<=1){u<0?o.at(0,c):o.at(1,c),i.closestPointToPoint(c,!0,a);return}else if(u>=0&&u<=1){r<0?i.at(0,a):i.at(1,a),o.closestPointToPoint(a,!0,c);return}else{let l;r<0?l=i.start:l=i.end;let d;u<0?d=o.start:d=o.end;const f=t,h=e;if(i.closestPointToPoint(d,!0,t),o.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=h.distanceToSquared(l)){a.copy(f),c.copy(d);return}else{a.copy(l),c.copy(h);return}}}}(),Ji=function(){const n=new C,t=new C,e=new vn,s=new J;return function(o,a){const{radius:c,center:r}=o,{a:u,b:l,c:d}=a;if(s.start=u,s.end=l,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c||(s.start=u,s.end=d,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c)||(s.start=l,s.end=d,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c))return!0;const T=a.getPlane(e);if(Math.abs(T.distanceToPoint(r))<=c){const p=T.projectPoint(r,t);if(a.containsPoint(p))return!0}return!1}}(),Qi=1e-15;function on(n){return Math.abs(n)<Qi}class Q extends G{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new C),this.satBounds=new Array(4).fill().map(()=>new yt),this.points=[this.a,this.b,this.c],this.sphere=new Ai,this.plane=new vn,this.needsUpdate=!0}intersectsSphere(t){return Ji(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,o=this.satAxes,a=this.satBounds,c=o[0],r=a[0];this.getNormal(c),r.setFromPoints(c,i);const u=o[1],l=a[1];u.subVectors(t,e),l.setFromPoints(u,i);const d=o[2],f=a[2];d.subVectors(e,s),f.setFromPoints(d,i);const h=o[3],y=a[3];h.subVectors(s,t),y.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}Q.prototype.closestPointToSegment=function(){const n=new C,t=new C,e=new J;return function(i,o=null,a=null){const{start:c,end:r}=i,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),Vn(e,i,n,t),l=n.distanceToSquared(t),l<d&&(d=l,o&&o.copy(n),a&&a.copy(t))}return this.closestPointToPoint(c,n),l=c.distanceToSquared(n),l<d&&(d=l,o&&o.copy(n),a&&a.copy(c)),this.closestPointToPoint(r,n),l=r.distanceToSquared(n),l<d&&(d=l,o&&o.copy(n),a&&a.copy(r)),Math.sqrt(d)}}();Q.prototype.intersectsTriangle=function(){const n=new Q,t=new Array(3),e=new Array(3),s=new yt,i=new yt,o=new C,a=new C,c=new C,r=new C,u=new C,l=new J,d=new J,f=new J,h=new C;function y(T,w,p){const m=T.points;let g=0,A=-1;for(let x=0;x<3;x++){const{start:S,end:b}=l;S.copy(m[x]),b.copy(m[(x+1)%3]),l.delta(a);const B=on(w.distanceToPoint(S));if(on(w.normal.dot(a))&&B){p.copy(l),g=2;break}const P=w.intersectLine(l,h);if(!P&&B&&h.copy(S),(P||B)&&!on(h.distanceTo(b))){if(g<=1)(g===1?p.start:p.end).copy(h),B&&(A=g);else if(g>=2){(A===1?p.start:p.end).copy(h),g=2;break}if(g++,g===2&&A===-1)break}}return g}return function(w,p=null,m=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(n.copy(w),n.update(),w=n);const g=this.plane,A=w.plane;if(Math.abs(g.normal.dot(A.normal))>1-1e-10){const x=this.satBounds,S=this.satAxes;e[0]=w.a,e[1]=w.b,e[2]=w.c;for(let P=0;P<4;P++){const M=x[P],E=S[P];if(s.setFromPoints(E,e),M.isSeparated(s))return!1}const b=w.satBounds,B=w.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const M=b[P],E=B[P];if(s.setFromPoints(E,t),M.isSeparated(s))return!1}for(let P=0;P<4;P++){const M=S[P];for(let E=0;E<4;E++){const _=B[E];if(o.crossVectors(M,_),s.setFromPoints(o,t),i.setFromPoints(o,e),s.isSeparated(i))return!1}}return p&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const x=y(this,A,d);if(x===1&&w.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(x!==2)return!1;const S=y(w,g,f);if(S===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(S!==2)return!1;if(d.delta(c),f.delta(r),c.dot(r)<0){let I=f.start;f.start=f.end,f.end=I}const b=d.start.dot(c),B=d.end.dot(c),P=f.start.dot(c),M=f.end.dot(c),E=B<P,_=b<M;return b!==M&&P!==B&&E===_?!1:(p&&(u.subVectors(d.start,f.start),u.dot(c)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(c)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();Q.prototype.distanceToPoint=function(){const n=new C;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();Q.prototype.distanceToTriangle=function(){const n=new C,t=new C,e=["a","b","c"],s=new J,i=new J;return function(a,c=null,r=null){const u=c||r?s:null;if(this.intersectsTriangle(a,u))return(c||r)&&(c&&u.getCenter(c),r&&u.getCenter(r)),0;let l=1/0;for(let d=0;d<3;d++){let f;const h=e[d],y=a[h];this.closestPointToPoint(y,n),f=y.distanceToSquared(n),f<l&&(l=f,c&&c.copy(n),r&&r.copy(y));const T=this[h];a.closestPointToPoint(T,n),f=T.distanceToSquared(n),f<l&&(l=f,c&&c.copy(T),r&&r.copy(n))}for(let d=0;d<3;d++){const f=e[d],h=e[(d+1)%3];s.set(this[f],this[h]);for(let y=0;y<3;y++){const T=e[y],w=e[(y+1)%3];i.set(a[T],a[w]),Vn(s,i,n,t);const p=n.distanceToSquared(t);p<l&&(l=p,c&&c.copy(n),r&&r.copy(t))}}return Math.sqrt(l)}}();class ${constructor(t,e,s){this.isOrientedBox=!0,this.min=new C,this.max=new C,this.matrix=new ot,this.invMatrix=new ot,this.points=new Array(8).fill().map(()=>new C),this.satAxes=new Array(3).fill().map(()=>new C),this.satBounds=new Array(3).fill().map(()=>new yt),this.alignedSatBounds=new Array(3).fill().map(()=>new yt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}$.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,h=i[f];h.x=u?s.x:e.x,h.y=l?s.y:e.y,h.z=d?s.z:e.z,h.applyMatrix4(t)}const o=this.satBounds,a=this.satAxes,c=i[0];for(let u=0;u<3;u++){const l=a[u],d=o[u],f=1<<u,h=i[f];l.subVectors(c,h),d.setFromPoints(l,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();$.prototype.intersectsBox=function(){const n=new yt;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,o=this.satBounds,a=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const u=a[r],l=o[r];if(n.setFromBox(u,e),l.isSeparated(n))return!1}return!0}}();$.prototype.intersectsTriangle=function(){const n=new Q,t=new Array(3),e=new yt,s=new yt,i=new C;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(n.copy(a),n.update(),a=n);const c=this.satBounds,r=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let f=0;f<3;f++){const h=c[f],y=r[f];if(e.setFromPoints(y,t),h.isSeparated(e))return!1}const u=a.satBounds,l=a.satAxes,d=this.points;for(let f=0;f<3;f++){const h=u[f],y=l[f];if(e.setFromPoints(y,d),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=r[f];for(let y=0;y<4;y++){const T=l[y];if(i.crossVectors(h,T),e.setFromPoints(i,t),s.setFromPoints(i,d),e.isSeparated(s))return!1}}return!0}}();$.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();$.prototype.distanceToPoint=function(){const n=new C;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();$.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new J),e=new Array(12).fill().map(()=>new J),s=new C,i=new C;return function(a,c=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(r||u)&&(a.getCenter(i),this.closestPointToPoint(i,s),a.closestPointToPoint(s,i),r&&r.copy(s),u&&u.copy(i)),0;const l=c*c,d=a.min,f=a.max,h=this.points;let y=1/0;for(let w=0;w<8;w++){const p=h[w];i.copy(p).clamp(d,f);const m=p.distanceToSquared(i);if(m<y&&(y=m,r&&r.copy(p),u&&u.copy(i),m<l))return Math.sqrt(m)}let T=0;for(let w=0;w<3;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){const g=(w+1)%3,A=(w+2)%3,x=p<<g|m<<A,S=1<<w|p<<g|m<<A,b=h[x],B=h[S];t[T].set(b,B);const M=n[w],E=n[g],_=n[A],I=e[T],z=I.start,L=I.end;z[M]=d[M],z[E]=p?d[E]:f[E],z[_]=m?d[_]:f[E],L[M]=f[M],L[E]=p?d[E]:f[E],L[_]=m?d[_]:f[E],T++}for(let w=0;w<=1;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){i.x=w?f.x:d.x,i.y=p?f.y:d.y,i.z=m?f.z:d.z,this.closestPointToPoint(i,s);const g=i.distanceToSquared(s);if(g<y&&(y=g,r&&r.copy(s),u&&u.copy(i),g<l))return Math.sqrt(g)}for(let w=0;w<12;w++){const p=t[w];for(let m=0;m<12;m++){const g=e[m];Vn(p,g,s,i);const A=s.distanceToSquared(i);if(A<y&&(y=A,r&&r.copy(s),u&&u.copy(i),A<l))return Math.sqrt(A)}}return Math.sqrt(y)}}();class Dn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class tr extends Dn{constructor(){super(()=>new Q)}}const K=new tr;class er{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const v=new er;let Tt,Xt;const Ut=[],we=new Dn(()=>new it);function nr(n,t,e,s,i,o){Tt=we.getPrimitive(),Xt=we.getPrimitive(),Ut.push(Tt,Xt),v.setBuffer(n._roots[t]);const a=In(0,n.geometry,e,s,i,o);v.clearBuffer(),we.releasePrimitive(Tt),we.releasePrimitive(Xt),Ut.pop(),Ut.pop();const c=Ut.length;return c>0&&(Xt=Ut[c-1],Tt=Ut[c-2]),a}function In(n,t,e,s,i=null,o=0,a=0){const{float32Array:c,uint16Array:r,uint32Array:u}=v;let l=n*2;if(H(l,r)){const f=W(n,u),h=j(l,r);return U(n,c,Tt),s(f,h,!1,a,o+n,Tt)}else{let M=function(_){const{uint16Array:I,uint32Array:z}=v;let L=_*2;for(;!H(L,I);)_=Z(_),L=_*2;return W(_,z)},E=function(_){const{uint16Array:I,uint32Array:z}=v;let L=_*2;for(;!H(L,I);)_=Y(_,z),L=_*2;return W(_,z)+j(L,I)};const f=Z(n),h=Y(n,u);let y=f,T=h,w,p,m,g;if(i&&(m=Tt,g=Xt,U(y,c,m),U(T,c,g),w=i(m),p=i(g),p<w)){y=h,T=f;const _=w;w=p,p=_,m=g}m||(m=Tt,U(y,c,m));const A=H(y*2,r),x=e(m,A,w,a+1,o+y);let S;if(x===is){const _=M(y),z=E(y)-_;S=s(_,z,!0,a+1,o+y,m)}else S=x&&In(y,t,e,s,i,o,a+1);if(S)return!0;g=Xt,U(T,c,g);const b=H(T*2,r),B=e(g,b,p,a+1,o+T);let P;if(B===is){const _=M(T),z=E(T)-_;P=s(_,z,!0,a+1,o+T,g)}else P=B&&In(T,t,e,s,i,o,a+1);return!!P}}const ne=new C,cn=new C;function sr(n,t,e={},s=0,i=1/0){const o=s*s,a=i*i;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(ne.copy(t).clamp(l.min,l.max),ne.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<c&&f<a,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,ne);const f=t.distanceToSquared(ne);return f<c&&(cn.copy(ne),c=f,r=d),f<o}}),c===1/0)return null;const u=Math.sqrt(c);return e.point?e.point.copy(cn):e.point=cn.clone(),e.distance=u,e.faceIndex=r,e}const Ft=new C,Vt=new C,Dt=new C,xe=new Rt,Ae=new Rt,be=new Rt,ls=new C,us=new C,fs=new C,Te=new C;function ir(n,t,e,s,i,o){let a;return o===bi?a=n.intersectTriangle(s,e,t,!0,i):a=n.intersectTriangle(t,e,s,o!==Un,i),a===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function rr(n,t,e,s,i,o,a,c,r){Ft.fromBufferAttribute(t,o),Vt.fromBufferAttribute(t,a),Dt.fromBufferAttribute(t,c);const u=ir(n,Ft,Vt,Dt,Te,r);if(u){s&&(xe.fromBufferAttribute(s,o),Ae.fromBufferAttribute(s,a),be.fromBufferAttribute(s,c),u.uv=G.getInterpolation(Te,Ft,Vt,Dt,xe,Ae,be,new Rt)),i&&(xe.fromBufferAttribute(i,o),Ae.fromBufferAttribute(i,a),be.fromBufferAttribute(i,c),u.uv1=G.getInterpolation(Te,Ft,Vt,Dt,xe,Ae,be,new Rt)),e&&(ls.fromBufferAttribute(e,o),us.fromBufferAttribute(e,a),fs.fromBufferAttribute(e,c),u.normal=G.getInterpolation(Te,Ft,Vt,Dt,ls,us,fs,new C),u.normal.dot(n.direction)>0&&u.normal.multiplyScalar(-1));const l={a:o,b:a,c,normal:new C,materialIndex:0};G.getNormal(Ft,Vt,Dt,l.normal),u.face=l,u.faceIndex=o}return u}function Xe(n,t,e,s,i){const o=s*3;let a=o+0,c=o+1,r=o+2;const u=n.index;n.index&&(a=u.getX(a),c=u.getX(c),r=u.getX(r));const{position:l,normal:d,uv:f,uv1:h}=n.attributes,y=rr(e,l,d,f,h,a,c,r,t);return y?(y.faceIndex=s,i&&i.push(y),y):null}function V(n,t,e,s){const i=n.a,o=n.b,a=n.c;let c=t,r=t+1,u=t+2;e&&(c=e.getX(c),r=e.getX(r),u=e.getX(u)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),o.x=s.getX(r),o.y=s.getY(r),o.z=s.getZ(r),a.x=s.getX(u),a.y=s.getY(u),a.z=s.getZ(u)}function or(n,t,e,s,i,o){const{geometry:a,_indirectBuffer:c}=n;for(let r=s,u=s+i;r<u;r++)Xe(a,t,e,r,o)}function cr(n,t,e,s,i){const{geometry:o,_indirectBuffer:a}=n;let c=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let d;d=Xe(o,t,e,u),d&&d.distance<c&&(r=d,c=d.distance)}return r}function ar(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,u=c.attributes.position;for(let l=n,d=t+n;l<d;l++){let f;if(f=l,V(a,f*3,r,u),a.needsUpdate=!0,s(a,f,i,o))return!0}return!1}function lr(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,h,y=!1){const T=f*2;if(c[T+15]===We){const p=a[f+6],m=c[T+14];let g=1/0,A=1/0,x=1/0,S=-1/0,b=-1/0,B=-1/0;for(let P=3*p,M=3*(p+m);P<M;P++){let E=s[P];const _=i.getX(E),I=i.getY(E),z=i.getZ(E);_<g&&(g=_),_>S&&(S=_),I<A&&(A=I),I>b&&(b=I),z<x&&(x=z),z>B&&(B=z)}return r[f+0]!==g||r[f+1]!==A||r[f+2]!==x||r[f+3]!==S||r[f+4]!==b||r[f+5]!==B?(r[f+0]=g,r[f+1]=A,r[f+2]=x,r[f+3]=S,r[f+4]=b,r[f+5]=B,!0):!1}else{const p=f+8,m=a[f+6],g=p+h,A=m+h;let x=y,S=!1,b=!1;t?x||(S=t.has(g),b=t.has(A),x=!S&&!b):(S=!0,b=!0);const B=x||S,P=x||b;let M=!1;B&&(M=d(p,h,x));let E=!1;P&&(E=d(m,h,x));const _=M||E;if(_)for(let I=0;I<3;I++){const z=p+I,L=m+I,R=r[z],D=r[z+3],vt=r[L],_t=r[L+3];r[f+I]=R<vt?R:vt,r[f+I+3]=D>_t?D:_t}return _}}}const ds=new it;function Bt(n,t,e,s){return U(n,t,ds),e.intersectBox(ds,s)}function ur(n,t,e,s,i,o){const{geometry:a,_indirectBuffer:c}=n;for(let r=s,u=s+i;r<u;r++){let l=c?c[r]:r;Xe(a,t,e,l,o)}}function fr(n,t,e,s,i){const{geometry:o,_indirectBuffer:a}=n;let c=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let d;d=Xe(o,t,e,a?a[u]:u),d&&d.distance<c&&(r=d,c=d.distance)}return r}function dr(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,u=c.attributes.position;for(let l=n,d=t+n;l<d;l++){let f;if(f=e.resolveTriangleIndex(l),V(a,f*3,r,u),a.needsUpdate=!0,s(a,f,i,o))return!0}return!1}const ps=new C;function pr(n,t,e,s,i){v.setBuffer(n._roots[t]),En(0,n,e,s,i),v.clearBuffer()}function En(n,t,e,s,i){const{float32Array:o,uint16Array:a,uint32Array:c}=v,r=n*2;if(H(r,a)){const l=W(n,c),d=j(r,a);or(t,e,s,l,d,i)}else{const l=Z(n);Bt(l,o,s,ps)&&En(l,t,e,s,i);const d=Y(n,c);Bt(d,o,s,ps)&&En(d,t,e,s,i)}}const hs=new C,hr=["x","y","z"];function yr(n,t,e,s){v.setBuffer(n._roots[t]);const i=Cn(0,n,e,s);return v.clearBuffer(),i}function Cn(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:a}=v;let c=n*2;if(H(c,o)){const u=W(n,a),l=j(c,o);return cr(t,e,s,u,l)}else{const u=Ws(n,a),l=hr[u],f=s.direction[l]>=0;let h,y;f?(h=Z(n),y=Y(n,a)):(h=Y(n,a),y=Z(n));const w=Bt(h,i,s,hs)?Cn(h,t,e,s):null;if(w){const g=w.point[l];if(f?g<=i[y+u]:g>=i[y+u+3])return w}const m=Bt(y,i,s,hs)?Cn(y,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const Se=new it,kt=new Q,$t=new Q,se=new ot,ys=new $,Be=new $;function gr(n,t,e,s){v.setBuffer(n._roots[t]);const i=zn(0,n,e,s);return v.clearBuffer(),i}function zn(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=v;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),ys.set(e.boundingBox.min,e.boundingBox.max,s),i=ys),H(r,a)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,y=e.attributes.position,T=W(n,c),w=j(r,a);if(se.copy(s).invert(),e.boundsTree)return U(n,o,Be),Be.matrix.copy(se),Be.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Be.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let g=T*3,A=(w+T)*3;g<A;g+=3)if(V($t,g,d,f),$t.needsUpdate=!0,m.intersectsTriangle($t))return!0;return!1}});for(let p=T*3,m=(w+T)*3;p<m;p+=3){V(kt,p,d,f),kt.a.applyMatrix4(se),kt.b.applyMatrix4(se),kt.c.applyMatrix4(se),kt.needsUpdate=!0;for(let g=0,A=h.count;g<A;g+=3)if(V($t,g,h,y),$t.needsUpdate=!0,kt.intersectsTriangle($t))return!0}}else{const l=n+8,d=c[n+6];return U(l,o,Se),!!(i.intersectsBox(Se)&&zn(l,t,e,s,i)||(U(d,o,Se),i.intersectsBox(Se)&&zn(d,t,e,s,i)))}}const Pe=new ot,an=new $,ie=new $,mr=new C,wr=new C,xr=new C,Ar=new C;function br(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),an.set(t.boundingBox.min,t.boundingBox.max,e),an.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,u=c.index,l=t.attributes.position,d=t.index,f=K.getPrimitive(),h=K.getPrimitive();let y=mr,T=wr,w=null,p=null;i&&(w=xr,p=Ar);let m=1/0,g=null,A=null;return Pe.copy(e).invert(),ie.matrix.copy(Pe),n.shapecast({boundsTraverseOrder:x=>an.distanceToBox(x),intersectsBounds:(x,S,b)=>b<m&&b<a?(S&&(ie.min.copy(x.min),ie.max.copy(x.max),ie.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>ie.distanceToBox(B),intersectsBounds:(B,P,M)=>M<m&&M<a,intersectsRange:(B,P)=>{for(let M=B,E=B+P;M<E;M++){V(h,3*M,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let _=x,I=x+S;_<I;_++){V(f,3*_,u,r),f.needsUpdate=!0;const z=f.distanceToTriangle(h,y,w);if(z<m&&(T.copy(y),p&&p.copy(w),m=z,g=_,A=M),z<o)return!0}}}});{const b=Zt(t);for(let B=0,P=b;B<P;B++){V(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=x,E=x+S;M<E;M++){V(f,3*M,u,r),f.needsUpdate=!0;const _=f.distanceToTriangle(h,y,w);if(_<m&&(T.copy(y),p&&p.copy(w),m=_,g=M,A=B),_<o)return!0}}}}}),K.releasePrimitive(f),K.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=m,s.faceIndex=g,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Pe),T.applyMatrix4(Pe),i.distance=T.sub(i.point).length(),i.faceIndex=A),s)}function Tr(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,h,y=!1){const T=f*2;if(c[T+15]===We){const p=a[f+6],m=c[T+14];let g=1/0,A=1/0,x=1/0,S=-1/0,b=-1/0,B=-1/0;for(let P=p,M=p+m;P<M;P++){const E=3*n.resolveTriangleIndex(P);for(let _=0;_<3;_++){let I=E+_;I=s?s[I]:I;const z=i.getX(I),L=i.getY(I),R=i.getZ(I);z<g&&(g=z),z>S&&(S=z),L<A&&(A=L),L>b&&(b=L),R<x&&(x=R),R>B&&(B=R)}}return r[f+0]!==g||r[f+1]!==A||r[f+2]!==x||r[f+3]!==S||r[f+4]!==b||r[f+5]!==B?(r[f+0]=g,r[f+1]=A,r[f+2]=x,r[f+3]=S,r[f+4]=b,r[f+5]=B,!0):!1}else{const p=f+8,m=a[f+6],g=p+h,A=m+h;let x=y,S=!1,b=!1;t?x||(S=t.has(g),b=t.has(A),x=!S&&!b):(S=!0,b=!0);const B=x||S,P=x||b;let M=!1;B&&(M=d(p,h,x));let E=!1;P&&(E=d(m,h,x));const _=M||E;if(_)for(let I=0;I<3;I++){const z=p+I,L=m+I,R=r[z],D=r[z+3],vt=r[L],_t=r[L+3];r[f+I]=R<vt?R:vt,r[f+I+3]=D>_t?D:_t}return _}}}const gs=new C;function Sr(n,t,e,s,i){v.setBuffer(n._roots[t]),Ln(0,n,e,s,i),v.clearBuffer()}function Ln(n,t,e,s,i){const{float32Array:o,uint16Array:a,uint32Array:c}=v,r=n*2;if(H(r,a)){const l=W(n,c),d=j(r,a);ur(t,e,s,l,d,i)}else{const l=Z(n);Bt(l,o,s,gs)&&Ln(l,t,e,s,i);const d=Y(n,c);Bt(d,o,s,gs)&&Ln(d,t,e,s,i)}}const ms=new C,Br=["x","y","z"];function Pr(n,t,e,s){v.setBuffer(n._roots[t]);const i=Rn(0,n,e,s);return v.clearBuffer(),i}function Rn(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:a}=v;let c=n*2;if(H(c,o)){const u=W(n,a),l=j(c,o);return fr(t,e,s,u,l)}else{const u=Ws(n,a),l=Br[u],f=s.direction[l]>=0;let h,y;f?(h=Z(n),y=Y(n,a)):(h=Y(n,a),y=Z(n));const w=Bt(h,i,s,ms)?Rn(h,t,e,s):null;if(w){const g=w.point[l];if(f?g<=i[y+u]:g>=i[y+u+3])return w}const m=Bt(y,i,s,ms)?Rn(y,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const _e=new it,Ht=new Q,Ot=new Q,re=new ot,ws=new $,Me=new $;function _r(n,t,e,s){v.setBuffer(n._roots[t]);const i=Nn(0,n,e,s);return v.clearBuffer(),i}function Nn(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=v;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),ws.set(e.boundingBox.min,e.boundingBox.max,s),i=ws),H(r,a)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,y=e.attributes.position,T=W(n,c),w=j(r,a);if(re.copy(s).invert(),e.boundsTree)return U(n,o,Me),Me.matrix.copy(re),Me.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Me.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let g=T,A=w+T;g<A;g++)if(V(Ot,3*t.resolveTriangleIndex(g),d,f),Ot.needsUpdate=!0,m.intersectsTriangle(Ot))return!0;return!1}});for(let p=T,m=w+T;p<m;p++){const g=t.resolveTriangleIndex(p);V(Ht,3*g,d,f),Ht.a.applyMatrix4(re),Ht.b.applyMatrix4(re),Ht.c.applyMatrix4(re),Ht.needsUpdate=!0;for(let A=0,x=h.count;A<x;A+=3)if(V(Ot,A,h,y),Ot.needsUpdate=!0,Ht.intersectsTriangle(Ot))return!0}}else{const l=n+8,d=c[n+6];return U(l,o,_e),!!(i.intersectsBox(_e)&&Nn(l,t,e,s,i)||(U(d,o,_e),i.intersectsBox(_e)&&Nn(d,t,e,s,i)))}}const Ie=new ot,ln=new $,oe=new $,Mr=new C,Ir=new C,Er=new C,Cr=new C;function zr(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),ln.set(t.boundingBox.min,t.boundingBox.max,e),ln.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,u=c.index,l=t.attributes.position,d=t.index,f=K.getPrimitive(),h=K.getPrimitive();let y=Mr,T=Ir,w=null,p=null;i&&(w=Er,p=Cr);let m=1/0,g=null,A=null;return Ie.copy(e).invert(),oe.matrix.copy(Ie),n.shapecast({boundsTraverseOrder:x=>ln.distanceToBox(x),intersectsBounds:(x,S,b)=>b<m&&b<a?(S&&(oe.min.copy(x.min),oe.max.copy(x.max),oe.needsUpdate=!0),!0):!1,intersectsRange:(x,S)=>{if(t.boundsTree){const b=t.boundsTree;return b.shapecast({boundsTraverseOrder:B=>oe.distanceToBox(B),intersectsBounds:(B,P,M)=>M<m&&M<a,intersectsRange:(B,P)=>{for(let M=B,E=B+P;M<E;M++){const _=b.resolveTriangleIndex(M);V(h,3*_,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let I=x,z=x+S;I<z;I++){const L=n.resolveTriangleIndex(I);V(f,3*L,u,r),f.needsUpdate=!0;const R=f.distanceToTriangle(h,y,w);if(R<m&&(T.copy(y),p&&p.copy(w),m=R,g=I,A=M),R<o)return!0}}}})}else{const b=Zt(t);for(let B=0,P=b;B<P;B++){V(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=x,E=x+S;M<E;M++){const _=n.resolveTriangleIndex(M);V(f,3*_,u,r),f.needsUpdate=!0;const I=f.distanceToTriangle(h,y,w);if(I<m&&(T.copy(y),p&&p.copy(w),m=I,g=M,A=B),I<o)return!0}}}}}),K.releasePrimitive(f),K.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=m,s.faceIndex=g,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Ie),T.applyMatrix4(Ie),i.distance=T.sub(i.point).length(),i.faceIndex=A),s)}function Lr(){return typeof SharedArrayBuffer<"u"}const ue=new v.constructor,ke=new v.constructor,At=new Dn(()=>new it),Gt=new it,Wt=new it,un=new it,fn=new it;let dn=!1;function Rr(n,t,e,s){if(dn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");dn=!0;const i=n._roots,o=t._roots;let a,c=0,r=0;const u=new ot().copy(e).invert();for(let l=0,d=i.length;l<d;l++){ue.setBuffer(i[l]),r=0;const f=At.getPrimitive();U(0,ue.float32Array,f),f.applyMatrix4(u);for(let h=0,y=o.length;h<y&&(ke.setBuffer(o[l]),a=tt(0,0,e,u,s,c,r,0,0,f),ke.clearBuffer(),r+=o[h].length,!a);h++);if(At.releasePrimitive(f),ue.clearBuffer(),c+=i[l].length,a)break}return dn=!1,a}function tt(n,t,e,s,i,o=0,a=0,c=0,r=0,u=null,l=!1){let d,f;l?(d=ke,f=ue):(d=ue,f=ke);const h=d.float32Array,y=d.uint32Array,T=d.uint16Array,w=f.float32Array,p=f.uint32Array,m=f.uint16Array,g=n*2,A=t*2,x=H(g,T),S=H(A,m);let b=!1;if(S&&x)l?b=i(W(t,p),j(t*2,m),W(n,y),j(n*2,T),r,a+t,c,o+n):b=i(W(n,y),j(n*2,T),W(t,p),j(t*2,m),c,o+n,r,a+t);else if(S){const B=At.getPrimitive();U(t,w,B),B.applyMatrix4(e);const P=Z(n),M=Y(n,y);U(P,h,Gt),U(M,h,Wt);const E=B.intersectsBox(Gt),_=B.intersectsBox(Wt);b=E&&tt(t,P,s,e,i,a,o,r,c+1,B,!l)||_&&tt(t,M,s,e,i,a,o,r,c+1,B,!l),At.releasePrimitive(B)}else{const B=Z(t),P=Y(t,p);U(B,w,un),U(P,w,fn);const M=u.intersectsBox(un),E=u.intersectsBox(fn);if(M&&E)b=tt(n,B,e,s,i,o,a,c,r+1,u,l)||tt(n,P,e,s,i,o,a,c,r+1,u,l);else if(M)if(x)b=tt(n,B,e,s,i,o,a,c,r+1,u,l);else{const _=At.getPrimitive();_.copy(un).applyMatrix4(e);const I=Z(n),z=Y(n,y);U(I,h,Gt),U(z,h,Wt);const L=_.intersectsBox(Gt),R=_.intersectsBox(Wt);b=L&&tt(B,I,s,e,i,a,o,r,c+1,_,!l)||R&&tt(B,z,s,e,i,a,o,r,c+1,_,!l),At.releasePrimitive(_)}else if(E)if(x)b=tt(n,P,e,s,i,o,a,c,r+1,u,l);else{const _=At.getPrimitive();_.copy(fn).applyMatrix4(e);const I=Z(n),z=Y(n,y);U(I,h,Gt),U(z,h,Wt);const L=_.intersectsBox(Gt),R=_.intersectsBox(Wt);b=L&&tt(P,I,s,e,i,a,o,r,c+1,_,!l)||R&&tt(P,z,s,e,i,a,o,r,c+1,_,!l),At.releasePrimitive(_)}}return b}const Ee=new $,xs=new it,Nr={strategy:Hs,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class kn{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,o=t._indirectBuffer,a=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(r=>r.slice()),index:a.array.slice(),indirectBuffer:o?o.slice():null}:c={roots:i,index:a.array,indirectBuffer:o},c}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:o,indirectBuffer:a}=t,c=new kn(e,{...s,[nn]:!0});if(c._roots=o,c._indirectBuffer=a||null,s.setIndex){const r=e.getIndex();if(r===null){const u=new Oe(t.index,1,!1);e.setIndex(u)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...Nr,[nn]:!1},e),e.useSharedArrayBuffer&&!Lr())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[nn]||(Yi(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new it)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?Tr:lr)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),o=new Uint16Array(s);a(0);function a(c,r=0){const u=c*2,l=o[u+15]===We;if(l){const d=i[c+6],f=o[u+14];t(r,l,new Float32Array(s,c*4,6),d,f)}else{const d=c+le/4,f=i[c+6],h=i[c+7];t(r,l,new Float32Array(s,c*4,6),h)||(a(d,r+1),a(f,r+1))}}}raycast(t,e=ns){const s=this._roots,i=this.geometry,o=[],a=e.isMaterial,c=Array.isArray(e),r=i.groups,u=a?e.side:e,l=this.indirect?Sr:pr;for(let d=0,f=s.length;d<f;d++){const h=c?e[r[d].materialIndex].side:u,y=o.length;if(l(this,d,h,t,o),c){const T=r[d].materialIndex;for(let w=y,p=o.length;w<p;w++)o[w].face.materialIndex=T}}return o}raycastFirst(t,e=ns){const s=this._roots,i=this.geometry,o=e.isMaterial,a=Array.isArray(e);let c=null;const r=i.groups,u=o?e.side:e,l=this.indirect?Pr:yr;for(let d=0,f=s.length;d<f;d++){const h=a?e[r[d].materialIndex].side:u,y=l(this,d,h,t);y!=null&&(c==null||y.distance<c.distance)&&(c=y,a&&(y.face.materialIndex=r[d].materialIndex))}return c}intersectsGeometry(t,e){let s=!1;const i=this._roots,o=this.indirect?_r:gr;for(let a=0,c=i.length;a<c&&(s=o(this,a,t,e),!s);a++);return s}shapecast(t){const e=K.getPrimitive(),s=this.indirect?dr:ar;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const d=a;a=(f,h,y,T,w)=>d(f,h,y,T,w)?!0:s(f,h,this,c,y,T,e)}else a||(c?a=(d,f,h,y)=>s(d,f,this,c,h,y,e):a=(d,f,h)=>h);let r=!1,u=0;const l=this._roots;for(let d=0,f=l.length;d<f;d++){const h=l[d];if(r=nr(this,d,o,a,i,u),r)break;u+=h.byteLength}return K.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const a=K.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,u=this.indirect?y=>{const T=this.resolveTriangleIndex(y);V(a,T*3,c,r)}:y=>{V(a,y*3,c,r)},l=K.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?y=>{const T=t.resolveTriangleIndex(y);V(l,T*3,d,f)}:y=>{V(l,y*3,d,f)};if(o){const y=(T,w,p,m,g,A,x,S)=>{for(let b=p,B=p+m;b<B;b++){h(b),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let P=T,M=T+w;P<M;P++)if(u(P),a.needsUpdate=!0,o(a,l,P,b,g,A,x,S))return!0}return!1};if(i){const T=i;i=function(w,p,m,g,A,x,S,b){return T(w,p,m,g,A,x,S,b)?!0:y(w,p,m,g,A,x,S,b)}}else i=y}return Rr(this,t,e,i)}intersectsBox(t,e){return Ee.set(t.min,t.max,e),Ee.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Ee.intersectsBox(s),intersectsTriangle:s=>Ee.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},o=0,a=1/0){return(this.indirect?zr:br)(this,t,e,s,i,o,a)}closestPointToPoint(t,e={},s=0,i=1/0){return sr(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),xs),t.union(xs)}),t}}const js=1e-6,vr=js*.5,Zs=Math.pow(10,-Math.log10(js)),Ur=vr*Zs;function rt(n){return~~(n*Zs+Ur)}function Fr(n){return`${rt(n.x)},${rt(n.y)}`}function As(n){return`${rt(n.x)},${rt(n.y)},${rt(n.z)}`}function Vr(n){return`${rt(n.x)},${rt(n.y)},${rt(n.z)},${rt(n.w)}`}function Dr(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}function Ys(){return typeof SharedArrayBuffer<"u"}function kr(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,s=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(s).set(i,0),new t(s)}function $r(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Hr(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=$r(e,s);n.setIndex(new Oe(i,1));for(let o=0;o<e;o++)i[o]=o}}function Or(n){return n.index?n.index.count:n.attributes.position.count}function $n(n){return Or(n)/3}const Gr=1e-8,Wr=new C;function Xr(n){return~~(n/3)}function qr(n){return n%3}function bs(n,t){return n.start-t.start}function Ts(n,t){return Wr.subVectors(t,n.origin).dot(n.direction)}function jr(n,t,e,s=Gr){n.sort(bs),t.sort(bs);for(let c=0;c<n.length;c++){const r=n[c];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)o(l.end,r.end)||n.splice(c+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)o(r.end,l.end)||t.splice(u+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const d=r.end;r.end=l.start,l.start=d}else if(r.start>=l.start&&r.end>=l.end){const d=l.end;l.end=r.start,r.start=d}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),a(l)&&(t.splice(u,1),u--),a(r)){n.splice(c,1),c--;break}}}i(n),i(t);function i(c){for(let r=0;r<c.length;r++)a(c[r])&&(c.splice(r,1),r--)}function o(c,r){return Math.abs(r-c)<s}function a(c){return Math.abs(c.end-c.start)<s}}const Ss=1e-5,Bs=1e-4;class Zr{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,o=null;for(let r=0,u=e.length;r<u;r++){const l=e[r];if(a(l,t)&&a(l,s))continue;const d=c(l,t),f=c(l,s),h=Math.min(d,f);h<i&&(i=h,o=l)}return o;function a(r,u){const l=r.origin.distanceTo(u.origin)>Ss;return r.direction.angleTo(u.direction)>Bs||l}function c(r,u){const l=r.origin.distanceTo(u.origin),d=r.direction.angleTo(u.direction);return l/Ss+d/Bs}}}const pn=new C,hn=new C,Ce=new ks;function Yr(n,t,e){const s=n.attributes,i=n.index,o=s.position,a=new Map,c=new Map,r=Array.from(t),u=new Zr;for(let l=0,d=r.length;l<d;l++){const f=r[l],h=Xr(f),y=qr(f);let T=3*h+y,w=3*h+(y+1)%3;i&&(T=i.getX(T),w=i.getX(w)),pn.fromBufferAttribute(o,T),hn.fromBufferAttribute(o,w),Dr(pn,hn,Ce);let p,m=u.findClosestRay(Ce);m===null&&(m=Ce.clone(),u.addRay(m)),c.has(m)||c.set(m,{forward:[],reverse:[],ray:m}),p=c.get(m);let g=Ts(m,pn),A=Ts(m,hn);g>A&&([g,A]=[A,g]),Ce.direction.dot(m.direction)<0?p.reverse.push({start:g,end:A,index:f}):p.forward.push({start:g,end:A,index:f})}return c.forEach(({forward:l,reverse:d},f)=>{jr(l,d,a,e),l.length===0&&d.length===0&&c.delete(f)}),{disjointConnectivityMap:a,fragmentMap:c}}const Kr=new Rt,yn=new C,Jr=new Nt,gn=["","",""];class Qr{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>~~(o/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>o%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:o}=this,a=e?g:m,c=new Map,{attributes:r}=t,u=e?Object.keys(r):null,l=t.index,d=r.position;let f=$n(t);const h=f;let y=0;s&&(y=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let T=this.data;(!T||T.length<3*h)&&(T=new Int32Array(3*h)),T.fill(-1);let w=0,p=new Set;for(let A=y,x=f*3+y;A<x;A+=3){const S=A;for(let b=0;b<3;b++){let B=S+b;l&&(B=l.getX(B)),gn[b]=a(B)}for(let b=0;b<3;b++){const B=(b+1)%3,P=gn[b],M=gn[B],E=`${M}_${P}`;if(c.has(E)){const _=S+b,I=c.get(E);T[_]=I,T[I]=_,c.delete(E),w+=2,p.delete(I)}else{const _=`${P}_${M}`,I=S+b;c.set(_,I),p.add(I)}}}if(i){const{fragmentMap:A,disjointConnectivityMap:x}=Yr(t,p,o);p.clear(),A.forEach(({forward:S,reverse:b})=>{S.forEach(({index:B})=>p.add(B)),b.forEach(({index:B})=>p.add(B))}),this.unmatchedDisjointEdges=A,this.disjointConnections=x,w=f*3-p.size}this.matchedEdges=w,this.unmatchedEdges=p.size,this.data=T;function m(A){return yn.fromBufferAttribute(d,A),As(yn)}function g(A){let x="";for(let S=0,b=u.length;S<b;S++){const B=r[u[S]];let P;switch(B.itemSize){case 1:P=rt(B.getX(A));break;case 2:P=Fr(Kr.fromBufferAttribute(B,A));break;case 3:P=As(yn.fromBufferAttribute(B,A));break;case 4:P=Vr(Jr.fromBufferAttribute(B,A));break}x!==""&&(x+="|"),x+=P}return x}}}class ct extends jt{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new ot,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let o=0;o<16;o++)if(s[o]!==i[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=Ys();if(s)for(const i in e){const o=e[i];if(o.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");o.array=kr(o.array)}if(t.boundsTree||(Hr(t,{useSharedArrayBuffer:s}),t.boundsTree=new kn(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new Qr(t)),!t.groupIndices){const i=$n(t),o=new Uint16Array(i),a=t.groups;for(let c=0,r=a.length;c<r;c++){const{start:u,count:l}=a[c];for(let d=u/3,f=(u+l)/3;d<f;d++)o[d]=c}t.groupIndices=o}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const to=1e-14,mn=new C,Ps=new C,_s=new C;function bt(n,t=to){mn.subVectors(n.b,n.a),Ps.subVectors(n.c,n.a),_s.subVectors(n.b,n.c);const e=mn.angleTo(Ps),s=mn.angleTo(_s),i=Math.PI-e-s;return Math.abs(e)<t||Math.abs(s)<t||Math.abs(i)<t||n.a.distanceToSquared(n.b)<t||n.a.distanceToSquared(n.c)<t||n.b.distanceToSquared(n.c)<t}const wn=1e-10,ce=1e-10,eo=1e-10,ft=new J,F=new J,dt=new C,xn=new C,Ms=new C,ze=new vn,An=new Q;class no{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new G),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class so{constructor(){this.trianglePool=new no,this.triangles=[],this.normal=new C,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:s,normal:i}=this;if(Array.isArray(t))for(let o=0,a=t.length;o<a;o++){const c=t[o];if(o===0)c.getNormal(i);else if(Math.abs(1-c.getNormal(dt).dot(i))>wn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const r=s.getTriangle();r.copy(c),e.push(r)}else{t.getNormal(i);const o=s.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:s}=this;if(t.getNormal(xn).normalize(),Math.abs(1-Math.abs(xn.dot(e)))<eo){this.coplanarTriangleUsed=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];c.coplanarCount=0}const i=[t.a,t.b,t.c];for(let o=0;o<3;o++){const a=(o+1)%3,c=i[o],r=i[a];dt.subVectors(r,c).normalize(),Ms.crossVectors(xn,dt),ze.setFromNormalAndCoplanarPoint(Ms,c),this.splitByPlane(ze,t)}}else t.getPlane(ze),this.splitByPlane(ze,t)}splitByPlane(t,e){const{triangles:s,trianglePool:i}=this;An.copy(e),An.needsUpdate=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];if(!An.intersectsTriangle(c,ft,!0))continue;const{a:r,b:u,c:l}=c;let d=0,f=-1,h=!1,y=[],T=[];const w=[r,u,l];for(let p=0;p<3;p++){const m=(p+1)%3;ft.start.copy(w[p]),ft.end.copy(w[m]);const g=t.distanceToPoint(ft.start),A=t.distanceToPoint(ft.end);if(Math.abs(g)<ce&&Math.abs(A)<ce){h=!0;break}if(g>0?y.push(p):T.push(p),Math.abs(g)<ce)continue;let x=!!t.intersectLine(ft,dt);!x&&Math.abs(A)<ce&&(dt.copy(ft.end),x=!0),x&&!(dt.distanceTo(ft.start)<wn)&&(dt.distanceTo(ft.end)<wn&&(f=p),d===0?F.start.copy(dt):F.end.copy(dt),d++)}if(!h&&d===2&&F.distance()>ce)if(f!==-1){f=(f+1)%3;let p=0;p===f&&(p=(p+1)%3);let m=p+1;m===f&&(m=(m+1)%3);const g=i.getTriangle();g.a.copy(w[m]),g.b.copy(F.end),g.c.copy(F.start),bt(g)||s.push(g),c.a.copy(w[p]),c.b.copy(F.start),c.c.copy(F.end),bt(c)&&(s.splice(o,1),o--,a--)}else{const p=y.length>=2?T[0]:y[0];if(p===0){let S=F.start;F.start=F.end,F.end=S}const m=(p+1)%3,g=(p+2)%3,A=i.getTriangle(),x=i.getTriangle();w[m].distanceToSquared(F.start)<w[g].distanceToSquared(F.end)?(A.a.copy(w[m]),A.b.copy(F.start),A.c.copy(F.end),x.a.copy(w[m]),x.b.copy(w[g]),x.c.copy(F.start)):(A.a.copy(w[g]),A.b.copy(F.start),A.c.copy(F.end),x.a.copy(w[m]),x.b.copy(w[g]),x.c.copy(F.end)),c.a.copy(w[p]),c.b.copy(F.end),c.c.copy(F.start),bt(A)||s.push(A),bt(x)||s.push(x),bt(c)&&(s.splice(o,1),o--,a--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function io(n){return n=~~n,n+4-n%4}class Is{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,s=Ys()?SharedArrayBuffer:ArrayBuffer,i=new e(new s(io(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:s}=this;s+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,o=t.length;i<o;i++)e[s+i]=t[i];this.length+=t.length}clear(){this.length=0}}class ro{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:s}=this;let i=0;for(let o=0;o<e;o++){const a=s[o];i+=a[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const s=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const o in s){const a=s[o],c=new Is(a.type);c.itemSize=a.itemSize,c.normalized=a.normalized,i[o]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:s}=this;if(!s[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,s,i){const{groupAttributes:o}=this,c=o[0][t];if(c){if(c.type!==e)for(let r=0,u=o.length;r<u;r++){const l=o[r][t];l.setType(e),l.itemSize=s,l.normalized=i}}else for(let r=0,u=o.length;r<u;r++){const l=new Is(e);l.itemSize=s,l.normalized=i,o[r][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const s in e)e[s].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Es{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:s,ids:i}=this;s[t]||(s[t]=[],i.push(t)),s[t].push(e)}}const Yt=0,Hn=1,oo=2,co=3,ao=4,Ks=5,Js=6,q=new ks,Cs=new ot,k=new G,pt=new C,zs=new Nt,Ls=new Nt,Rs=new Nt,bn=new Nt,Le=new Nt,Re=new Nt,Ns=new J,Tn=new C,Sn=1e-8,lo=1e-15,Et=-1,Ct=1,Fe=-2,Ve=2,fe=0,Mt=1,On=2,uo=1e-14;let De=null;function vs(n){De=n}function Qs(n,t){n.getMidpoint(q.origin),n.getNormal(q.direction);const e=t.raycastFirst(q,Un);return!!(e&&q.direction.dot(e.face.normal)>0)?Et:Ct}function fo(n,t){function e(){return Math.random()-.5}n.getNormal(Tn),q.direction.copy(Tn),n.getMidpoint(q.origin);const s=3;let i=0,o=1/0;for(let a=0;a<s;a++){q.direction.x+=e()*Sn,q.direction.y+=e()*Sn,q.direction.z+=e()*Sn,q.direction.multiplyScalar(-1);const c=t.raycastFirst(q,Un);if(!!(c&&q.direction.dot(c.face.normal)>0)&&i++,c!==null&&(o=Math.min(o,c.distance)),o<=lo)return c.face.normal.dot(Tn)>0?Ve:Fe;if(i/s>.5||(a-i+1)/s>.5)break}return i/s>.5?Et:Ct}function po(n,t){const e=new Es,s=new Es;return Cs.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,Cs,{intersectsTriangles(i,o,a,c){if(!bt(i)&&!bt(o)){let r=i.intersectsTriangle(o,Ns,!0);if(!r){const u=i.plane,l=o.plane,d=u.normal,f=l.normal;d.dot(f)===1&&Math.abs(u.constant-l.constant)<uo&&(r=!0)}if(r){let u=n.geometry.boundsTree.resolveTriangleIndex(a),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(u,l),s.add(l,u),De&&(De.addEdge(Ns),De.addIntersectingTriangles(a,i,c,o))}}return!1}}),{aIntersections:e,bIntersections:s}}function ho(n,t,e,s,i,o,a=!1){const c=e.attributes,r=e.index,u=n*3,l=r.getX(u+0),d=r.getX(u+1),f=r.getX(u+2);for(const h in o){const y=c[h],T=o[h];if(!(h in c))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const w=y.itemSize;h==="position"?(k.a.fromBufferAttribute(y,l).applyMatrix4(s),k.b.fromBufferAttribute(y,d).applyMatrix4(s),k.c.fromBufferAttribute(y,f).applyMatrix4(s),Bn(k.a,k.b,k.c,t,3,T,a)):h==="normal"?(k.a.fromBufferAttribute(y,l).applyNormalMatrix(i),k.b.fromBufferAttribute(y,d).applyNormalMatrix(i),k.c.fromBufferAttribute(y,f).applyNormalMatrix(i),a&&(k.a.multiplyScalar(-1),k.b.multiplyScalar(-1),k.c.multiplyScalar(-1)),Bn(k.a,k.b,k.c,t,3,T,a,!0)):(zs.fromBufferAttribute(y,l),Ls.fromBufferAttribute(y,d),Rs.fromBufferAttribute(y,f),Bn(zs,Ls,Rs,t,w,T,a))}}function yo(n,t,e,s,i,o,a,c=!1){Pn(n,s,i,o,a,c),Pn(c?e:t,s,i,o,a,c),Pn(c?t:e,s,i,o,a,c)}function ti(n,t,e=!1){switch(n){case Yt:if(t===Ct||t===Ve&&!e)return Mt;break;case Hn:if(e){if(t===Et)return fe}else if(t===Ct||t===Fe)return Mt;break;case oo:if(e){if(t===Ct||t===Fe)return Mt}else if(t===Et)return fe;break;case ao:if(t===Et)return fe;if(t===Ct)return Mt;break;case co:if(t===Et||t===Ve&&!e)return Mt;break;case Ks:if(!e&&(t===Ct||t===Fe))return Mt;break;case Js:if(!e&&(t===Et||t===Ve))return Mt;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return On}function Bn(n,t,e,s,i,o,a=!1,c=!1){const r=u=>{o.push(u.x),i>1&&o.push(u.y),i>2&&o.push(u.z),i>3&&o.push(u.w)};bn.set(0,0,0,0).addScaledVector(n,s.a.x).addScaledVector(t,s.a.y).addScaledVector(e,s.a.z),Le.set(0,0,0,0).addScaledVector(n,s.b.x).addScaledVector(t,s.b.y).addScaledVector(e,s.b.z),Re.set(0,0,0,0).addScaledVector(n,s.c.x).addScaledVector(t,s.c.y).addScaledVector(e,s.c.z),c&&(bn.normalize(),Le.normalize(),Re.normalize()),r(bn),a?(r(Re),r(Le)):(r(Le),r(Re))}function Pn(n,t,e,s,i,o=!1){for(const a in i){const c=t[a],r=i[a];if(!(a in t))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const u=c.itemSize;a==="position"?(pt.fromBufferAttribute(c,n).applyMatrix4(e),r.push(pt.x,pt.y,pt.z)):a==="normal"?(pt.fromBufferAttribute(c,n).applyNormalMatrix(s),o&&pt.multiplyScalar(-1),r.push(pt.x,pt.y,pt.z)):(r.push(c.getX(n)),u>1&&r.push(c.getY(n)),u>2&&r.push(c.getZ(n)),u>3&&r.push(c.getW(n)))}}class go{constructor(t){this.triangle=new G().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new G().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const s in e)t.push(e[s]);return t}}class Us{constructor(){this.data={}}addTriangleIntersection(t,e,s,i){const{data:o}=this;o[t]||(o[t]=new go(e)),o[t].addTriangle(s,i)}getTrianglesAsArray(t=null){const{data:e}=this,s=[];if(t!==null)t in e&&s.push(e[t].triangle);else for(const i in e)s.push(e[i].triangle);return s}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(s=>parseInt(s)):[]}getIntersectionsAsArray(t=null,e=null){const{data:s}=this,i=new Set,o=[],a=c=>{if(s[c])if(e!==null)s[c].intersects[e]&&o.push(s[c].intersects[e]);else{const r=s[c].intersects;for(const u in r)i.has(u)||(i.add(u),o.push(r[u]))}};if(t!==null)a(t);else for(const c in s)a(c);return o}reset(){this.data={}}}class mo{constructor(){this.enabled=!1,this.triangleIntersectsA=new Us,this.triangleIntersectsB=new Us,this.intersectionEdges=[]}addIntersectingTriangles(t,e,s,i){const{triangleIntersectsA:o,triangleIntersectsB:a}=this;o.addTriangleIntersection(t,e,s,i),a.addTriangleIntersection(s,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),vs(this))}complete(){this.enabled&&vs(null)}}const St=new ot,$e=new Ti,It=new G,Ne=new G,xt=new G,ve=new G,et=[],Lt=[];function wo(n){for(const t of n)return t}function xo(n,t,e,s,i,o={}){const{useGroups:a=!0}=o,{aIntersections:c,bIntersections:r}=po(n,t),u=[];let l=null,d;return d=a?0:-1,Fs(n,t,c,e,!1,s,i,d),Vs(n,t,c,e,!1,i,d),e.findIndex(h=>h!==Js&&h!==Ks)!==-1&&(d=a?n.geometry.groups.length||1:-1,Fs(t,n,r,e,!0,s,i,d),Vs(t,n,r,e,!0,i,d)),et.length=0,Lt.length=0,{groups:u,materials:l}}function Fs(n,t,e,s,i,o,a,c=0){const r=n.matrixWorld.determinant()<0;St.copy(t.matrixWorld).invert().multiply(n.matrixWorld),$e.getNormalMatrix(n.matrixWorld).multiplyScalar(r?-1:1);const u=n.geometry.groupIndices,l=n.geometry.index,d=n.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,y=t.geometry.attributes.position,T=e.ids,w=e.intersectionSet;for(let p=0,m=T.length;p<m;p++){const g=T[p],A=c===-1?0:u[g]+c,x=3*g,S=l.getX(x+0),b=l.getX(x+1),B=l.getX(x+2);It.a.fromBufferAttribute(d,S).applyMatrix4(St),It.b.fromBufferAttribute(d,b).applyMatrix4(St),It.c.fromBufferAttribute(d,B).applyMatrix4(St),o.reset(),o.initialize(It);const P=w[g];for(let E=0,_=P.length;E<_;E++){const I=3*P[E],z=h.getX(I+0),L=h.getX(I+1),R=h.getX(I+2);Ne.a.fromBufferAttribute(y,z),Ne.b.fromBufferAttribute(y,L),Ne.c.fromBufferAttribute(y,R),o.splitByTriangle(Ne)}const M=o.triangles;for(let E=0,_=M.length;E<_;E++){const I=M[E],z=o.coplanarTriangleUsed?fo(I,f):Qs(I,f);et.length=0,Lt.length=0;for(let L=0,R=s.length;L<R;L++){const D=ti(s[L],z,i);D!==On&&(Lt.push(D),et.push(a[L].getGroupAttrSet(A)))}if(et.length!==0){It.getBarycoord(I.a,ve.a),It.getBarycoord(I.b,ve.b),It.getBarycoord(I.c,ve.c);for(let L=0,R=et.length;L<R;L++){const D=et[L],_t=Lt[L]===fe;ho(g,ve,n.geometry,n.matrixWorld,$e,D,r!==_t)}}}}return T.length}function Vs(n,t,e,s,i,o,a=0){const c=n.matrixWorld.determinant()<0;St.copy(t.matrixWorld).invert().multiply(n.matrixWorld),$e.getNormalMatrix(n.matrixWorld).multiplyScalar(c?-1:1);const r=t.geometry.boundsTree,u=n.geometry.groupIndices,l=n.geometry.index,d=n.geometry.attributes,f=d.position,h=[],y=n.geometry.halfEdges,T=new Set,w=$n(n.geometry);for(let p=0,m=w;p<m;p++)p in e.intersectionSet||T.add(p);for(;T.size>0;){const p=wo(T);T.delete(p),h.push(p);const m=3*p,g=l.getX(m+0),A=l.getX(m+1),x=l.getX(m+2);xt.a.fromBufferAttribute(f,g).applyMatrix4(St),xt.b.fromBufferAttribute(f,A).applyMatrix4(St),xt.c.fromBufferAttribute(f,x).applyMatrix4(St);const S=Qs(xt,r);Lt.length=0,et.length=0;for(let b=0,B=s.length;b<B;b++){const P=ti(s[b],S,i);P!==On&&(Lt.push(P),et.push(o[b]))}for(;h.length>0;){const b=h.pop();for(let B=0;B<3;B++){const P=y.getSiblingTriangleIndex(b,B);P!==-1&&T.has(P)&&(h.push(P),T.delete(P))}if(et.length!==0){const B=3*b,P=l.getX(B+0),M=l.getX(B+1),E=l.getX(B+2),_=a===-1?0:u[b]+a;if(xt.a.fromBufferAttribute(f,P),xt.b.fromBufferAttribute(f,M),xt.c.fromBufferAttribute(f,E),!bt(xt))for(let I=0,z=et.length;I<z;I++){const L=Lt[I],R=et[I].getGroupAttrSet(_),D=L===fe;yo(P,M,E,d,n.matrixWorld,$e,R,D!==c)}}}}}function Ao(n){for(let t=0;t<n.length-1;t++){const e=n[t],s=n[t+1];if(e.materialIndex===s.materialIndex){const i=e.start,o=s.start+s.count;s.start=i,s.count=o-i,n.splice(t,1),t--}}}function bo(n,t,e,s){e.clear();const i=n.attributes;for(let o=0,a=s.length;o<a;o++){const c=s[o],r=i[c];e.initializeArray(c,r.array.constructor,r.itemSize,r.normalized)}for(const o in e.attributes)s.includes(o)||e.delete(o);for(const o in t.attributes)s.includes(o)||(t.deleteAttribute(o),t.dispose())}function To(n,t,e){let s=!1,i=-1;const o=n.attributes,a=t.groupAttributes[0];for(const r in a){const u=t.getTotalLength(r),l=t.getType(r),d=t.getItemSize(r),f=t.getNormalized(r);let h=o[r];(!h||h.array.length<u)&&(h=new Oe(new l(u),d,f),n.setAttribute(r,h),s=!0);let y=0;for(let T=0,w=Math.min(e.length,t.groupCount);T<w;T++){const p=e[T].index,{array:m,type:g,length:A}=t.groupAttributes[p][r],x=new g(m.buffer,0,A);h.array.set(x,y),y+=x.length}h.needsUpdate=!0,i=u/h.itemSize}if(n.index){const r=n.index.array;if(r.length<i)n.index=null,s=!0;else for(let u=0,l=r.length;u<l;u++)r[u]=u}let c=0;n.clearGroups();for(let r=0,u=Math.min(e.length,t.groupCount);r<u;r++){const{index:l,materialIndex:d}=e[r],f=t.getCount(l);f!==0&&(n.addGroup(c,f,d),c+=f)}n.setDrawRange(0,i),n.boundsTree=null,s&&n.dispose()}function Ds(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(s=>{e[s.materialIndex]=t})),e}class ei{constructor(){this.triangleSplitter=new so,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new mo}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,s,i=new ct){let o=!0;if(Array.isArray(s)||(s=[s]),Array.isArray(i)||(i=[i],o=!1),i.length!==s.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:a,attributeData:c,attributes:r,useGroups:u,consolidateGroups:l,debug:d}=this;for(;c.length<i.length;)c.push(new ro);i.forEach((p,m)=>{bo(t.geometry,p.geometry,c[m],r)}),d.init(),xo(t,e,s,a,c,{useGroups:u}),d.complete();const f=this.getGroupRanges(t.geometry),h=Ds(f,t.material),y=this.getGroupRanges(e.geometry),T=Ds(y,e.material);y.forEach(p=>p.materialIndex+=h.length);let w=[...f,...y].map((p,m)=>({...p,index:m}));if(u){const p=[...h,...T];l&&(w=w.map(g=>{const A=p[g.materialIndex];return g.materialIndex=p.indexOf(A),g}).sort((g,A)=>g.materialIndex-A.materialIndex));const m=[];for(let g=0,A=p.length;g<A;g++){let x=!1;for(let S=0,b=w.length;S<b;S++){const B=w[S];B.materialIndex===g&&(x=!0,B.materialIndex=m.length)}x&&m.push(p[g])}i.forEach(g=>{g.material=m})}else w=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(p=>{p.material=h[0]});return i.forEach((p,m)=>{const g=p.geometry;To(g,c[m],w),l&&Ao(g.groups)}),o?i:i[0]}evaluateHierarchy(t,e=new ct){t.updateMatrixWorld(!0);const s=(o,a)=>{const c=o.children;for(let r=0,u=c.length;r<u;r++){const l=c[r];l.isOperationGroup?s(l,a):a(l)}},i=o=>{const a=o.children;let c=!1;for(let u=0,l=a.length;u<l;u++){const d=a[u];c=i(d)||c}const r=o.isDirty();if(r&&o.markUpdated(),c&&!o.isOperationGroup){let u;return s(o,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(o,l,l.operation)}),o._cachedGeometry=u.geometry,o._cachedMaterials=u.material,!0}else return c||r};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const qe=!1,st={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},zt={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},{frameThickness:Gn,frameWidthOuter:ni,frameHeightOuter:si,slatWidth:qt,x:So,y:Bo,frameWidthInner:ii,frameHeightInner:ri}=zt,Kt=new Ge({roughness:1,metalness:0,wireframe:qe,color:34918}),oi=new ct(new He(ni,si,Gn),Kt);oi.updateMatrixWorld();const ci=new ct(new He(ii,ri,Gn),Kt);ci.updateMatrixWorld();const ye=new ei,Po=ye.evaluate(oi,ci,Hn),Wn=new ct(new at(ii,qt*2,qt*2,st.roundSegments,st.roundRadius),Kt);Wn.position.set(0,-2.2,0);Wn.updateMatrixWorld();const Xn=new ct(new at(.6,ri,.6,st.roundSegments,st.roundRadius),Kt);Xn.position.set(0,0,0);Xn.updateMatrixWorld();let pe=ye.evaluate(Wn,Xn,Yt);const qn=new ct(new at(qt,13,qt,st.roundSegments,st.roundRadius),Kt);qn.position.set(-8.2,4.6,0);qn.updateMatrixWorld();pe=ye.evaluate(pe,qn,Yt);const jn=new ct(new at(qt,13,qt,st.roundSegments,st.roundRadius),Kt);jn.position.set(8.2,4.6,0);jn.updateMatrixWorld();pe=ye.evaluate(pe,jn,Yt);const Zn=ye.evaluate(Po,pe,Yt);Zn.position.set(ni/2+So,si/2+Bo,-(st.wallThickness-Gn/2));Zn.updateMatrixWorld();const{floorXLength:lt,floorZLength:ut,wallHeight:gt,wallThickness:N,roundRadius:Jt,roundSegments:Qt,ny:_o}=st,Yn=new Ge({roughness:1,metalness:0,wireframe:qe,transparent:!0,opacity:0}),Mo=new at(lt,N,ut,Qt,Jt),Io=new Ge({roughness:1,metalness:0,wireframe:qe}),je=new jt(Mo,Io);je.position.set(lt/2,-N/2,ut/2);je.receiveShadow=!0;je.castShadow=!0;const Kn=new Ge({roughness:1,metalness:0,wireframe:qe}),Eo=new at(N,gt,ut,Qt,Jt),Ze=new jt(Eo,Kn);Ze.position.set(-N/2,gt/2-N,ut/2);Ze.receiveShadow=!0;Ze.castShadow=!0;const Co=new at(lt+N,gt,N,Qt,Jt),Jn=new ct(Co,Kn);Jn.position.set(lt/2-N/2,gt/2-N,-N/2);Jn.updateMatrixWorld();const zo=new He(zt.frameWidthOuter,zt.frameHeightOuter,N),Qn=new ct(zo,Kn);Qn.position.set(zt.frameWidthOuter/2+zt.x,zt.frameHeightOuter/2+zt.y,-N/2);Qn.updateMatrixWorld();const ai=new ei,li=ai.evaluate(Jn,Qn,Hn);li.updateMatrixWorld();const Ye=ai.evaluate(li,Zn,Yt);Ye.receiveShadow=!0;Ye.castShadow=!0;Ye.updateMatrixWorld();const Lo=new at(lt+N+N,gt,N,Qt,Jt),Ke=new jt(Lo,Yn);Ke.position.set(lt/2,gt/2-N,ut+N/2);Ke.receiveShadow=!0;Ke.castShadow=!0;const Ro=new at(N,gt,ut+N,Qt,Jt),Je=new jt(Ro,Yn);Je.position.set(lt+N/2,gt/2-N,ut/2-N/2);Je.receiveShadow=!0;Je.castShadow=!0;const No=new at(lt+N+N,N,ut+N+N,Qt,Jt),Qe=new jt(No,Yn);Qe.position.set(lt/2,gt-N/2,ut/2);Qe.receiveShadow=!0;Qe.castShadow=!0;const mt=new Si;mt.position.set(-lt/2,-_o,-ut/2);mt.add(je);mt.add(Ze);mt.add(Ye);mt.add(Ke);mt.add(Je);mt.add(Qe);Pt.add(mt);const ts=new Bi(mt);ts.visible=!1;Pt.add(ts);const vo=new Pi,ui=()=>{ss.begin(),nt.clear(),ts.update(),Fn.update();const n=vo.getDelta();tn.animating&&tn.update(n),nt.render(Pt,he),tn.render(nt),ss.end(),requestAnimationFrame(ui)},Uo=new _i("#ffffff",.3);Pt.add(Uo);const O=new Mi("#ffffff",1);O.position.set(20,20,-30);O.castShadow=!0;O.shadow.mapSize.width=1024;O.shadow.mapSize.height=1024;O.shadow.camera.near=1;O.shadow.camera.far=100;O.shadow.camera.top=50;O.shadow.camera.right=50;O.shadow.camera.bottom=-50;O.shadow.camera.left=-50;O.shadow.normalBias=.12;Pt.add(O);const fi=new Ii(O,10);Pt.add(fi);fi.visible=!1;const di=new Ei(O.shadow.camera);Pt.add(di);di.visible=!1;const{floorXLength:Fo,floorZLength:Vo,ny:Do}=st,es=new Ci(42);es.position.set(-Fo/2,-Do,-Vo/2);es.visible=!1;Pt.add(es);ui();zi(de,he,nt);Li.add(Fn,"autoRotate");

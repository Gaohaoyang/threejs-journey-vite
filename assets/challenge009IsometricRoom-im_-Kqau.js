import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as v,aP as kt,n as Ua,j as Fa,m as Da,a4 as Ut,_ as mo,aQ as Pe,X as Ks,U as wo,Q as jn,aR as ja,a0 as yo,a3 as Ys,M as R,P as Ga,W as Ha,aS as Oa,O as Xa,S as Wa,c as qa,J as Ms,V as be,aT as ki,aU as At,aV as rt,ar as Za,v as $t,aq as Et,aW as Ka,Y as Ui,ak as xo,aX as dr,aY as Te,aZ as Ya,s as ue,z as Ke,t as An,R as N,a as st,a_ as Fi,a$ as mt,r as Vn,b0 as Ja,b as bo,d as Qa,b1 as tc,q as ec,b2 as nc,b3 as Ye,p as sc,b4 as ic,o as _s,b5 as Ls,A as oc,G as rc,l as ac}from"./index-Btor9uwS.js";const rn=new v;function pt(n,t,e,s,i,o){const c=2*Math.PI*i/4,a=Math.max(o-2*i,0),r=Math.PI/4;rn.copy(t),rn[s]=0,rn.normalize();const u=.5*c/(c+a),l=1-rn.angleTo(n)/r;return Math.sign(rn[e])===1?l*u:a/(c+a)+u+u*(1-l)}class $ extends kt{constructor(t=1,e=1,s=1,i=2,o=.1){if(i=i*2+1,o=Math.min(t/2,e/2,s/2,o),super(1,1,1,i,i,i),i===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const a=new v,r=new v,u=new v(t,e,s).divideScalar(2).subScalar(o),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,g=new v,A=.5/i;for(let w=0,p=0;w<l.length;w+=3,p+=2)switch(a.fromArray(l,w),r.copy(a),r.x-=Math.sign(r.x)*A,r.y-=Math.sign(r.y)*A,r.z-=Math.sign(r.z)*A,r.normalize(),l[w+0]=u.x*Math.sign(a.x)+r.x*o,l[w+1]=u.y*Math.sign(a.y)+r.y*o,l[w+2]=u.z*Math.sign(a.z)+r.z*o,d[w+0]=r.x,d[w+1]=r.y,d[w+2]=r.z,Math.floor(w/h)){case 0:g.set(1,0,0),f[p+0]=pt(g,r,"z","y",o,s),f[p+1]=1-pt(g,r,"y","z",o,e);break;case 1:g.set(-1,0,0),f[p+0]=1-pt(g,r,"z","y",o,s),f[p+1]=1-pt(g,r,"y","z",o,e);break;case 2:g.set(0,1,0),f[p+0]=1-pt(g,r,"x","z",o,t),f[p+1]=pt(g,r,"z","x",o,s);break;case 3:g.set(0,-1,0),f[p+0]=1-pt(g,r,"x","z",o,t),f[p+1]=1-pt(g,r,"z","x",o,s);break;case 4:g.set(0,0,1),f[p+0]=1-pt(g,r,"x","y",o,t),f[p+1]=1-pt(g,r,"y","x",o,e);break;case 5:g.set(0,0,-1),f[p+0]=pt(g,r,"x","y",o,t),f[p+1]=1-pt(g,r,"y","x",o,e);break}}}const cc=/^[og]\s*(.+)?/,lc=/^mtllib /,uc=/^usemtl /,fc=/^usemap /,Ao=/\s+/,To=new v,Js=new v,So=new v,Bo=new v,ht=new v,Gn=new Ua;function dc(){const n={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(i,o){const c=this._finalize(!1);c&&(c.inherited||c.groupCount<=0)&&this.materials.splice(c.index,1);const a={index:this.materials.length,name:i||"",mtllib:Array.isArray(o)&&o.length>0?o[o.length-1]:"",smooth:c!==void 0?c.smooth:this.smooth,groupStart:c!==void 0?c.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(r){const u={index:typeof r=="number"?r:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return u.clone=this.clone.bind(u),u}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(i){const o=this.currentMaterial();if(o&&o.groupEnd===-1&&(o.groupEnd=this.geometry.vertices.length/3,o.groupCount=o.groupEnd-o.groupStart,o.inherited=!1),i&&this.materials.length>1)for(let c=this.materials.length-1;c>=0;c--)this.materials[c].groupCount<=0&&this.materials.splice(c,1);return i&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),o}},s&&s.name&&typeof s.clone=="function"){const i=s.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const s=parseInt(t,10);return(s>=0?s-1:s+e/3)*3},parseNormalIndex:function(t,e){const s=parseInt(t,10);return(s>=0?s-1:s+e/3)*3},parseUVIndex:function(t,e){const s=parseInt(t,10);return(s>=0?s-1:s+e/2)*2},addVertex:function(t,e,s){const i=this.vertices,o=this.object.geometry.vertices;o.push(i[t+0],i[t+1],i[t+2]),o.push(i[e+0],i[e+1],i[e+2]),o.push(i[s+0],i[s+1],i[s+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,s){const i=this.normals,o=this.object.geometry.normals;o.push(i[t+0],i[t+1],i[t+2]),o.push(i[e+0],i[e+1],i[e+2]),o.push(i[s+0],i[s+1],i[s+2])},addFaceNormal:function(t,e,s){const i=this.vertices,o=this.object.geometry.normals;To.fromArray(i,t),Js.fromArray(i,e),So.fromArray(i,s),ht.subVectors(So,Js),Bo.subVectors(To,Js),ht.cross(Bo),ht.normalize(),o.push(ht.x,ht.y,ht.z),o.push(ht.x,ht.y,ht.z),o.push(ht.x,ht.y,ht.z)},addColor:function(t,e,s){const i=this.colors,o=this.object.geometry.colors;i[t]!==void 0&&o.push(i[t+0],i[t+1],i[t+2]),i[e]!==void 0&&o.push(i[e+0],i[e+1],i[e+2]),i[s]!==void 0&&o.push(i[s+0],i[s+1],i[s+2])},addUV:function(t,e,s){const i=this.uvs,o=this.object.geometry.uvs;o.push(i[t+0],i[t+1]),o.push(i[e+0],i[e+1]),o.push(i[s+0],i[s+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,s,i,o,c,a,r,u){const l=this.vertices.length;let d=this.parseVertexIndex(t,l),f=this.parseVertexIndex(e,l),h=this.parseVertexIndex(s,l);if(this.addVertex(d,f,h),this.addColor(d,f,h),a!==void 0&&a!==""){const g=this.normals.length;d=this.parseNormalIndex(a,g),f=this.parseNormalIndex(r,g),h=this.parseNormalIndex(u,g),this.addNormal(d,f,h)}else this.addFaceNormal(d,f,h);if(i!==void 0&&i!==""){const g=this.uvs.length;d=this.parseUVIndex(i,g),f=this.parseUVIndex(o,g),h=this.parseUVIndex(c,g),this.addUV(d,f,h),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let s=0,i=t.length;s<i;s++){const o=this.parseVertexIndex(t[s],e);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const s=this.vertices.length,i=this.uvs.length;for(let o=0,c=t.length;o<c;o++)this.addVertexLine(this.parseVertexIndex(t[o],s));for(let o=0,c=e.length;o<c;o++)this.addUVLine(this.parseUVIndex(e[o],i))}};return n.startObject("",!1),n}class pr extends Fa{constructor(t){super(t),this.materials=null}load(t,e,s,i){const o=this,c=new Da(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(t,function(a){try{e(o.parse(a))}catch(r){i?i(r):console.error(r),o.manager.itemError(t)}},s,i)}setMaterials(t){return this.materials=t,this}parse(t){const e=new dc;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const s=t.split(`
`);let i=[];for(let a=0,r=s.length;a<r;a++){const u=s[a].trimStart();if(u.length===0)continue;const l=u.charAt(0);if(l!=="#")if(l==="v"){const d=u.split(Ao);switch(d[0]){case"v":e.vertices.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3])),d.length>=7?(Gn.setRGB(parseFloat(d[4]),parseFloat(d[5]),parseFloat(d[6])).convertSRGBToLinear(),e.colors.push(Gn.r,Gn.g,Gn.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3]));break;case"vt":e.uvs.push(parseFloat(d[1]),parseFloat(d[2]));break}}else if(l==="f"){const f=u.slice(1).trim().split(Ao),h=[];for(let A=0,w=f.length;A<w;A++){const p=f[A];if(p.length>0){const m=p.split("/");h.push(m)}}const g=h[0];for(let A=1,w=h.length-1;A<w;A++){const p=h[A],m=h[A+1];e.addFace(g[0],p[0],m[0],g[1],p[1],m[1],g[2],p[2],m[2])}}else if(l==="l"){const d=u.substring(1).trim().split(" ");let f=[];const h=[];if(u.indexOf("/")===-1)f=d;else for(let g=0,A=d.length;g<A;g++){const w=d[g].split("/");w[0]!==""&&f.push(w[0]),w[1]!==""&&h.push(w[1])}e.addLineGeometry(f,h)}else if(l==="p"){const f=u.slice(1).trim().split(" ");e.addPointGeometry(f)}else if((i=cc.exec(u))!==null){const d=(" "+i[0].slice(1).trim()).slice(1);e.startObject(d)}else if(uc.test(u))e.object.startMaterial(u.substring(7).trim(),e.materialLibraries);else if(lc.test(u))e.materialLibraries.push(u.substring(7).trim());else if(fc.test(u))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(l==="s"){if(i=u.split(" "),i.length>1){const f=i[1].trim().toLowerCase();e.object.smooth=f!=="0"&&f!=="off"}else e.object.smooth=!0;const d=e.object.currentMaterial();d&&(d.smooth=e.object.smooth)}else{if(u==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+u+'"')}}e.finalize();const o=new Ut;if(o.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let a=0,r=e.objects.length;a<r;a++){const u=e.objects[a],l=u.geometry,d=u.materials,f=l.type==="Line",h=l.type==="Points";let g=!1;if(l.vertices.length===0)continue;const A=new mo;A.setAttribute("position",new Pe(l.vertices,3)),l.normals.length>0&&A.setAttribute("normal",new Pe(l.normals,3)),l.colors.length>0&&(g=!0,A.setAttribute("color",new Pe(l.colors,3))),l.hasUVIndices===!0&&A.setAttribute("uv",new Pe(l.uvs,2));const w=[];for(let m=0,y=d.length;m<y;m++){const x=d[m],b=x.name+"_"+x.smooth+"_"+g;let S=e.materials[b];if(this.materials!==null){if(S=this.materials.create(x.name),f&&S&&!(S instanceof Ks)){const T=new Ks;wo.prototype.copy.call(T,S),T.color.copy(S.color),S=T}else if(h&&S&&!(S instanceof jn)){const T=new jn({size:10,sizeAttenuation:!1});wo.prototype.copy.call(T,S),T.color.copy(S.color),T.map=S.map,S=T}}S===void 0&&(f?S=new Ks:h?S=new jn({size:1,sizeAttenuation:!1}):S=new ja,S.name=x.name,S.flatShading=!x.smooth,S.vertexColors=g,e.materials[b]=S),w.push(S)}let p;if(w.length>1){for(let m=0,y=d.length;m<y;m++){const x=d[m];A.addGroup(x.groupStart,x.groupCount,m)}f?p=new yo(A,w):h?p=new Ys(A,w):p=new R(A,w)}else f?p=new yo(A,w[0]):h?p=new Ys(A,w[0]):p=new R(A,w[0]);p.name=u.name,o.add(p)}else if(e.vertices.length>0){const a=new jn({size:1,sizeAttenuation:!1}),r=new mo;r.setAttribute("position",new Pe(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(r.setAttribute("color",new Pe(e.colors,3)),a.vertexColors=!0);const u=new Ys(r,a);o.add(u)}return o}}const Vt={width:window.innerWidth,height:window.innerHeight},Ae=new Ga(20,Vt.width/Vt.height,25,800);Vt.width<768?Ae.position.set(200,175,200):Ae.position.set(120,100,120);const hr=document.querySelector("canvas.webgl");if(hr===null)throw new Error("Cannot find the canvas element");const vt=new Ha({canvas:hr,antialias:!0});vt.setSize(Vt.width,Vt.height);vt.setPixelRatio(Math.min(window.devicePixelRatio,2));vt.autoClear=!1;vt.shadowMap.enabled=!0;vt.shadowMap.type=Oa;const Je=new Xa(Ae,vt.domElement);Je.enableDamping=!0;Je.minDistance=30;Je.maxDistance=400;Je.maxPolarAngle=Math.PI/1.98;const z=new Wa,Qs=qa(Ae,vt.domElement),gr=0,pc=1,hc=2,Mo=2,ti=1.25,_o=1,yn=6*4+4+4,Ps=65535,gc=Math.pow(2,-24),ei=Symbol("SKIP_GENERATION");function mc(n){return n.index?n.index.count:n.attributes.position.count}function Qe(n){return mc(n)/3}function wc(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function yc(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=wc(e,s);n.setIndex(new Ms(i,1));for(let o=0;o<e;o++)i[o]=o}}function mr(n){const t=Qe(n),e=n.drawRange,s=e.start/3,i=(e.start+e.count)/3,o=Math.max(0,s),c=Math.min(t,i)-o;return[{offset:Math.floor(o),count:Math.floor(c)}]}function wr(n){if(!n.groups||!n.groups.length)return mr(n);const t=[],e=new Set,s=n.drawRange,i=s.start/3,o=(s.start+s.count)/3;for(const a of n.groups){const r=a.start/3,u=(a.start+a.count)/3;e.add(Math.max(i,r)),e.add(Math.min(o,u))}const c=Array.from(e.values()).sort((a,r)=>a-r);for(let a=0;a<c.length-1;a++){const r=c[a],u=c[a+1];t.push({offset:Math.floor(r),count:Math.floor(u-r)})}return t}function xc(n){if(n.groups.length===0)return!1;const t=Qe(n),e=wr(n).sort((o,c)=>o.offset-c.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let i=0;return e.forEach(({count:o})=>i+=o),t!==i}function ni(n,t,e,s,i){let o=1/0,c=1/0,a=1/0,r=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,g=-1/0,A=-1/0,w=-1/0;for(let p=t*6,m=(t+e)*6;p<m;p+=6){const y=n[p+0],x=n[p+1],b=y-x,S=y+x;b<o&&(o=b),S>r&&(r=S),y<d&&(d=y),y>g&&(g=y);const T=n[p+2],B=n[p+3],M=T-B,L=T+B;M<c&&(c=M),L>u&&(u=L),T<f&&(f=T),T>A&&(A=T);const I=n[p+4],_=n[p+5],P=I-_,E=I+_;P<a&&(a=P),E>l&&(l=E),I<h&&(h=I),I>w&&(w=I)}s[0]=o,s[1]=c,s[2]=a,s[3]=r,s[4]=u,s[5]=l,i[0]=d,i[1]=f,i[2]=h,i[3]=g,i[4]=A,i[5]=w}function bc(n,t=null,e=null,s=null){const i=n.attributes.position,o=n.index?n.index.array:null,c=Qe(n),a=i.normalized;let r;t===null?(r=new Float32Array(c*6*4),e=0,s=c):(r=t,e=e||0,s=s||c);const u=i.array,l=i.offset||0;let d=3;i.isInterleavedBufferAttribute&&(d=i.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+s;h++){const g=h*3,A=h*6;let w=g+0,p=g+1,m=g+2;o&&(w=o[w],p=o[p],m=o[m]),a||(w=w*d+l,p=p*d+l,m=m*d+l);for(let y=0;y<3;y++){let x,b,S;a?(x=i[f[y]](w),b=i[f[y]](p),S=i[f[y]](m)):(x=u[w+y],b=u[p+y],S=u[m+y]);let T=x;b<T&&(T=b),S<T&&(T=S);let B=x;b>B&&(B=b),S>B&&(B=S);const M=(B-T)/2,L=y*2;r[A+L+0]=T+M,r[A+L+1]=M+(Math.abs(T)+M)*gc}}return r}function j(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Lo(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function Po(n,t){t.set(n)}function Io(n,t,e){let s,i;for(let o=0;o<3;o++){const c=o+3;s=n[o],i=t[o],e[o]=s<i?s:i,s=n[c],i=t[c],e[c]=s>i?s:i}}function Hn(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],o=t[n+2*s+1],c=i-o,a=i+o;c<e[s]&&(e[s]=c),a>e[s+3]&&(e[s+3]=a)}}function an(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const Ht=32,Ac=(n,t)=>n.candidate-t.candidate,ee=new Array(Ht).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),On=new Float32Array(6);function Tc(n,t,e,s,i,o){let c=-1,a=0;if(o===gr)c=Lo(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(o===pc)c=Lo(n),c!==-1&&(a=Sc(e,s,i,c));else if(o===hc){const r=an(n);let u=ti*i;const l=s*6,d=(s+i)*6;for(let f=0;f<3;f++){const h=t[f],w=(t[f+3]-h)/Ht;if(i<Ht/4){const p=[...ee];p.length=i;let m=0;for(let x=l;x<d;x+=6,m++){const b=p[m];b.candidate=e[x+2*f],b.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:B}=b;for(let M=0;M<3;M++)B[M]=1/0,B[M+3]=-1/0,T[M]=1/0,T[M+3]=-1/0,S[M]=1/0,S[M+3]=-1/0;Hn(x,e,S)}p.sort(Ac);let y=i;for(let x=0;x<y;x++){const b=p[x];for(;x+1<y&&p[x+1].candidate===b.candidate;)p.splice(x+1,1),y--}for(let x=l;x<d;x+=6){const b=e[x+2*f];for(let S=0;S<y;S++){const T=p[S];b>=T.candidate?Hn(x,e,T.rightCacheBounds):(Hn(x,e,T.leftCacheBounds),T.count++)}}for(let x=0;x<y;x++){const b=p[x],S=b.count,T=i-b.count,B=b.leftCacheBounds,M=b.rightCacheBounds;let L=0;S!==0&&(L=an(B)/r);let I=0;T!==0&&(I=an(M)/r);const _=_o+ti*(L*S+I*T);_<u&&(c=f,u=_,a=b.candidate)}}else{for(let y=0;y<Ht;y++){const x=ee[y];x.count=0,x.candidate=h+w+y*w;const b=x.bounds;for(let S=0;S<3;S++)b[S]=1/0,b[S+3]=-1/0}for(let y=l;y<d;y+=6){let S=~~((e[y+2*f]-h)/w);S>=Ht&&(S=Ht-1);const T=ee[S];T.count++,Hn(y,e,T.bounds)}const p=ee[Ht-1];Po(p.bounds,p.rightCacheBounds);for(let y=Ht-2;y>=0;y--){const x=ee[y],b=ee[y+1];Io(x.bounds,b.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let y=0;y<Ht-1;y++){const x=ee[y],b=x.count,S=x.bounds,B=ee[y+1].rightCacheBounds;b!==0&&(m===0?Po(S,On):Io(S,On,On)),m+=b;let M=0,L=0;m!==0&&(M=an(On)/r);const I=i-m;I!==0&&(L=an(B)/r);const _=_o+ti*(M*m+L*I);_<u&&(c=f,u=_,a=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:c,pos:a}}function Sc(n,t,e,s){let i=0;for(let o=t,c=t+e;o<c;o++)i+=n[o*6+s*2];return i/e}class si{constructor(){this.boundingData=new Float32Array(6)}}function Bc(n,t,e,s,i,o){let c=s,a=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;c<=a&&e[c*6+u]<r;)c++;for(;c<=a&&e[a*6+u]>=r;)a--;if(c<a){for(let l=0;l<3;l++){let d=t[c*3+l];t[c*3+l]=t[a*3+l],t[a*3+l]=d}for(let l=0;l<6;l++){let d=e[c*6+l];e[c*6+l]=e[a*6+l],e[a*6+l]=d}c++,a--}else return c}}function Mc(n,t,e,s,i,o){let c=s,a=s+i-1;const r=o.pos,u=o.axis*2;for(;;){for(;c<=a&&e[c*6+u]<r;)c++;for(;c<=a&&e[a*6+u]>=r;)a--;if(c<a){let l=n[c];n[c]=n[a],n[a]=l;for(let d=0;d<6;d++){let f=e[c*6+d];e[c*6+d]=e[a*6+d],e[a*6+d]=f}c++,a--}else return c}}function nt(n,t){return t[n+15]===65535}function at(n,t){return t[n+6]}function wt(n,t){return t[n+14]}function yt(n){return n+8}function xt(n,t){return t[n+6]}function yr(n,t){return t[n+7]}let xr,wn,us,br;const _c=Math.pow(2,32);function Li(n){return"count"in n?1:1+Li(n.left)+Li(n.right)}function Lc(n,t,e){return xr=new Float32Array(e),wn=new Uint32Array(e),us=new Uint16Array(e),br=new Uint8Array(e),Pi(n,t)}function Pi(n,t){const e=n/4,s=n/2,i="count"in t,o=t.boundingData;for(let c=0;c<6;c++)xr[e+c]=o[c];if(i)if(t.buffer){const c=t.buffer;br.set(new Uint8Array(c),n);for(let a=n,r=n+c.byteLength;a<r;a+=yn){const u=a/2;nt(u,us)||(wn[a/4+6]+=e)}return n+c.byteLength}else{const c=t.offset,a=t.count;return wn[e+6]=c,us[s+14]=a,us[s+15]=Ps,n+yn}else{const c=t.left,a=t.right,r=t.splitAxis;let u;if(u=Pi(n+yn,c),u/4>_c)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return wn[e+6]=u/4,u=Pi(u,a),wn[e+7]=r,u}}function Pc(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),c=s?new Uint32Array(o):new Uint16Array(o);for(let a=0,r=c.length;a<r;a++)c[a]=a;return c}function Ic(n,t,e,s,i){const{maxDepth:o,verbose:c,maxLeafTris:a,strategy:r,onProgress:u,indirect:l}=i,d=n._indirectBuffer,f=n.geometry,h=f.index?f.index.array:null,g=l?Mc:Bc,A=Qe(f),w=new Float32Array(6);let p=!1;const m=new si;return ni(t,e,s,m.boundingData,w),x(m,e,s,w),m;function y(b){u&&u(b/A)}function x(b,S,T,B=null,M=0){if(!p&&M>=o&&(p=!0,c&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),T<=a||M>=o)return y(S+T),b.offset=S,b.count=T,b;const L=Tc(b.boundingData,B,t,S,T,r);if(L.axis===-1)return y(S+T),b.offset=S,b.count=T,b;const I=g(d,h,t,S,T,L);if(I===S||I===S+T)y(S+T),b.offset=S,b.count=T;else{b.splitAxis=L.axis;const _=new si,P=S,E=I-S;b.left=_,ni(t,P,E,_.boundingData,w),x(_,P,E,w,M+1);const C=new si,k=I,K=T-E;b.right=C,ni(t,k,K,C.boundingData,w),x(C,k,K,w,M+1)}return b}}function vc(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=Pc(e,t.useSharedArrayBuffer),xc(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||yc(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=bc(e),o=t.indirect?mr(e):wr(e);n._roots=o.map(c=>{const a=Ic(n,i,c.offset,c.count,t),r=Li(a),u=new s(yn*r);return Lc(0,a,u),u})}class Ot{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let o=0,c=t.length;o<c;o++){const r=t[o][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let o=0,c=e.length;o<c;o++){const a=e[o],r=t.dot(a);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}Ot.prototype.setFromBox=function(){const n=new v;return function(e,s){const i=s.min,o=s.max;let c=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){n.x=i.x*r+o.x*(1-r),n.y=i.y*u+o.y*(1-u),n.z=i.z*l+o.z*(1-l);const d=e.dot(n);c=Math.min(d,c),a=Math.max(d,a)}this.min=c,this.max=a}}();const Ec=function(){const n=new v,t=new v,e=new v;return function(i,o,c){const a=i.start,r=n,u=o.start,l=t;e.subVectors(a,u),n.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const d=e.dot(l),f=l.dot(r),h=l.dot(l),g=e.dot(r),w=r.dot(r)*h-f*f;let p,m;w!==0?p=(d*f-g*h)/w:p=0,m=(d+p*f)/h,c.x=p,c.y=m}}(),Di=function(){const n=new be,t=new v,e=new v;return function(i,o,c,a){Ec(i,o,n);let r=n.x,u=n.y;if(r>=0&&r<=1&&u>=0&&u<=1){i.at(r,c),o.at(u,a);return}else if(r>=0&&r<=1){u<0?o.at(0,a):o.at(1,a),i.closestPointToPoint(a,!0,c);return}else if(u>=0&&u<=1){r<0?i.at(0,c):i.at(1,c),o.closestPointToPoint(c,!0,a);return}else{let l;r<0?l=i.start:l=i.end;let d;u<0?d=o.start:d=o.end;const f=t,h=e;if(i.closestPointToPoint(d,!0,t),o.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=h.distanceToSquared(l)){c.copy(f),a.copy(d);return}else{c.copy(l),a.copy(h);return}}}}(),Cc=function(){const n=new v,t=new v,e=new ki,s=new At;return function(o,c){const{radius:a,center:r}=o,{a:u,b:l,c:d}=c;if(s.start=u,s.end=l,s.closestPointToPoint(r,!0,n).distanceTo(r)<=a||(s.start=u,s.end=d,s.closestPointToPoint(r,!0,n).distanceTo(r)<=a)||(s.start=l,s.end=d,s.closestPointToPoint(r,!0,n).distanceTo(r)<=a))return!0;const A=c.getPlane(e);if(Math.abs(A.distanceToPoint(r))<=a){const p=A.projectPoint(r,t);if(c.containsPoint(p))return!0}return!1}}(),zc=1e-15;function ii(n){return Math.abs(n)<zc}class Tt extends rt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new v),this.satBounds=new Array(4).fill().map(()=>new Ot),this.points=[this.a,this.b,this.c],this.sphere=new Za,this.plane=new ki,this.needsUpdate=!0}intersectsSphere(t){return Cc(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,o=this.satAxes,c=this.satBounds,a=o[0],r=c[0];this.getNormal(a),r.setFromPoints(a,i);const u=o[1],l=c[1];u.subVectors(t,e),l.setFromPoints(u,i);const d=o[2],f=c[2];d.subVectors(e,s),f.setFromPoints(d,i);const h=o[3],g=c[3];h.subVectors(s,t),g.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}Tt.prototype.closestPointToSegment=function(){const n=new v,t=new v,e=new At;return function(i,o=null,c=null){const{start:a,end:r}=i,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),Di(e,i,n,t),l=n.distanceToSquared(t),l<d&&(d=l,o&&o.copy(n),c&&c.copy(t))}return this.closestPointToPoint(a,n),l=a.distanceToSquared(n),l<d&&(d=l,o&&o.copy(n),c&&c.copy(a)),this.closestPointToPoint(r,n),l=r.distanceToSquared(n),l<d&&(d=l,o&&o.copy(n),c&&c.copy(r)),Math.sqrt(d)}}();Tt.prototype.intersectsTriangle=function(){const n=new Tt,t=new Array(3),e=new Array(3),s=new Ot,i=new Ot,o=new v,c=new v,a=new v,r=new v,u=new v,l=new At,d=new At,f=new At,h=new v;function g(A,w,p){const m=A.points;let y=0,x=-1;for(let b=0;b<3;b++){const{start:S,end:T}=l;S.copy(m[b]),T.copy(m[(b+1)%3]),l.delta(c);const B=ii(w.distanceToPoint(S));if(ii(w.normal.dot(c))&&B){p.copy(l),y=2;break}const M=w.intersectLine(l,h);if(!M&&B&&h.copy(S),(M||B)&&!ii(h.distanceTo(T))){if(y<=1)(y===1?p.start:p.end).copy(h),B&&(x=y);else if(y>=2){(x===1?p.start:p.end).copy(h),y=2;break}if(y++,y===2&&x===-1)break}}return y}return function(w,p=null,m=!1){this.needsUpdate&&this.update(),w.isExtendedTriangle?w.needsUpdate&&w.update():(n.copy(w),n.update(),w=n);const y=this.plane,x=w.plane;if(Math.abs(y.normal.dot(x.normal))>1-1e-10){const b=this.satBounds,S=this.satAxes;e[0]=w.a,e[1]=w.b,e[2]=w.c;for(let M=0;M<4;M++){const L=b[M],I=S[M];if(s.setFromPoints(I,e),L.isSeparated(s))return!1}const T=w.satBounds,B=w.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let M=0;M<4;M++){const L=T[M],I=B[M];if(s.setFromPoints(I,t),L.isSeparated(s))return!1}for(let M=0;M<4;M++){const L=S[M];for(let I=0;I<4;I++){const _=B[I];if(o.crossVectors(L,_),s.setFromPoints(o,t),i.setFromPoints(o,e),s.isSeparated(i))return!1}}return p&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const b=g(this,x,d);if(b===1&&w.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(b!==2)return!1;const S=g(w,y,f);if(S===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(S!==2)return!1;if(d.delta(a),f.delta(r),a.dot(r)<0){let P=f.start;f.start=f.end,f.end=P}const T=d.start.dot(a),B=d.end.dot(a),M=f.start.dot(a),L=f.end.dot(a),I=B<M,_=T<L;return T!==L&&M!==B&&I===_?!1:(p&&(u.subVectors(d.start,f.start),u.dot(a)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();Tt.prototype.distanceToPoint=function(){const n=new v;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();Tt.prototype.distanceToTriangle=function(){const n=new v,t=new v,e=["a","b","c"],s=new At,i=new At;return function(c,a=null,r=null){const u=a||r?s:null;if(this.intersectsTriangle(c,u))return(a||r)&&(a&&u.getCenter(a),r&&u.getCenter(r)),0;let l=1/0;for(let d=0;d<3;d++){let f;const h=e[d],g=c[h];this.closestPointToPoint(g,n),f=g.distanceToSquared(n),f<l&&(l=f,a&&a.copy(n),r&&r.copy(g));const A=this[h];c.closestPointToPoint(A,n),f=A.distanceToSquared(n),f<l&&(l=f,a&&a.copy(A),r&&r.copy(n))}for(let d=0;d<3;d++){const f=e[d],h=e[(d+1)%3];s.set(this[f],this[h]);for(let g=0;g<3;g++){const A=e[g],w=e[(g+1)%3];i.set(c[A],c[w]),Di(s,i,n,t);const p=n.distanceToSquared(t);p<l&&(l=p,a&&a.copy(n),r&&r.copy(t))}}return Math.sqrt(l)}}();class Q{constructor(t,e,s){this.isOrientedBox=!0,this.min=new v,this.max=new v,this.matrix=new $t,this.invMatrix=new $t,this.points=new Array(8).fill().map(()=>new v),this.satAxes=new Array(3).fill().map(()=>new v),this.satBounds=new Array(3).fill().map(()=>new Ot),this.alignedSatBounds=new Array(3).fill().map(()=>new Ot),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,h=i[f];h.x=u?s.x:e.x,h.y=l?s.y:e.y,h.z=d?s.z:e.z,h.applyMatrix4(t)}const o=this.satBounds,c=this.satAxes,a=i[0];for(let u=0;u<3;u++){const l=c[u],d=o[u],f=1<<u,h=i[f];l.subVectors(a,h),d.setFromPoints(l,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Q.prototype.intersectsBox=function(){const n=new Ot;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,o=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,a[0].isSeparated(n)||(n.min=s.y,n.max=i.y,a[1].isSeparated(n))||(n.min=s.z,n.max=i.z,a[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const u=c[r],l=o[r];if(n.setFromBox(u,e),l.isSeparated(n))return!1}return!0}}();Q.prototype.intersectsTriangle=function(){const n=new Tt,t=new Array(3),e=new Ot,s=new Ot,i=new v;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(n.copy(c),n.update(),c=n);const a=this.satBounds,r=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let f=0;f<3;f++){const h=a[f],g=r[f];if(e.setFromPoints(g,t),h.isSeparated(e))return!1}const u=c.satBounds,l=c.satAxes,d=this.points;for(let f=0;f<3;f++){const h=u[f],g=l[f];if(e.setFromPoints(g,d),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=r[f];for(let g=0;g<4;g++){const A=l[g];if(i.crossVectors(h,A),e.setFromPoints(i,t),s.setFromPoints(i,d),e.isSeparated(s))return!1}}return!0}}();Q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();Q.prototype.distanceToPoint=function(){const n=new v;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();Q.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new At),e=new Array(12).fill().map(()=>new At),s=new v,i=new v;return function(c,a=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(r||u)&&(c.getCenter(i),this.closestPointToPoint(i,s),c.closestPointToPoint(s,i),r&&r.copy(s),u&&u.copy(i)),0;const l=a*a,d=c.min,f=c.max,h=this.points;let g=1/0;for(let w=0;w<8;w++){const p=h[w];i.copy(p).clamp(d,f);const m=p.distanceToSquared(i);if(m<g&&(g=m,r&&r.copy(p),u&&u.copy(i),m<l))return Math.sqrt(m)}let A=0;for(let w=0;w<3;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){const y=(w+1)%3,x=(w+2)%3,b=p<<y|m<<x,S=1<<w|p<<y|m<<x,T=h[b],B=h[S];t[A].set(T,B);const L=n[w],I=n[y],_=n[x],P=e[A],E=P.start,C=P.end;E[L]=d[L],E[I]=p?d[I]:f[I],E[_]=m?d[_]:f[I],C[L]=f[L],C[I]=p?d[I]:f[I],C[_]=m?d[_]:f[I],A++}for(let w=0;w<=1;w++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){i.x=w?f.x:d.x,i.y=p?f.y:d.y,i.z=m?f.z:d.z,this.closestPointToPoint(i,s);const y=i.distanceToSquared(s);if(y<g&&(g=y,r&&r.copy(s),u&&u.copy(i),y<l))return Math.sqrt(y)}for(let w=0;w<12;w++){const p=t[w];for(let m=0;m<12;m++){const y=e[m];Di(p,y,s,i);const x=s.distanceToSquared(i);if(x<g&&(g=x,r&&r.copy(s),u&&u.copy(i),x<l))return Math.sqrt(x)}}return Math.sqrt(g)}}();class ji{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Rc extends ji{constructor(){super(()=>new Tt)}}const bt=new Rc;class $c{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const F=new $c;let re,Ue;const Ie=[],Xn=new ji(()=>new Et);function Vc(n,t,e,s,i,o){re=Xn.getPrimitive(),Ue=Xn.getPrimitive(),Ie.push(re,Ue),F.setBuffer(n._roots[t]);const c=Ii(0,n.geometry,e,s,i,o);F.clearBuffer(),Xn.releasePrimitive(re),Xn.releasePrimitive(Ue),Ie.pop(),Ie.pop();const a=Ie.length;return a>0&&(Ue=Ie[a-1],re=Ie[a-2]),c}function Ii(n,t,e,s,i=null,o=0,c=0){const{float32Array:a,uint16Array:r,uint32Array:u}=F;let l=n*2;if(nt(l,r)){const f=at(n,u),h=wt(l,r);return j(n,a,re),s(f,h,!1,c,o+n,re)}else{let L=function(_){const{uint16Array:P,uint32Array:E}=F;let C=_*2;for(;!nt(C,P);)_=yt(_),C=_*2;return at(_,E)},I=function(_){const{uint16Array:P,uint32Array:E}=F;let C=_*2;for(;!nt(C,P);)_=xt(_,E),C=_*2;return at(_,E)+wt(C,P)};const f=yt(n),h=xt(n,u);let g=f,A=h,w,p,m,y;if(i&&(m=re,y=Ue,j(g,a,m),j(A,a,y),w=i(m),p=i(y),p<w)){g=h,A=f;const _=w;w=p,p=_,m=y}m||(m=re,j(g,a,m));const x=nt(g*2,r),b=e(m,x,w,c+1,o+g);let S;if(b===Mo){const _=L(g),E=I(g)-_;S=s(_,E,!0,c+1,o+g,m)}else S=b&&Ii(g,t,e,s,i,o,c+1);if(S)return!0;y=Ue,j(A,a,y);const T=nt(A*2,r),B=e(y,T,p,c+1,o+A);let M;if(B===Mo){const _=L(A),E=I(A)-_;M=s(_,E,!0,c+1,o+A,y)}else M=B&&Ii(A,t,e,s,i,o,c+1);return!!M}}const cn=new v,oi=new v;function Nc(n,t,e={},s=0,i=1/0){const o=s*s,c=i*i;let a=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(cn.copy(t).clamp(l.min,l.max),cn.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<a&&f<c,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,cn);const f=t.distanceToSquared(cn);return f<a&&(oi.copy(cn),a=f,r=d),f<o}}),a===1/0)return null;const u=Math.sqrt(a);return e.point?e.point.copy(oi):e.point=oi.clone(),e.distance=u,e.faceIndex=r,e}const ve=new v,Ee=new v,Ce=new v,Wn=new be,qn=new be,Zn=new be,vo=new v,Eo=new v,Co=new v,Kn=new v;function kc(n,t,e,s,i,o){let c;return o===Ka?c=n.intersectTriangle(s,e,t,!0,i):c=n.intersectTriangle(t,e,s,o!==Ui,i),c===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function Uc(n,t,e,s,i,o,c,a,r){ve.fromBufferAttribute(t,o),Ee.fromBufferAttribute(t,c),Ce.fromBufferAttribute(t,a);const u=kc(n,ve,Ee,Ce,Kn,r);if(u){s&&(Wn.fromBufferAttribute(s,o),qn.fromBufferAttribute(s,c),Zn.fromBufferAttribute(s,a),u.uv=rt.getInterpolation(Kn,ve,Ee,Ce,Wn,qn,Zn,new be)),i&&(Wn.fromBufferAttribute(i,o),qn.fromBufferAttribute(i,c),Zn.fromBufferAttribute(i,a),u.uv1=rt.getInterpolation(Kn,ve,Ee,Ce,Wn,qn,Zn,new be)),e&&(vo.fromBufferAttribute(e,o),Eo.fromBufferAttribute(e,c),Co.fromBufferAttribute(e,a),u.normal=rt.getInterpolation(Kn,ve,Ee,Ce,vo,Eo,Co,new v),u.normal.dot(n.direction)>0&&u.normal.multiplyScalar(-1));const l={a:o,b:c,c:a,normal:new v,materialIndex:0};rt.getNormal(ve,Ee,Ce,l.normal),u.face=l,u.faceIndex=o}return u}function Is(n,t,e,s,i){const o=s*3;let c=o+0,a=o+1,r=o+2;const u=n.index;n.index&&(c=u.getX(c),a=u.getX(a),r=u.getX(r));const{position:l,normal:d,uv:f,uv1:h}=n.attributes,g=Uc(e,l,d,f,h,c,a,r,t);return g?(g.faceIndex=s,i&&i.push(g),g):null}function H(n,t,e,s){const i=n.a,o=n.b,c=n.c;let a=t,r=t+1,u=t+2;e&&(a=e.getX(a),r=e.getX(r),u=e.getX(u)),i.x=s.getX(a),i.y=s.getY(a),i.z=s.getZ(a),o.x=s.getX(r),o.y=s.getY(r),o.z=s.getZ(r),c.x=s.getX(u),c.y=s.getY(u),c.z=s.getZ(u)}function Fc(n,t,e,s,i,o){const{geometry:c,_indirectBuffer:a}=n;for(let r=s,u=s+i;r<u;r++)Is(c,t,e,r,o)}function Dc(n,t,e,s,i){const{geometry:o,_indirectBuffer:c}=n;let a=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let d;d=Is(o,t,e,u),d&&d.distance<a&&(r=d,a=d.distance)}return r}function jc(n,t,e,s,i,o,c){const{geometry:a}=e,{index:r}=a,u=a.attributes.position;for(let l=n,d=t+n;l<d;l++){let f;if(f=l,H(c,f*3,r,u),c.needsUpdate=!0,s(c,f,i,o))return!0}return!1}function Gc(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,c,a,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,h,g=!1){const A=f*2;if(a[A+15]===Ps){const p=c[f+6],m=a[A+14];let y=1/0,x=1/0,b=1/0,S=-1/0,T=-1/0,B=-1/0;for(let M=3*p,L=3*(p+m);M<L;M++){let I=s[M];const _=i.getX(I),P=i.getY(I),E=i.getZ(I);_<y&&(y=_),_>S&&(S=_),P<x&&(x=P),P>T&&(T=P),E<b&&(b=E),E>B&&(B=E)}return r[f+0]!==y||r[f+1]!==x||r[f+2]!==b||r[f+3]!==S||r[f+4]!==T||r[f+5]!==B?(r[f+0]=y,r[f+1]=x,r[f+2]=b,r[f+3]=S,r[f+4]=T,r[f+5]=B,!0):!1}else{const p=f+8,m=c[f+6],y=p+h,x=m+h;let b=g,S=!1,T=!1;t?b||(S=t.has(y),T=t.has(x),b=!S&&!T):(S=!0,T=!0);const B=b||S,M=b||T;let L=!1;B&&(L=d(p,h,b));let I=!1;M&&(I=d(m,h,b));const _=L||I;if(_)for(let P=0;P<3;P++){const E=p+P,C=m+P,k=r[E],K=r[E+3],Le=r[C],pe=r[C+3];r[f+P]=k<Le?k:Le,r[f+P+3]=K>pe?K:pe}return _}}}const zo=new Et;function le(n,t,e,s){return j(n,t,zo),e.intersectBox(zo,s)}function Hc(n,t,e,s,i,o){const{geometry:c,_indirectBuffer:a}=n;for(let r=s,u=s+i;r<u;r++){let l=a?a[r]:r;Is(c,t,e,l,o)}}function Oc(n,t,e,s,i){const{geometry:o,_indirectBuffer:c}=n;let a=1/0,r=null;for(let u=s,l=s+i;u<l;u++){let d;d=Is(o,t,e,c?c[u]:u),d&&d.distance<a&&(r=d,a=d.distance)}return r}function Xc(n,t,e,s,i,o,c){const{geometry:a}=e,{index:r}=a,u=a.attributes.position;for(let l=n,d=t+n;l<d;l++){let f;if(f=e.resolveTriangleIndex(l),H(c,f*3,r,u),c.needsUpdate=!0,s(c,f,i,o))return!0}return!1}const Ro=new v;function Wc(n,t,e,s,i){F.setBuffer(n._roots[t]),vi(0,n,e,s,i),F.clearBuffer()}function vi(n,t,e,s,i){const{float32Array:o,uint16Array:c,uint32Array:a}=F,r=n*2;if(nt(r,c)){const l=at(n,a),d=wt(r,c);Fc(t,e,s,l,d,i)}else{const l=yt(n);le(l,o,s,Ro)&&vi(l,t,e,s,i);const d=xt(n,a);le(d,o,s,Ro)&&vi(d,t,e,s,i)}}const $o=new v,qc=["x","y","z"];function Zc(n,t,e,s){F.setBuffer(n._roots[t]);const i=Ei(0,n,e,s);return F.clearBuffer(),i}function Ei(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:c}=F;let a=n*2;if(nt(a,o)){const u=at(n,c),l=wt(a,o);return Dc(t,e,s,u,l)}else{const u=yr(n,c),l=qc[u],f=s.direction[l]>=0;let h,g;f?(h=yt(n),g=xt(n,c)):(h=xt(n,c),g=yt(n));const w=le(h,i,s,$o)?Ei(h,t,e,s):null;if(w){const y=w.point[l];if(f?y<=i[g+u]:y>=i[g+u+3])return w}const m=le(g,i,s,$o)?Ei(g,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const Yn=new Et,ze=new Tt,Re=new Tt,ln=new $t,Vo=new Q,Jn=new Q;function Kc(n,t,e,s){F.setBuffer(n._roots[t]);const i=Ci(0,n,e,s);return F.clearBuffer(),i}function Ci(n,t,e,s,i=null){const{float32Array:o,uint16Array:c,uint32Array:a}=F;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Vo.set(e.boundingBox.min,e.boundingBox.max,s),i=Vo),nt(r,c)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,g=e.attributes.position,A=at(n,a),w=wt(r,c);if(ln.copy(s).invert(),e.boundsTree)return j(n,o,Jn),Jn.matrix.copy(ln),Jn.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>Jn.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let y=A*3,x=(w+A)*3;y<x;y+=3)if(H(Re,y,d,f),Re.needsUpdate=!0,m.intersectsTriangle(Re))return!0;return!1}});for(let p=A*3,m=(w+A)*3;p<m;p+=3){H(ze,p,d,f),ze.a.applyMatrix4(ln),ze.b.applyMatrix4(ln),ze.c.applyMatrix4(ln),ze.needsUpdate=!0;for(let y=0,x=h.count;y<x;y+=3)if(H(Re,y,h,g),Re.needsUpdate=!0,ze.intersectsTriangle(Re))return!0}}else{const l=n+8,d=a[n+6];return j(l,o,Yn),!!(i.intersectsBox(Yn)&&Ci(l,t,e,s,i)||(j(d,o,Yn),i.intersectsBox(Yn)&&Ci(d,t,e,s,i)))}}const Qn=new $t,ri=new Q,un=new Q,Yc=new v,Jc=new v,Qc=new v,tl=new v;function el(n,t,e,s={},i={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),ri.set(t.boundingBox.min,t.boundingBox.max,e),ri.needsUpdate=!0;const a=n.geometry,r=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=bt.getPrimitive(),h=bt.getPrimitive();let g=Yc,A=Jc,w=null,p=null;i&&(w=Qc,p=tl);let m=1/0,y=null,x=null;return Qn.copy(e).invert(),un.matrix.copy(Qn),n.shapecast({boundsTraverseOrder:b=>ri.distanceToBox(b),intersectsBounds:(b,S,T)=>T<m&&T<c?(S&&(un.min.copy(b.min),un.max.copy(b.max),un.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>un.distanceToBox(B),intersectsBounds:(B,M,L)=>L<m&&L<c,intersectsRange:(B,M)=>{for(let L=B,I=B+M;L<I;L++){H(h,3*L,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let _=b,P=b+S;_<P;_++){H(f,3*_,u,r),f.needsUpdate=!0;const E=f.distanceToTriangle(h,g,w);if(E<m&&(A.copy(g),p&&p.copy(w),m=E,y=_,x=L),E<o)return!0}}}});{const T=Qe(t);for(let B=0,M=T;B<M;B++){H(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let L=b,I=b+S;L<I;L++){H(f,3*L,u,r),f.needsUpdate=!0;const _=f.distanceToTriangle(h,g,w);if(_<m&&(A.copy(g),p&&p.copy(w),m=_,y=L,x=B),_<o)return!0}}}}}),bt.releasePrimitive(f),bt.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=m,s.faceIndex=y,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Qn),A.applyMatrix4(Qn),i.distance=A.sub(i.point).length(),i.faceIndex=x),s)}function nl(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,c,a,r,u=0;const l=n._roots;for(let f=0,h=l.length;f<h;f++)o=l[f],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,h,g=!1){const A=f*2;if(a[A+15]===Ps){const p=c[f+6],m=a[A+14];let y=1/0,x=1/0,b=1/0,S=-1/0,T=-1/0,B=-1/0;for(let M=p,L=p+m;M<L;M++){const I=3*n.resolveTriangleIndex(M);for(let _=0;_<3;_++){let P=I+_;P=s?s[P]:P;const E=i.getX(P),C=i.getY(P),k=i.getZ(P);E<y&&(y=E),E>S&&(S=E),C<x&&(x=C),C>T&&(T=C),k<b&&(b=k),k>B&&(B=k)}}return r[f+0]!==y||r[f+1]!==x||r[f+2]!==b||r[f+3]!==S||r[f+4]!==T||r[f+5]!==B?(r[f+0]=y,r[f+1]=x,r[f+2]=b,r[f+3]=S,r[f+4]=T,r[f+5]=B,!0):!1}else{const p=f+8,m=c[f+6],y=p+h,x=m+h;let b=g,S=!1,T=!1;t?b||(S=t.has(y),T=t.has(x),b=!S&&!T):(S=!0,T=!0);const B=b||S,M=b||T;let L=!1;B&&(L=d(p,h,b));let I=!1;M&&(I=d(m,h,b));const _=L||I;if(_)for(let P=0;P<3;P++){const E=p+P,C=m+P,k=r[E],K=r[E+3],Le=r[C],pe=r[C+3];r[f+P]=k<Le?k:Le,r[f+P+3]=K>pe?K:pe}return _}}}const No=new v;function sl(n,t,e,s,i){F.setBuffer(n._roots[t]),zi(0,n,e,s,i),F.clearBuffer()}function zi(n,t,e,s,i){const{float32Array:o,uint16Array:c,uint32Array:a}=F,r=n*2;if(nt(r,c)){const l=at(n,a),d=wt(r,c);Hc(t,e,s,l,d,i)}else{const l=yt(n);le(l,o,s,No)&&zi(l,t,e,s,i);const d=xt(n,a);le(d,o,s,No)&&zi(d,t,e,s,i)}}const ko=new v,il=["x","y","z"];function ol(n,t,e,s){F.setBuffer(n._roots[t]);const i=Ri(0,n,e,s);return F.clearBuffer(),i}function Ri(n,t,e,s){const{float32Array:i,uint16Array:o,uint32Array:c}=F;let a=n*2;if(nt(a,o)){const u=at(n,c),l=wt(a,o);return Oc(t,e,s,u,l)}else{const u=yr(n,c),l=il[u],f=s.direction[l]>=0;let h,g;f?(h=yt(n),g=xt(n,c)):(h=xt(n,c),g=yt(n));const w=le(h,i,s,ko)?Ri(h,t,e,s):null;if(w){const y=w.point[l];if(f?y<=i[g+u]:y>=i[g+u+3])return w}const m=le(g,i,s,ko)?Ri(g,t,e,s):null;return w&&m?w.distance<=m.distance?w:m:w||m||null}}const ts=new Et,$e=new Tt,Ve=new Tt,fn=new $t,Uo=new Q,es=new Q;function rl(n,t,e,s){F.setBuffer(n._roots[t]);const i=$i(0,n,e,s);return F.clearBuffer(),i}function $i(n,t,e,s,i=null){const{float32Array:o,uint16Array:c,uint32Array:a}=F;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Uo.set(e.boundingBox.min,e.boundingBox.max,s),i=Uo),nt(r,c)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,g=e.attributes.position,A=at(n,a),w=wt(r,c);if(fn.copy(s).invert(),e.boundsTree)return j(n,o,es),es.matrix.copy(fn),es.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:m=>es.intersectsBox(m),intersectsTriangle:m=>{m.a.applyMatrix4(s),m.b.applyMatrix4(s),m.c.applyMatrix4(s),m.needsUpdate=!0;for(let y=A,x=w+A;y<x;y++)if(H(Ve,3*t.resolveTriangleIndex(y),d,f),Ve.needsUpdate=!0,m.intersectsTriangle(Ve))return!0;return!1}});for(let p=A,m=w+A;p<m;p++){const y=t.resolveTriangleIndex(p);H($e,3*y,d,f),$e.a.applyMatrix4(fn),$e.b.applyMatrix4(fn),$e.c.applyMatrix4(fn),$e.needsUpdate=!0;for(let x=0,b=h.count;x<b;x+=3)if(H(Ve,x,h,g),Ve.needsUpdate=!0,$e.intersectsTriangle(Ve))return!0}}else{const l=n+8,d=a[n+6];return j(l,o,ts),!!(i.intersectsBox(ts)&&$i(l,t,e,s,i)||(j(d,o,ts),i.intersectsBox(ts)&&$i(d,t,e,s,i)))}}const ns=new $t,ai=new Q,dn=new Q,al=new v,cl=new v,ll=new v,ul=new v;function fl(n,t,e,s={},i={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),ai.set(t.boundingBox.min,t.boundingBox.max,e),ai.needsUpdate=!0;const a=n.geometry,r=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=bt.getPrimitive(),h=bt.getPrimitive();let g=al,A=cl,w=null,p=null;i&&(w=ll,p=ul);let m=1/0,y=null,x=null;return ns.copy(e).invert(),dn.matrix.copy(ns),n.shapecast({boundsTraverseOrder:b=>ai.distanceToBox(b),intersectsBounds:(b,S,T)=>T<m&&T<c?(S&&(dn.min.copy(b.min),dn.max.copy(b.max),dn.needsUpdate=!0),!0):!1,intersectsRange:(b,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:B=>dn.distanceToBox(B),intersectsBounds:(B,M,L)=>L<m&&L<c,intersectsRange:(B,M)=>{for(let L=B,I=B+M;L<I;L++){const _=T.resolveTriangleIndex(L);H(h,3*_,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let P=b,E=b+S;P<E;P++){const C=n.resolveTriangleIndex(P);H(f,3*C,u,r),f.needsUpdate=!0;const k=f.distanceToTriangle(h,g,w);if(k<m&&(A.copy(g),p&&p.copy(w),m=k,y=P,x=L),k<o)return!0}}}})}else{const T=Qe(t);for(let B=0,M=T;B<M;B++){H(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let L=b,I=b+S;L<I;L++){const _=n.resolveTriangleIndex(L);H(f,3*_,u,r),f.needsUpdate=!0;const P=f.distanceToTriangle(h,g,w);if(P<m&&(A.copy(g),p&&p.copy(w),m=P,y=L,x=B),P<o)return!0}}}}}),bt.releasePrimitive(f),bt.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(A):s.point=A.clone(),s.distance=m,s.faceIndex=y,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(ns),A.applyMatrix4(ns),i.distance=A.sub(i.point).length(),i.faceIndex=x),s)}function dl(){return typeof SharedArrayBuffer<"u"}const xn=new F.constructor,ms=new F.constructor,se=new ji(()=>new Et),Ne=new Et,ke=new Et,ci=new Et,li=new Et;let ui=!1;function pl(n,t,e,s){if(ui)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");ui=!0;const i=n._roots,o=t._roots;let c,a=0,r=0;const u=new $t().copy(e).invert();for(let l=0,d=i.length;l<d;l++){xn.setBuffer(i[l]),r=0;const f=se.getPrimitive();j(0,xn.float32Array,f),f.applyMatrix4(u);for(let h=0,g=o.length;h<g&&(ms.setBuffer(o[l]),c=Pt(0,0,e,u,s,a,r,0,0,f),ms.clearBuffer(),r+=o[h].length,!c);h++);if(se.releasePrimitive(f),xn.clearBuffer(),a+=i[l].length,c)break}return ui=!1,c}function Pt(n,t,e,s,i,o=0,c=0,a=0,r=0,u=null,l=!1){let d,f;l?(d=ms,f=xn):(d=xn,f=ms);const h=d.float32Array,g=d.uint32Array,A=d.uint16Array,w=f.float32Array,p=f.uint32Array,m=f.uint16Array,y=n*2,x=t*2,b=nt(y,A),S=nt(x,m);let T=!1;if(S&&b)l?T=i(at(t,p),wt(t*2,m),at(n,g),wt(n*2,A),r,c+t,a,o+n):T=i(at(n,g),wt(n*2,A),at(t,p),wt(t*2,m),a,o+n,r,c+t);else if(S){const B=se.getPrimitive();j(t,w,B),B.applyMatrix4(e);const M=yt(n),L=xt(n,g);j(M,h,Ne),j(L,h,ke);const I=B.intersectsBox(Ne),_=B.intersectsBox(ke);T=I&&Pt(t,M,s,e,i,c,o,r,a+1,B,!l)||_&&Pt(t,L,s,e,i,c,o,r,a+1,B,!l),se.releasePrimitive(B)}else{const B=yt(t),M=xt(t,p);j(B,w,ci),j(M,w,li);const L=u.intersectsBox(ci),I=u.intersectsBox(li);if(L&&I)T=Pt(n,B,e,s,i,o,c,a,r+1,u,l)||Pt(n,M,e,s,i,o,c,a,r+1,u,l);else if(L)if(b)T=Pt(n,B,e,s,i,o,c,a,r+1,u,l);else{const _=se.getPrimitive();_.copy(ci).applyMatrix4(e);const P=yt(n),E=xt(n,g);j(P,h,Ne),j(E,h,ke);const C=_.intersectsBox(Ne),k=_.intersectsBox(ke);T=C&&Pt(B,P,s,e,i,c,o,r,a+1,_,!l)||k&&Pt(B,E,s,e,i,c,o,r,a+1,_,!l),se.releasePrimitive(_)}else if(I)if(b)T=Pt(n,M,e,s,i,o,c,a,r+1,u,l);else{const _=se.getPrimitive();_.copy(li).applyMatrix4(e);const P=yt(n),E=xt(n,g);j(P,h,Ne),j(E,h,ke);const C=_.intersectsBox(Ne),k=_.intersectsBox(ke);T=C&&Pt(M,P,s,e,i,c,o,r,a+1,_,!l)||k&&Pt(M,E,s,e,i,c,o,r,a+1,_,!l),se.releasePrimitive(_)}}return T}const ss=new Q,Fo=new Et,hl={strategy:gr,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Gi{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,o=t._indirectBuffer,c=s.getIndex();let a;return e.cloneBuffers?a={roots:i.map(r=>r.slice()),index:c.array.slice(),indirectBuffer:o?o.slice():null}:a={roots:i,index:c.array,indirectBuffer:o},a}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:o,indirectBuffer:c}=t,a=new Gi(e,{...s,[ei]:!0});if(a._roots=o,a._indirectBuffer=c||null,s.setIndex){const r=e.getIndex();if(r===null){const u=new Ms(t.index,1,!1);e.setIndex(u)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...hl,[ei]:!1},e),e.useSharedArrayBuffer&&!dl())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[ei]||(vc(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Et)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?i=>s[i]:i=>i}refit(t=null){return(this.indirect?nl:Gc)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),o=new Uint16Array(s);c(0);function c(a,r=0){const u=a*2,l=o[u+15]===Ps;if(l){const d=i[a+6],f=o[u+14];t(r,l,new Float32Array(s,a*4,6),d,f)}else{const d=a+yn/4,f=i[a+6],h=i[a+7];t(r,l,new Float32Array(s,a*4,6),h)||(c(d,r+1),c(f,r+1))}}}raycast(t,e=xo){const s=this._roots,i=this.geometry,o=[],c=e.isMaterial,a=Array.isArray(e),r=i.groups,u=c?e.side:e,l=this.indirect?sl:Wc;for(let d=0,f=s.length;d<f;d++){const h=a?e[r[d].materialIndex].side:u,g=o.length;if(l(this,d,h,t,o),a){const A=r[d].materialIndex;for(let w=g,p=o.length;w<p;w++)o[w].face.materialIndex=A}}return o}raycastFirst(t,e=xo){const s=this._roots,i=this.geometry,o=e.isMaterial,c=Array.isArray(e);let a=null;const r=i.groups,u=o?e.side:e,l=this.indirect?ol:Zc;for(let d=0,f=s.length;d<f;d++){const h=c?e[r[d].materialIndex].side:u,g=l(this,d,h,t);g!=null&&(a==null||g.distance<a.distance)&&(a=g,c&&(g.face.materialIndex=r[d].materialIndex))}return a}intersectsGeometry(t,e){let s=!1;const i=this._roots,o=this.indirect?rl:Kc;for(let c=0,a=i.length;c<a&&(s=o(this,c,t,e),!s);c++);return s}shapecast(t){const e=bt.getPrimitive(),s=this.indirect?Xc:jc;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:c,intersectsTriangle:a}=t;if(c&&a){const d=c;c=(f,h,g,A,w)=>d(f,h,g,A,w)?!0:s(f,h,this,a,g,A,e)}else c||(a?c=(d,f,h,g)=>s(d,f,this,a,h,g,e):c=(d,f,h)=>h);let r=!1,u=0;const l=this._roots;for(let d=0,f=l.length;d<f;d++){const h=l[d];if(r=Vc(this,d,o,c,i,u),r)break;u+=h.byteLength}return bt.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const c=bt.getPrimitive(),a=this.geometry.index,r=this.geometry.attributes.position,u=this.indirect?g=>{const A=this.resolveTriangleIndex(g);H(c,A*3,a,r)}:g=>{H(c,g*3,a,r)},l=bt.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?g=>{const A=t.resolveTriangleIndex(g);H(l,A*3,d,f)}:g=>{H(l,g*3,d,f)};if(o){const g=(A,w,p,m,y,x,b,S)=>{for(let T=p,B=p+m;T<B;T++){h(T),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let M=A,L=A+w;M<L;M++)if(u(M),c.needsUpdate=!0,o(c,l,M,T,y,x,b,S))return!0}return!1};if(i){const A=i;i=function(w,p,m,y,x,b,S,T){return A(w,p,m,y,x,b,S,T)?!0:g(w,p,m,y,x,b,S,T)}}else i=g}return pl(this,t,e,i)}intersectsBox(t,e){return ss.set(t.min,t.max,e),ss.needsUpdate=!0,this.shapecast({intersectsBounds:s=>ss.intersectsBox(s),intersectsTriangle:s=>ss.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},o=0,c=1/0){return(this.indirect?fl:el)(this,t,e,s,i,o,c)}closestPointToPoint(t,e={},s=0,i=1/0){return Nc(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{j(0,new Float32Array(s),Fo),t.union(Fo)}),t}}const Ar=1e-6,gl=Ar*.5,Tr=Math.pow(10,-Math.log10(Ar)),ml=gl*Tr;function Rt(n){return~~(n*Tr+ml)}function wl(n){return`${Rt(n.x)},${Rt(n.y)}`}function Do(n){return`${Rt(n.x)},${Rt(n.y)},${Rt(n.z)}`}function yl(n){return`${Rt(n.x)},${Rt(n.y)},${Rt(n.z)},${Rt(n.w)}`}function xl(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}function Sr(){return typeof SharedArrayBuffer<"u"}function bl(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,s=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(s).set(i,0),new t(s)}function Al(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Tl(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Al(e,s);n.setIndex(new Ms(i,1));for(let o=0;o<e;o++)i[o]=o}}function Sl(n){return n.index?n.index.count:n.attributes.position.count}function Hi(n){return Sl(n)/3}const Bl=1e-8,Ml=new v;function _l(n){return~~(n/3)}function Ll(n){return n%3}function jo(n,t){return n.start-t.start}function Go(n,t){return Ml.subVectors(t,n.origin).dot(n.direction)}function Pl(n,t,e,s=Bl){n.sort(jo),t.sort(jo);for(let a=0;a<n.length;a++){const r=n[a];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)o(l.end,r.end)||n.splice(a+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)o(r.end,l.end)||t.splice(u+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const d=r.end;r.end=l.start,l.start=d}else if(r.start>=l.start&&r.end>=l.end){const d=l.end;l.end=r.start,r.start=d}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),c(l)&&(t.splice(u,1),u--),c(r)){n.splice(a,1),a--;break}}}i(n),i(t);function i(a){for(let r=0;r<a.length;r++)c(a[r])&&(a.splice(r,1),r--)}function o(a,r){return Math.abs(r-a)<s}function c(a){return Math.abs(a.end-a.start)<s}}const Ho=1e-5,Oo=1e-4;class Il{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,o=null;for(let r=0,u=e.length;r<u;r++){const l=e[r];if(c(l,t)&&c(l,s))continue;const d=a(l,t),f=a(l,s),h=Math.min(d,f);h<i&&(i=h,o=l)}return o;function c(r,u){const l=r.origin.distanceTo(u.origin)>Ho;return r.direction.angleTo(u.direction)>Oo||l}function a(r,u){const l=r.origin.distanceTo(u.origin),d=r.direction.angleTo(u.direction);return l/Ho+d/Oo}}}const fi=new v,di=new v,is=new dr;function vl(n,t,e){const s=n.attributes,i=n.index,o=s.position,c=new Map,a=new Map,r=Array.from(t),u=new Il;for(let l=0,d=r.length;l<d;l++){const f=r[l],h=_l(f),g=Ll(f);let A=3*h+g,w=3*h+(g+1)%3;i&&(A=i.getX(A),w=i.getX(w)),fi.fromBufferAttribute(o,A),di.fromBufferAttribute(o,w),xl(fi,di,is);let p,m=u.findClosestRay(is);m===null&&(m=is.clone(),u.addRay(m)),a.has(m)||a.set(m,{forward:[],reverse:[],ray:m}),p=a.get(m);let y=Go(m,fi),x=Go(m,di);y>x&&([y,x]=[x,y]),is.direction.dot(m.direction)<0?p.reverse.push({start:y,end:x,index:f}):p.forward.push({start:y,end:x,index:f})}return a.forEach(({forward:l,reverse:d},f)=>{Pl(l,d,c,e),l.length===0&&d.length===0&&a.delete(f)}),{disjointConnectivityMap:c,fragmentMap:a}}const El=new be,pi=new v,Cl=new Te,hi=["","",""];class zl{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>~~(o/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>o%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:o}=this,c=e?y:m,a=new Map,{attributes:r}=t,u=e?Object.keys(r):null,l=t.index,d=r.position;let f=Hi(t);const h=f;let g=0;s&&(g=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let A=this.data;(!A||A.length<3*h)&&(A=new Int32Array(3*h)),A.fill(-1);let w=0,p=new Set;for(let x=g,b=f*3+g;x<b;x+=3){const S=x;for(let T=0;T<3;T++){let B=S+T;l&&(B=l.getX(B)),hi[T]=c(B)}for(let T=0;T<3;T++){const B=(T+1)%3,M=hi[T],L=hi[B],I=`${L}_${M}`;if(a.has(I)){const _=S+T,P=a.get(I);A[_]=P,A[P]=_,a.delete(I),w+=2,p.delete(P)}else{const _=`${M}_${L}`,P=S+T;a.set(_,P),p.add(P)}}}if(i){const{fragmentMap:x,disjointConnectivityMap:b}=vl(t,p,o);p.clear(),x.forEach(({forward:S,reverse:T})=>{S.forEach(({index:B})=>p.add(B)),T.forEach(({index:B})=>p.add(B))}),this.unmatchedDisjointEdges=x,this.disjointConnections=b,w=f*3-p.size}this.matchedEdges=w,this.unmatchedEdges=p.size,this.data=A;function m(x){return pi.fromBufferAttribute(d,x),Do(pi)}function y(x){let b="";for(let S=0,T=u.length;S<T;S++){const B=r[u[S]];let M;switch(B.itemSize){case 1:M=Rt(B.getX(x));break;case 2:M=wl(El.fromBufferAttribute(B,x));break;case 3:M=Do(pi.fromBufferAttribute(B,x));break;case 4:M=yl(Cl.fromBufferAttribute(B,x));break}b!==""&&(b+="|"),b+=M}return b}}}class ct extends R{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new $t,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let o=0;o<16;o++)if(s[o]!==i[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=Sr();if(s)for(const i in e){const o=e[i];if(o.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");o.array=bl(o.array)}if(t.boundsTree||(Tl(t,{useSharedArrayBuffer:s}),t.boundsTree=new Gi(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new zl(t)),!t.groupIndices){const i=Hi(t),o=new Uint16Array(i),c=t.groups;for(let a=0,r=c.length;a<r;a++){const{start:u,count:l}=c[a];for(let d=u/3,f=(u+l)/3;d<f;d++)o[d]=a}t.groupIndices=o}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Rl=1e-14,gi=new v,Xo=new v,Wo=new v;function oe(n,t=Rl){gi.subVectors(n.b,n.a),Xo.subVectors(n.c,n.a),Wo.subVectors(n.b,n.c);const e=gi.angleTo(Xo),s=gi.angleTo(Wo),i=Math.PI-e-s;return Math.abs(e)<t||Math.abs(s)<t||Math.abs(i)<t||n.a.distanceToSquared(n.b)<t||n.a.distanceToSquared(n.c)<t||n.b.distanceToSquared(n.c)<t}const mi=1e-10,pn=1e-10,$l=1e-10,Dt=new At,G=new At,jt=new v,wi=new v,qo=new v,os=new ki,yi=new Tt;class Vl{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new rt),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class Nl{constructor(){this.trianglePool=new Vl,this.triangles=[],this.normal=new v,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:s,normal:i}=this;if(Array.isArray(t))for(let o=0,c=t.length;o<c;o++){const a=t[o];if(o===0)a.getNormal(i);else if(Math.abs(1-a.getNormal(jt).dot(i))>mi)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const r=s.getTriangle();r.copy(a),e.push(r)}else{t.getNormal(i);const o=s.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:s}=this;if(t.getNormal(wi).normalize(),Math.abs(1-Math.abs(wi.dot(e)))<$l){this.coplanarTriangleUsed=!0;for(let o=0,c=s.length;o<c;o++){const a=s[o];a.coplanarCount=0}const i=[t.a,t.b,t.c];for(let o=0;o<3;o++){const c=(o+1)%3,a=i[o],r=i[c];jt.subVectors(r,a).normalize(),qo.crossVectors(wi,jt),os.setFromNormalAndCoplanarPoint(qo,a),this.splitByPlane(os,t)}}else t.getPlane(os),this.splitByPlane(os,t)}splitByPlane(t,e){const{triangles:s,trianglePool:i}=this;yi.copy(e),yi.needsUpdate=!0;for(let o=0,c=s.length;o<c;o++){const a=s[o];if(!yi.intersectsTriangle(a,Dt,!0))continue;const{a:r,b:u,c:l}=a;let d=0,f=-1,h=!1,g=[],A=[];const w=[r,u,l];for(let p=0;p<3;p++){const m=(p+1)%3;Dt.start.copy(w[p]),Dt.end.copy(w[m]);const y=t.distanceToPoint(Dt.start),x=t.distanceToPoint(Dt.end);if(Math.abs(y)<pn&&Math.abs(x)<pn){h=!0;break}if(y>0?g.push(p):A.push(p),Math.abs(y)<pn)continue;let b=!!t.intersectLine(Dt,jt);!b&&Math.abs(x)<pn&&(jt.copy(Dt.end),b=!0),b&&!(jt.distanceTo(Dt.start)<mi)&&(jt.distanceTo(Dt.end)<mi&&(f=p),d===0?G.start.copy(jt):G.end.copy(jt),d++)}if(!h&&d===2&&G.distance()>pn)if(f!==-1){f=(f+1)%3;let p=0;p===f&&(p=(p+1)%3);let m=p+1;m===f&&(m=(m+1)%3);const y=i.getTriangle();y.a.copy(w[m]),y.b.copy(G.end),y.c.copy(G.start),oe(y)||s.push(y),a.a.copy(w[p]),a.b.copy(G.start),a.c.copy(G.end),oe(a)&&(s.splice(o,1),o--,c--)}else{const p=g.length>=2?A[0]:g[0];if(p===0){let S=G.start;G.start=G.end,G.end=S}const m=(p+1)%3,y=(p+2)%3,x=i.getTriangle(),b=i.getTriangle();w[m].distanceToSquared(G.start)<w[y].distanceToSquared(G.end)?(x.a.copy(w[m]),x.b.copy(G.start),x.c.copy(G.end),b.a.copy(w[m]),b.b.copy(w[y]),b.c.copy(G.start)):(x.a.copy(w[y]),x.b.copy(G.start),x.c.copy(G.end),b.a.copy(w[m]),b.b.copy(w[y]),b.c.copy(G.end)),a.a.copy(w[p]),a.b.copy(G.end),a.c.copy(G.start),oe(x)||s.push(x),oe(b)||s.push(b),oe(a)&&(s.splice(o,1),o--,c--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function kl(n){return n=~~n,n+4-n%4}class Zo{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,s=Sr()?SharedArrayBuffer:ArrayBuffer,i=new e(new s(kl(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:s}=this;s+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,o=t.length;i<o;i++)e[s+i]=t[i];this.length+=t.length}clear(){this.length=0}}class Ul{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:s}=this;let i=0;for(let o=0;o<e;o++){const c=s[o];i+=c[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const s=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const o in s){const c=s[o],a=new Zo(c.type);a.itemSize=c.itemSize,a.normalized=c.normalized,i[o]=a}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:s}=this;if(!s[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,s,i){const{groupAttributes:o}=this,a=o[0][t];if(a){if(a.type!==e)for(let r=0,u=o.length;r<u;r++){const l=o[r][t];l.setType(e),l.itemSize=s,l.normalized=i}}else for(let r=0,u=o.length;r<u;r++){const l=new Zo(e);l.itemSize=s,l.normalized=i,o[r][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const s in e)e[s].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Ko{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:s,ids:i}=this;s[t]||(s[t]=[],i.push(t)),s[t].push(e)}}const Xt=0,Oi=1,Fl=2,Dl=3,jl=4,Br=5,Mr=6,gt=new dr,Yo=new $t,Y=new rt,Gt=new v,Jo=new Te,Qo=new Te,tr=new Te,xi=new Te,rs=new Te,as=new Te,er=new At,bi=new v,Ai=1e-8,Gl=1e-15,me=-1,we=1,fs=-2,ds=2,bn=0,he=1,Xi=2,Hl=1e-14;let ps=null;function nr(n){ps=n}function _r(n,t){n.getMidpoint(gt.origin),n.getNormal(gt.direction);const e=t.raycastFirst(gt,Ui);return!!(e&&gt.direction.dot(e.face.normal)>0)?me:we}function Ol(n,t){function e(){return Math.random()-.5}n.getNormal(bi),gt.direction.copy(bi),n.getMidpoint(gt.origin);const s=3;let i=0,o=1/0;for(let c=0;c<s;c++){gt.direction.x+=e()*Ai,gt.direction.y+=e()*Ai,gt.direction.z+=e()*Ai,gt.direction.multiplyScalar(-1);const a=t.raycastFirst(gt,Ui);if(!!(a&&gt.direction.dot(a.face.normal)>0)&&i++,a!==null&&(o=Math.min(o,a.distance)),o<=Gl)return a.face.normal.dot(bi)>0?ds:fs;if(i/s>.5||(c-i+1)/s>.5)break}return i/s>.5?me:we}function Xl(n,t){const e=new Ko,s=new Ko;return Yo.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,Yo,{intersectsTriangles(i,o,c,a){if(!oe(i)&&!oe(o)){let r=i.intersectsTriangle(o,er,!0);if(!r){const u=i.plane,l=o.plane,d=u.normal,f=l.normal;d.dot(f)===1&&Math.abs(u.constant-l.constant)<Hl&&(r=!0)}if(r){let u=n.geometry.boundsTree.resolveTriangleIndex(c),l=t.geometry.boundsTree.resolveTriangleIndex(a);e.add(u,l),s.add(l,u),ps&&(ps.addEdge(er),ps.addIntersectingTriangles(c,i,a,o))}}return!1}}),{aIntersections:e,bIntersections:s}}function Wl(n,t,e,s,i,o,c=!1){const a=e.attributes,r=e.index,u=n*3,l=r.getX(u+0),d=r.getX(u+1),f=r.getX(u+2);for(const h in o){const g=a[h],A=o[h];if(!(h in a))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const w=g.itemSize;h==="position"?(Y.a.fromBufferAttribute(g,l).applyMatrix4(s),Y.b.fromBufferAttribute(g,d).applyMatrix4(s),Y.c.fromBufferAttribute(g,f).applyMatrix4(s),Ti(Y.a,Y.b,Y.c,t,3,A,c)):h==="normal"?(Y.a.fromBufferAttribute(g,l).applyNormalMatrix(i),Y.b.fromBufferAttribute(g,d).applyNormalMatrix(i),Y.c.fromBufferAttribute(g,f).applyNormalMatrix(i),c&&(Y.a.multiplyScalar(-1),Y.b.multiplyScalar(-1),Y.c.multiplyScalar(-1)),Ti(Y.a,Y.b,Y.c,t,3,A,c,!0)):(Jo.fromBufferAttribute(g,l),Qo.fromBufferAttribute(g,d),tr.fromBufferAttribute(g,f),Ti(Jo,Qo,tr,t,w,A,c))}}function ql(n,t,e,s,i,o,c,a=!1){Si(n,s,i,o,c,a),Si(a?e:t,s,i,o,c,a),Si(a?t:e,s,i,o,c,a)}function Lr(n,t,e=!1){switch(n){case Xt:if(t===we||t===ds&&!e)return he;break;case Oi:if(e){if(t===me)return bn}else if(t===we||t===fs)return he;break;case Fl:if(e){if(t===we||t===fs)return he}else if(t===me)return bn;break;case jl:if(t===me)return bn;if(t===we)return he;break;case Dl:if(t===me||t===ds&&!e)return he;break;case Br:if(!e&&(t===we||t===fs))return he;break;case Mr:if(!e&&(t===me||t===ds))return he;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return Xi}function Ti(n,t,e,s,i,o,c=!1,a=!1){const r=u=>{o.push(u.x),i>1&&o.push(u.y),i>2&&o.push(u.z),i>3&&o.push(u.w)};xi.set(0,0,0,0).addScaledVector(n,s.a.x).addScaledVector(t,s.a.y).addScaledVector(e,s.a.z),rs.set(0,0,0,0).addScaledVector(n,s.b.x).addScaledVector(t,s.b.y).addScaledVector(e,s.b.z),as.set(0,0,0,0).addScaledVector(n,s.c.x).addScaledVector(t,s.c.y).addScaledVector(e,s.c.z),a&&(xi.normalize(),rs.normalize(),as.normalize()),r(xi),c?(r(as),r(rs)):(r(rs),r(as))}function Si(n,t,e,s,i,o=!1){for(const c in i){const a=t[c],r=i[c];if(!(c in t))throw new Error(`CSG Operations: Attribute ${c} no available on geometry.`);const u=a.itemSize;c==="position"?(Gt.fromBufferAttribute(a,n).applyMatrix4(e),r.push(Gt.x,Gt.y,Gt.z)):c==="normal"?(Gt.fromBufferAttribute(a,n).applyNormalMatrix(s),o&&Gt.multiplyScalar(-1),r.push(Gt.x,Gt.y,Gt.z)):(r.push(a.getX(n)),u>1&&r.push(a.getY(n)),u>2&&r.push(a.getZ(n)),u>3&&r.push(a.getW(n)))}}class Zl{constructor(t){this.triangle=new rt().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new rt().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const s in e)t.push(e[s]);return t}}class sr{constructor(){this.data={}}addTriangleIntersection(t,e,s,i){const{data:o}=this;o[t]||(o[t]=new Zl(e)),o[t].addTriangle(s,i)}getTrianglesAsArray(t=null){const{data:e}=this,s=[];if(t!==null)t in e&&s.push(e[t].triangle);else for(const i in e)s.push(e[i].triangle);return s}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(s=>parseInt(s)):[]}getIntersectionsAsArray(t=null,e=null){const{data:s}=this,i=new Set,o=[],c=a=>{if(s[a])if(e!==null)s[a].intersects[e]&&o.push(s[a].intersects[e]);else{const r=s[a].intersects;for(const u in r)i.has(u)||(i.add(u),o.push(r[u]))}};if(t!==null)c(t);else for(const a in s)c(a);return o}reset(){this.data={}}}class Kl{constructor(){this.enabled=!1,this.triangleIntersectsA=new sr,this.triangleIntersectsB=new sr,this.intersectionEdges=[]}addIntersectingTriangles(t,e,s,i){const{triangleIntersectsA:o,triangleIntersectsB:c}=this;o.addTriangleIntersection(t,e,s,i),c.addTriangleIntersection(s,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),nr(this))}complete(){this.enabled&&nr(null)}}const ae=new $t,ws=new Ya,ge=new rt,cs=new rt,ne=new rt,ls=new rt,It=[],xe=[];function Yl(n){for(const t of n)return t}function Jl(n,t,e,s,i,o={}){const{useGroups:c=!0}=o,{aIntersections:a,bIntersections:r}=Xl(n,t),u=[];let l=null,d;return d=c?0:-1,ir(n,t,a,e,!1,s,i,d),or(n,t,a,e,!1,i,d),e.findIndex(h=>h!==Mr&&h!==Br)!==-1&&(d=c?n.geometry.groups.length||1:-1,ir(t,n,r,e,!0,s,i,d),or(t,n,r,e,!0,i,d)),It.length=0,xe.length=0,{groups:u,materials:l}}function ir(n,t,e,s,i,o,c,a=0){const r=n.matrixWorld.determinant()<0;ae.copy(t.matrixWorld).invert().multiply(n.matrixWorld),ws.getNormalMatrix(n.matrixWorld).multiplyScalar(r?-1:1);const u=n.geometry.groupIndices,l=n.geometry.index,d=n.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,g=t.geometry.attributes.position,A=e.ids,w=e.intersectionSet;for(let p=0,m=A.length;p<m;p++){const y=A[p],x=a===-1?0:u[y]+a,b=3*y,S=l.getX(b+0),T=l.getX(b+1),B=l.getX(b+2);ge.a.fromBufferAttribute(d,S).applyMatrix4(ae),ge.b.fromBufferAttribute(d,T).applyMatrix4(ae),ge.c.fromBufferAttribute(d,B).applyMatrix4(ae),o.reset(),o.initialize(ge);const M=w[y];for(let I=0,_=M.length;I<_;I++){const P=3*M[I],E=h.getX(P+0),C=h.getX(P+1),k=h.getX(P+2);cs.a.fromBufferAttribute(g,E),cs.b.fromBufferAttribute(g,C),cs.c.fromBufferAttribute(g,k),o.splitByTriangle(cs)}const L=o.triangles;for(let I=0,_=L.length;I<_;I++){const P=L[I],E=o.coplanarTriangleUsed?Ol(P,f):_r(P,f);It.length=0,xe.length=0;for(let C=0,k=s.length;C<k;C++){const K=Lr(s[C],E,i);K!==Xi&&(xe.push(K),It.push(c[C].getGroupAttrSet(x)))}if(It.length!==0){ge.getBarycoord(P.a,ls.a),ge.getBarycoord(P.b,ls.b),ge.getBarycoord(P.c,ls.c);for(let C=0,k=It.length;C<k;C++){const K=It[C],pe=xe[C]===bn;Wl(y,ls,n.geometry,n.matrixWorld,ws,K,r!==pe)}}}}return A.length}function or(n,t,e,s,i,o,c=0){const a=n.matrixWorld.determinant()<0;ae.copy(t.matrixWorld).invert().multiply(n.matrixWorld),ws.getNormalMatrix(n.matrixWorld).multiplyScalar(a?-1:1);const r=t.geometry.boundsTree,u=n.geometry.groupIndices,l=n.geometry.index,d=n.geometry.attributes,f=d.position,h=[],g=n.geometry.halfEdges,A=new Set,w=Hi(n.geometry);for(let p=0,m=w;p<m;p++)p in e.intersectionSet||A.add(p);for(;A.size>0;){const p=Yl(A);A.delete(p),h.push(p);const m=3*p,y=l.getX(m+0),x=l.getX(m+1),b=l.getX(m+2);ne.a.fromBufferAttribute(f,y).applyMatrix4(ae),ne.b.fromBufferAttribute(f,x).applyMatrix4(ae),ne.c.fromBufferAttribute(f,b).applyMatrix4(ae);const S=_r(ne,r);xe.length=0,It.length=0;for(let T=0,B=s.length;T<B;T++){const M=Lr(s[T],S,i);M!==Xi&&(xe.push(M),It.push(o[T]))}for(;h.length>0;){const T=h.pop();for(let B=0;B<3;B++){const M=g.getSiblingTriangleIndex(T,B);M!==-1&&A.has(M)&&(h.push(M),A.delete(M))}if(It.length!==0){const B=3*T,M=l.getX(B+0),L=l.getX(B+1),I=l.getX(B+2),_=c===-1?0:u[T]+c;if(ne.a.fromBufferAttribute(f,M),ne.b.fromBufferAttribute(f,L),ne.c.fromBufferAttribute(f,I),!oe(ne))for(let P=0,E=It.length;P<E;P++){const C=xe[P],k=It[P].getGroupAttrSet(_),K=C===bn;ql(M,L,I,d,n.matrixWorld,ws,k,K!==a)}}}}}function Ql(n){for(let t=0;t<n.length-1;t++){const e=n[t],s=n[t+1];if(e.materialIndex===s.materialIndex){const i=e.start,o=s.start+s.count;s.start=i,s.count=o-i,n.splice(t,1),t--}}}function tu(n,t,e,s){e.clear();const i=n.attributes;for(let o=0,c=s.length;o<c;o++){const a=s[o],r=i[a];e.initializeArray(a,r.array.constructor,r.itemSize,r.normalized)}for(const o in e.attributes)s.includes(o)||e.delete(o);for(const o in t.attributes)s.includes(o)||(t.deleteAttribute(o),t.dispose())}function eu(n,t,e){let s=!1,i=-1;const o=n.attributes,c=t.groupAttributes[0];for(const r in c){const u=t.getTotalLength(r),l=t.getType(r),d=t.getItemSize(r),f=t.getNormalized(r);let h=o[r];(!h||h.array.length<u)&&(h=new Ms(new l(u),d,f),n.setAttribute(r,h),s=!0);let g=0;for(let A=0,w=Math.min(e.length,t.groupCount);A<w;A++){const p=e[A].index,{array:m,type:y,length:x}=t.groupAttributes[p][r],b=new y(m.buffer,0,x);h.array.set(b,g),g+=b.length}h.needsUpdate=!0,i=u/h.itemSize}if(n.index){const r=n.index.array;if(r.length<i)n.index=null,s=!0;else for(let u=0,l=r.length;u<l;u++)r[u]=u}let a=0;n.clearGroups();for(let r=0,u=Math.min(e.length,t.groupCount);r<u;r++){const{index:l,materialIndex:d}=e[r],f=t.getCount(l);f!==0&&(n.addGroup(a,f,d),a+=f)}n.setDrawRange(0,i),n.boundsTree=null,s&&n.dispose()}function rr(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(s=>{e[s.materialIndex]=t})),e}class Pr{constructor(){this.triangleSplitter=new Nl,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Kl}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,s,i=new ct){let o=!0;if(Array.isArray(s)||(s=[s]),Array.isArray(i)||(i=[i],o=!1),i.length!==s.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:c,attributeData:a,attributes:r,useGroups:u,consolidateGroups:l,debug:d}=this;for(;a.length<i.length;)a.push(new Ul);i.forEach((p,m)=>{tu(t.geometry,p.geometry,a[m],r)}),d.init(),Jl(t,e,s,c,a,{useGroups:u}),d.complete();const f=this.getGroupRanges(t.geometry),h=rr(f,t.material),g=this.getGroupRanges(e.geometry),A=rr(g,e.material);g.forEach(p=>p.materialIndex+=h.length);let w=[...f,...g].map((p,m)=>({...p,index:m}));if(u){const p=[...h,...A];l&&(w=w.map(y=>{const x=p[y.materialIndex];return y.materialIndex=p.indexOf(x),y}).sort((y,x)=>y.materialIndex-x.materialIndex));const m=[];for(let y=0,x=p.length;y<x;y++){let b=!1;for(let S=0,T=w.length;S<T;S++){const B=w[S];B.materialIndex===y&&(b=!0,B.materialIndex=m.length)}b&&m.push(p[y])}i.forEach(y=>{y.material=m})}else w=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(p=>{p.material=h[0]});return i.forEach((p,m)=>{const y=p.geometry;eu(y,a[m],w),l&&Ql(y.groups)}),o?i:i[0]}evaluateHierarchy(t,e=new ct){t.updateMatrixWorld(!0);const s=(o,c)=>{const a=o.children;for(let r=0,u=a.length;r<u;r++){const l=a[r];l.isOperationGroup?s(l,c):c(l)}},i=o=>{const c=o.children;let a=!1;for(let u=0,l=c.length;u<l;u++){const d=c[u];a=i(d)||a}const r=o.isDirty();if(r&&o.markUpdated(),a&&!o.isOperationGroup){let u;return s(o,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(o,l,l.operation)}),o._cachedGeometry=u.geometry,o._cachedMaterials=u.material,!0}else return a||r};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const lt=!1,V={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},J={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},nu=ue({title:"Shelf Texture"}),tn=new Ke(nu),Tn=tn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_COL_1K_METALNESS.png");Tn.colorSpace=An;const Sn=tn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_NRM_1K_METALNESS.png"),Bn=tn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_AO_1K_METALNESS.png"),Mn=tn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_ROUGHNESS_1K_METALNESS.png"),_n=tn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_METALNESS_1K_METALNESS.png"),Ln=tn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wood/VeneerWhiteOakRandomMatched001_DISP_1K_METALNESS.png");Tn.wrapS=Tn.wrapT=Sn.wrapS=Sn.wrapT=Bn.wrapS=Bn.wrapT=Mn.wrapS=Mn.wrapT=_n.wrapS=_n.wrapT=Ln.wrapS=Ln.wrapT=N;const St=.3;Tn.repeat.set(St,St);Sn.repeat.set(St,St);Bn.repeat.set(St,St);Mn.repeat.set(St,St);_n.repeat.set(St,St);Ln.repeat.set(St,St);const su=ue({title:"Window texture"}),en=new Ke(su),Wi=en.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-albedo.png");Wi.colorSpace=An;const vs=en.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Normal-dx.png"),Es=en.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-ao.png"),Cs=en.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Roughness.png"),zs=en.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Metallic.png"),qi=en.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/metal/worn-shiny-metal-Height.png");Wi.wrapS=N;Wi.wrapT=N;vs.wrapS=N;vs.wrapT=N;Es.wrapS=N;Es.wrapT=N;Cs.wrapS=N;Cs.wrapT=N;zs.wrapS=N;zs.wrapT=N;qi.wrapS=N;qi.wrapT=N;const{frameThickness:Zi,frameWidthOuter:Ir,frameHeightOuter:vr,slatWidth:Fe,x:iu,y:ou,frameWidthInner:Er,frameHeightInner:Cr}=J,Mt=new st({roughness:.1,metalness:.6,wireframe:lt,color:16777215}),zr=new ct(new kt(Ir,vr,Zi),Mt);zr.updateMatrixWorld();const Rr=new ct(new kt(Er,Cr,Zi),Mt);Rr.updateMatrixWorld();const Nn=new Pr,ru=Nn.evaluate(zr,Rr,Oi),Ki=new ct(new $(Er+1,Fe*2,Fe*2,V.roundSegments,V.roundRadius/2),Mt);Ki.position.set(0,-2.2,0);Ki.updateMatrixWorld();const Yi=new ct(new $(.6,Cr+1,.6,V.roundSegments,V.roundRadius/2),Mt);Yi.position.set(0,0,0);Yi.updateMatrixWorld();let Pn=Nn.evaluate(Ki,Yi,Xt);const Ji=new ct(new $(Fe,13.4,Fe,V.roundSegments,V.roundRadius/2),Mt);Ji.position.set(-8.2,4.6,0);Ji.updateMatrixWorld();Pn=Nn.evaluate(Pn,Ji,Xt);const Qi=new ct(new $(Fe,13.4,Fe,V.roundSegments,V.roundRadius/2),Mt);Qi.position.set(8.2,4.6,0);Qi.updateMatrixWorld();Pn=Nn.evaluate(Pn,Qi,Xt);const to=Nn.evaluate(ru,Pn,Xt);to.position.set(Ir/2+iu,vr/2+ou,-(V.wallThickness-Zi/2));to.updateMatrixWorld();Mt.normalMap=vs;Mt.aoMap=Es;Mt.roughnessMap=Cs;Mt.metalnessMap=zs;Mt.displacementMap=qi;Mt.displacementScale=.01;const{floorXLength:_t,floorZLength:Lt,wallHeight:Wt,wallThickness:D,roundRadius:Se,roundSegments:Be,ny:au}=V,kn=new Pr,cu=ue({title:"Wall texture"}),eo=new Ke(cu),ys=eo.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_albedo.png"),xs=eo.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_normal-ogl.png"),bs=eo.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/wall/fiber-textured-wall1_ao.png");ys.repeat.set(2,2);xs.repeat.set(2,2);bs.repeat.set(2,2);ys.wrapS=ys.wrapT=N;xs.wrapS=xs.wrapT=N;bs.wrapS=bs.wrapT=N;const nn=new st({roughness:1,metalness:0,wireframe:lt});nn.map=ys;nn.normalMap=xs;nn.aoMap=bs;const no=new st({roughness:1,metalness:0,wireframe:lt,transparent:!0,opacity:0}),lu=new $(_t+1,D,Lt+1,Be,Se),uu=ue({title:"Floor texture"}),Rs=new Ke(uu),fu=new st({roughness:1,metalness:0,wireframe:lt});let In=new ct(lu,fu);In.position.set(_t/2-1/2,-D/2,Lt/2-1/2);In.updateMatrixWorld();const du=new $(_t+1,.4,Lt+1,Be,Se),vn=Rs.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DIFFUSE-1K.png"),En=Rs.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-NORMALS16_OPENGL-1K.png"),Cn=Rs.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-DISPLACEMENT16-1K.png"),zn=Rs.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/floor/Proma-XL-Mist-001-ROUGHNESS-1K.png");vn.wrapS=vn.wrapT=En.wrapS=En.wrapT=Cn.wrapS=Cn.wrapT=zn.wrapS=zn.wrapT=N;vn.rotation=En.rotation=Cn.rotation=zn.rotation=Math.PI/2;vn.repeat.set(1.3,1.3);En.repeat.set(1.3,1.3);Cn.repeat.set(1.3,1.3);zn.repeat.set(1.3,1.3);const pu=new st({wireframe:lt,map:vn,normalMap:En,displacementMap:Cn,displacementScale:.001,roughnessMap:zn}),so=new ct(du,pu);so.position.set(_t/2-1/2,-.199,Lt/2-1/2);so.updateMatrixWorld();In=kn.evaluate(so,In,Xt);const hu=new $(D,Wt,Lt+1,Be,Se),io=new ct(hu,nn);io.position.set(-D/2,Wt/2-D,Lt/2-1/2);io.updateMatrixWorld();const gu=new $(_t+D,Wt,D,Be,Se),oo=new ct(gu,nn);oo.position.set(_t/2-D/2,Wt/2-D,-D/2);oo.updateMatrixWorld();const mu=new kt(J.frameWidthOuter,J.frameHeightOuter,D),ro=new ct(mu,nn);ro.position.set(J.frameWidthOuter/2+J.x,J.frameHeightOuter/2+J.y,-D/2);ro.updateMatrixWorld();const $r=kn.evaluate(oo,ro,Oi);$r.updateMatrixWorld();const $s=kn.evaluate($r,to,Xt);$s.receiveShadow=!0;$s.castShadow=!0;$s.updateMatrixWorld();const wu=new $(_t+D+.1,Wt,.1,Be,Se),Vs=new R(wu,no);Vs.position.set(_t/2-D/2,Wt/2-D,Lt-.19);Vs.receiveShadow=!0;Vs.castShadow=!0;const yu=new $(.1,Wt,Lt+D,Be,Se),Ns=new R(yu,no);Ns.position.set(_t+.1/2,Wt/2-D,Lt/2-D/2);Ns.receiveShadow=!0;Ns.castShadow=!0;const xu=new $(_t+D+.1,D,Lt+D+.1,Be,Se),ks=new R(xu,no);ks.position.set(_t/2-D/2,Wt-D/2,Lt/2-D/2);ks.receiveShadow=!0;ks.castShadow=!0;const Me=new Ut;Me.position.set(-_t/2,-au,-Lt/2);let De=kn.evaluate(io,$s,Xt);De.updateMatrixWorld();De=kn.evaluate(De,In,Xt);De.castShadow=!0;De.receiveShadow=!0;Me.add(De);Me.add(Vs);Me.add(Ns);Me.add(ks);z.add(Me);const ao=new Fi(Me);ao.visible=!1;z.add(ao);const Bt=J.frameWidthInner/2+.1,sn=.8,co=sn-.04,bu=.03,Vr=Math.ceil(J.frameHeightInner/co),{floorXLength:Au,floorZLength:Tu,ny:Su}=V,Us=new Ut;Us.position.set(-Au/2+Bt/2+3.5,-Su+co*Vr+.5,-Tu/2-.3);const Bu=new $(Bt,bu,sn,2,.4),Mu=new st({wireframe:lt,roughness:.6,metalness:.8}),X=[];for(let n=0;n<Vr;n++){const t=new R(Bu,Mu);t.position.set(0,-n*co,0),t.receiveShadow=!0,t.castShadow=!0,t.rotation.set(mt(15),0,0),X.push(t)}Us.add(...X);z.add(Us);const Nr=new Fi(Us);Nr.visible=!1;z.add(Nr);const hn=1,ar=.15;let je=!1,Ge=!1,He=!1,Oe=!1,Bi=!0,hs=!0;const _u=()=>{hs&&(Bi?(kr(),Bi=!1):(Ur(),Bi=!0))},Lu=()=>{hs?(Fr(),hs=!1):(Dr(),hs=!0)},kr=()=>{je=!0,Ge=!1,He=!1,Oe=!1},Ur=()=>{Ge=!0,je=!1,He=!1,Oe=!1},Fr=()=>{He=!0,je=!1,Ge=!1,Oe=!1},Dr=()=>{Oe=!0,je=!1,Ge=!1,He=!1},Pu=n=>{je?X[0].rotation.x>mt(-88)?X.forEach(t=>{t.rotation.x-=n*hn}):je=!1:Ge?X[0].rotation.x<mt(15)?X.forEach(t=>{t.rotation.x+=n*hn}):Ge=!1:He?X[0].rotation.x>mt(2)?X.forEach(t=>{t.rotation.x-=n*hn}):X[0].rotation.x<mt(-2)?X.forEach(t=>{t.rotation.x+=n*hn}):X[X.length-1].position.y<-1?X.forEach((t,e)=>{t.position.y+=n*ar*e}):He=!1:Oe&&(X[X.length-1].position.y>-21.27?(X.forEach((t,e)=>{t.position.y-=n*ar*e}),X[0].rotation.x<mt(15)&&X.forEach(t=>{t.rotation.x+=n*hn})):Oe=!1)},Vi=J.frameWidthInner/2+.1,jr=.8,lo=jr-.04,Iu=.03,Gr=Math.ceil(J.frameHeightInner/lo),{floorXLength:vu,floorZLength:Eu,ny:Cu}=V,Fs=new Ut;Fs.position.set(-vu/2+Vi+Vi/2+3.6,-Cu+lo*Gr+.5,-Eu/2-.3);const zu=new $(Vi,Iu,jr,2,.4),Ru=new st({wireframe:lt,roughness:.6,metalness:.8}),W=[];for(let n=0;n<Gr;n++){const t=new R(zu,Ru);t.position.set(0,-n*lo,0),t.receiveShadow=!0,t.castShadow=!0,t.rotation.set(mt(15),0,0),t.name="blind2",W.push(t)}Fs.add(...W);z.add(Fs);const Hr=new Fi(Fs);Hr.visible=!1;z.add(Hr);const gn=1,cr=.15;let Xe=!1,We=!1,qe=!1,Ze=!1,Mi=!0,gs=!0;const $u=()=>{gs&&(Mi?(Or(),Mi=!1):(Xr(),Mi=!0))},Vu=()=>{gs?(Wr(),gs=!1):(qr(),gs=!0)},Or=()=>{Xe=!0,We=!1,qe=!1,Ze=!1},Xr=()=>{We=!0,Xe=!1,qe=!1,Ze=!1},Wr=()=>{qe=!0,Xe=!1,We=!1,Ze=!1},qr=()=>{Ze=!0,Xe=!1,We=!1,qe=!1},Nu=n=>{Xe?W[0].rotation.x>mt(-88)?W.forEach(t=>{t.rotation.x-=n*gn}):Xe=!1:We?W[0].rotation.x<mt(15)?W.forEach(t=>{t.rotation.x+=n*gn}):We=!1:qe?W[0].rotation.x>mt(2)?W.forEach(t=>{t.rotation.x-=n*gn}):W[0].rotation.x<mt(-2)?W.forEach(t=>{t.rotation.x+=n*gn}):W[W.length-1].position.y<-1?W.forEach((t,e)=>{t.position.y+=n*cr*e}):qe=!1:Ze&&(W[W.length-1].position.y>-21.27?(W.forEach((t,e)=>{t.position.y-=n*cr*e}),W[0].rotation.x<mt(15)&&W.forEach(t=>{t.rotation.x+=n*gn})):Ze=!1)},{floorXLength:Ds,floorZLength:js,ny:Gs}=V,Hs=0,Os=new R(new kt(Bt,J.frameHeightInner/2+4,sn),new Vn({color:65280,transparent:!0,opacity:Hs,wireframe:!0}));Os.position.set(-Ds/2+Bt/2+3.5,-Gs+8+.5,-js/2-.3);Os.name="windowBlind1Area";z.add(Os);const Xs=new R(new kt(Bt,J.frameHeightInner/2-3.5,sn),new Vn({color:65280,transparent:!0,opacity:Hs,wireframe:!0}));Xs.position.set(-Ds/2+Bt/2+3.5,-Gs+20.5,-js/2-.3);Xs.name="windowBlind1AreaUp";z.add(Xs);const Ws=new R(new kt(Bt,J.frameHeightInner/2+4,sn),new Vn({color:65280,transparent:!0,opacity:Hs,wireframe:!0}));Ws.position.set(-Ds/2+Bt/2+3.6+Bt,-Gs+8+.5,-js/2-.3);Ws.name="windowBlind2Area";z.add(Ws);const qs=new R(new kt(Bt,J.frameHeightInner/2-3.5,sn),new Vn({color:65280,transparent:!0,opacity:Hs,wireframe:!0}));qs.position.set(-Ds/2+Bt/2+3.6+Bt,-Gs+20.5,-js/2-.3);qs.name="windowBlind2AreaUp";z.add(qs);const mn=n=>{let t=document.querySelector("#cursorTip");t||(t=document.createElement("div"),t.id="cursorTip",t.style.position="fixed",t.style.top="0",t.style.left="0",t.style.pointerEvents="none",t.style.zIndex="-100",t.style.color="white",t.style.fontSize="13px",t.style.padding="6px 10px",t.style.borderRadius="5px",t.style.backgroundColor="rgba(0, 0, 0, 0.5)",t.style.fontFamily="sans-serif",t.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.7)",t.textContent=n),t.textContent=n,document.body.appendChild(t),document.addEventListener("mousemove",e=>{t.style.transform=`translate(${e.clientX+10}px, ${e.clientY+10}px)`,t.style.zIndex="100"})},ku=()=>{const n=document.querySelector("#cursorTip");n&&document.body.removeChild(n)},Zr=16*1.8,Rn=10*1.8,Kr=.02,Yr=80,Jr=Rn/Yr,Uu=new kt(Zr,Jr,Kr),Fu=new st({metalness:.01,roughness:.8,color:16777215,wireframe:!1}),Du=new R(Uu,Fu),Qr=new Ut,ie=[];for(let n=0;n<Yr;n++){const t=Du.clone();t.position.set(-16,Rn/2-Jr*n-2,0),t.rotateY(Math.PI/2),ie.push(t),t.castShadow=!0,t.receiveShadow=!0}Qr.add(...ie);const lr=.1;let uo=!1,fo=!1,_i=!0;const ta=()=>{uo=!0,fo=!1},ea=()=>{fo=!0,uo=!1},ju=n=>{uo?ie[ie.length-1].position.y<Rn/2-2&&ie.forEach((t,e)=>{t.position.y+=n*lr*e}):fo&&ie[ie.length-1].position.y>-Rn/2-2+.5&&ie.forEach((t,e)=>{t.position.y-=n*lr*e})},na=()=>{_i?(ta(),_i=!1):(ea(),_i=!0)};z.add(Qr);const Gu=0,Un=new R(new kt(Zr,Rn,Kr),new Vn({color:65280,transparent:!0,opacity:Gu,wireframe:!0}));Un.rotation.y=Math.PI/2;Un.position.set(-16,-2,0);Un.name="screenArea";z.add(Un);const Hu=[Os,Ws,Xs,qs,Un],sa=new Ja,ce={x:null,y:null};window.addEventListener("mousemove",n=>{ce.x=n.clientX/Vt.width*2-1,ce.y=-(n.clientY/Vt.height)*2+1});let ye=null;const Ou=()=>{ce.x&&ce.y&&sa.setFromCamera({x:ce.x,y:ce.y},Ae)};window.addEventListener("click",n=>{});let ia=0;window.addEventListener("mousedown",()=>{ia=+Date.now()});window.addEventListener("mouseup",n=>{if(+Date.now()-ia<300&&(ce.x=n.clientX/Vt.width*2-1,ce.y=-(n.clientY/Vt.height)*2+1,ye))switch(ye.object.name){case"windowBlind1Area":_u();break;case"windowBlind2Area":$u();break;case"windowBlind1AreaUp":Lu();break;case"windowBlind2AreaUp":Vu();break;case"screenArea":na();break}});const Xu=()=>{const n=sa.intersectObjects(Hu);if(n.length){if(!ye||ye.object!==n[0].object)switch(document.documentElement.style.cursor="pointer",n[0].object.name){case"windowBlind1Area":mn("Click here to open/close blinds 1");break;case"windowBlind2Area":mn("Click here to open/close blinds 2");break;case"windowBlind1AreaUp":mn("Click here to lift/drop blinds 1");break;case"windowBlind2AreaUp":mn("Click here to lift/drop blinds 2");break;case"screenArea":mn("Click here to lift/drop screen");break}[ye]=n}else ye&&(document.documentElement.style.cursor="auto",ku()),ye=null},Wu=new Qa,oa=()=>{bo.begin(),vt.clear(),ao.update(),Je.update();const n=Wu.getDelta();Qs.animating&&Qs.update(n),Pu(n),Nu(n),ju(n),Ou(),Xu(),vt.render(z,Ae),Qs.render(vt),bo.end(),requestAnimationFrame(oa)},ra=new tc("#ffffff",.2);z.add(ra);const tt=new ec("#ffffff",2);tt.position.set(20,20,-30);tt.castShadow=!0;tt.shadow.mapSize.width=1024;tt.shadow.mapSize.height=1024;tt.shadow.camera.near=1;tt.shadow.camera.far=200;tt.shadow.camera.top=50;tt.shadow.camera.right=50;tt.shadow.camera.bottom=-50;tt.shadow.camera.left=-50;tt.shadow.normalBias=.2;z.add(tt);const aa=new nc(tt,10);z.add(aa);aa.visible=!1;const ca=new Ye(tt.shadow.camera);z.add(ca);ca.visible=!1;const Ft=new sc(16777215,30,40,1);Ft.position.set(V.wallThickness,2,V.wallThickness);Ft.castShadow=!0;Ft.shadow.camera.near=1;Ft.shadow.camera.far=30;Ft.shadow.normalBias=.7;Ft.shadow.radius=5;z.add(Ft);const la=new ic(Ft,10);z.add(la);la.visible=!1;const ua=new Ye(Ft.shadow.camera);z.add(ua);ua.visible=!1;const qt=new _s(16777215,30,60,Math.PI*.11,.6,1);qt.position.set(V.floorXLength/2-3,6,-6);qt.target.position.set(V.floorXLength/2-3,-V.ny,-6);qt.castShadow=!0;qt.shadow.camera.near=1;qt.shadow.camera.far=30;z.add(qt);const fa=new Ls(qt,16776960);z.add(fa);fa.visible=!1;const da=new Ye(qt.shadow.camera);z.add(da);da.visible=!1;const Zt=new _s(16777215,30,60,Math.PI*.11,.6,1);Zt.position.set(V.floorXLength/2-3,6,6);Zt.target.position.set(V.floorXLength/2-3,-V.ny,6);Zt.castShadow=!0;Zt.shadow.camera.near=1;Zt.shadow.camera.far=30;z.add(Zt);const pa=new Ls(Zt,16776960);z.add(pa);pa.visible=!1;const ha=new Ye(Zt.shadow.camera);z.add(ha);ha.visible=!1;const Kt=new _s(16777215,30,60,Math.PI*.19,.6,1.5);Kt.position.set(-(V.floorXLength/2-1),6.8,6);Kt.target.position.set(-(V.floorXLength/2),-V.ny,6);Kt.castShadow=!0;Kt.shadow.camera.near=1;Kt.shadow.camera.far=30;z.add(Kt);const ga=new Ls(Kt,16776960);z.add(ga);ga.visible=!1;const ma=new Ye(Kt.shadow.camera);z.add(ma);ma.visible=!1;const Yt=new _s(16777215,30,60,Math.PI*.19,.6,1.5);Yt.position.set(-(V.floorXLength/2-1),6.8,-6);Yt.target.position.set(-(V.floorXLength/2),-V.ny,-6);Yt.castShadow=!0;Yt.shadow.camera.near=1;Yt.shadow.camera.far=30;z.add(Yt);const wa=new Ls(Yt,16776960);z.add(wa);wa.visible=!1;const ya=new Ye(Yt.shadow.camera);z.add(ya);ya.visible=!1;const xa=[qt,Zt,Kt,Yt],qu=()=>{xa.forEach(n=>{n.visible=!1})},Zu=()=>{xa.forEach(n=>{n.visible=!0})},{floorXLength:Ku,floorZLength:Yu,ny:Ju}=V,po=new oc(42);po.position.set(-Ku/2,-Ju,-Yu/2);po.visible=!1;z.add(po);const{floorXLength:Qu,floorZLength:tf,ny:ef}=V,ho=new Ut;ho.position.set(-Qu/2,-ef,-tf/2);const nf=ue({title:"Sofa"}),sf=new pr(nf);sf.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/ikeaSofa.obj",n=>{n.scale.set(10,10,10),n.rotation.y=-Math.PI/2,n.position.set(33,0,15);const e=n.children[0],s=n.children[1];ur(e),ur(s);const i=ue({title:"Sofa texture",onLoad:()=>{const h=new st({map:c,normalMap:a,aoMap:r,roughnessMap:u,wireframe:lt});e.material=h;const g=new st({map:l,normalMap:d,aoMap:f,color:5093036,wireframe:lt});s.material=g,ho.add(n)}}),o=new Ke(i),c=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Color.jpg");c.colorSpace=An,c.wrapS=N,c.wrapT=N;const a=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_NormalGL.jpg");a.wrapS=N,a.wrapT=N;const r=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_AmbientOcclusion.jpg");r.wrapS=N,r.wrapT=N;const u=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabric/Fabric030_1K-JPG_Roughness.jpg");u.wrapS=N,u.wrapT=N;const l=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_b.png");l.colorSpace=An,l.wrapS=N,l.wrapT=N;const d=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_n.png");d.wrapS=N,d.wrapT=N;const f=o.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/fabricLinen/fabric-029_linen-plain-100x100cm_o.png");f.wrapS=N,f.wrapT=N});const ur=n=>{n.castShadow=!0,n.receiveShadow=!0};z.add(ho);const{floorXLength:of,floorZLength:rf,ny:af}=V,go=new Ut;go.position.set(-of/2,-af,-rf/2);const cf=new $(22,.2,26,2,.5),lf=ue({title:"Rug Texture"}),Fn=new Ke(lf),$n=Fn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_COLOR2.png");$n.colorSpace=An;const As=Fn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_DISP.png"),Ts=Fn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_NRM.jpg"),Ss=Fn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_OCC.jpg"),Bs=Fn.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/texture/rug/Fabric_Rug_006_ROUGH.jpg");$n.wrapS=$n.wrapT=As.wrapS=As.wrapT=Ts.wrapS=Ts.wrapT=Ss.wrapS=Ss.wrapT=Bs.wrapS=Bs.wrapT=N;const Nt=.44;$n.repeat.set(Nt,Nt);As.repeat.set(Nt,Nt);Ts.repeat.set(Nt,Nt);Ss.repeat.set(Nt,Nt);Bs.repeat.set(Nt,Nt);const ba=new st({wireframe:lt,map:$n,displacementMap:As,displacementScale:.005,normalMap:Ts,aoMap:Ss,roughnessMap:Bs});ba.normalScale.set(1.2,1.2);const Zs=new R(cf,ba);Zs.position.set(28,.01,15);Zs.receiveShadow=!0;Zs.castShadow=!0;go.add(Zs);z.add(go);const it=18.2,ut=18.2,ot=3.3,U=.37,Z=.24,Ct=3.3,ft=3,dt=.05,uf={shelfWidth:it,shelfHeight:ut,shelfDepth:ot,shelfBorderBoardThickness:U,shelfBoardThickness:Z,shelfInnerWidth:Ct,roundSegments:ft,roundRadius:dt},{floorXLength:ff,floorZLength:df,ny:pf}=V,et=new Ut;et.position.set(-ff/2+ot/2,-pf+U/2+.1,-df/2+it/2+2);const O=new st({wireframe:lt,map:Tn,normalMap:Sn,aoMap:Bn,roughnessMap:Mn,metalnessMap:_n,displacementMap:Ln,displacementScale:.006}),Aa=new R(new $(ot,ut,U,ft,dt),O);Aa.position.set(0,ut/2-U/2,-it/2+U/2);const hf=new R(new $(ot,U,it,ft,dt),O),Ta=new R(new $(ot,Z,it,ft,dt),O);Ta.position.set(0,U+Ct,0);const Sa=new R(new $(ot,Z,it,ft,dt),O);Sa.position.set(0,U+Ct*2+Z,0);const Ba=new R(new $(ot,Z,it,ft,dt),O);Ba.position.set(0,U+Ct*3+Z*2,0);const Ma=new R(new $(ot,Z,it,ft,dt),O);Ma.position.set(0,U+Ct*4+Z*3,0);const _a=new R(new $(ot,U,it,ft,dt),O);_a.position.set(0,U+Ct*5+Z*4,0);const La=new R(new $(ot,ut,Z,ft,dt),O);La.position.set(0,ut/2-U/2,-it/2+U/2+U+Ct);const Pa=new R(new $(ot,ut,Z,ft,dt),O);Pa.position.set(0,ut/2-U/2,-it/2+U/2+U+Ct*2+Z);const Ia=new R(new $(ot,ut,Z,ft,dt),O);Ia.position.set(0,ut/2-U/2,-it/2+U/2+U+Ct*3+Z*2);const va=new R(new $(ot,ut,Z,ft,dt),O);va.position.set(0,ut/2-U/2,-it/2+U/2+U+Ct*4+Z*3);const Ea=new R(new $(ot,ut,U,ft,dt),O);Ea.position.set(0,ut/2-U/2,-it/2+U/2+U+Ct*5+Z*4);et.add(hf);et.add(Ta);et.add(Sa);et.add(Ba);et.add(Ma);et.add(_a);et.add(Aa);et.add(La);et.add(Pa);et.add(Ia);et.add(va);et.add(Ea);et.children.forEach(n=>{n.castShadow=!0,n.receiveShadow=!0});z.add(et);const{shelfWidth:gf,shelfDepth:Jt,shelfBorderBoardThickness:q,shelfBoardThickness:Qt,shelfInnerWidth:_e,roundSegments:fe,roundRadius:de}=uf,te=_e*2+Qt+q*2,on=_e*4+Qt*3+q*2,{floorXLength:mf,floorZLength:wf,ny:yf}=V,zt=new Ut;zt.position.set(-mf/2+Jt/2,-yf+q/2+.1,-wf/2+te/2+2+gf);const xf=new R(new $(Jt,q,te,fe,de),O),Ca=new R(new $(Jt,Qt,te,fe,de),O);Ca.position.set(0,q+_e,0);const za=new R(new $(Jt,Qt,te,fe,de),O);za.position.set(0,q+_e*2+Qt,0);const Ra=new R(new $(Jt,Qt,te,fe,de),O);Ra.position.set(0,q+_e*3+Qt*2,0);const $a=new R(new $(Jt,q,te,fe,de),O);$a.position.set(0,q+_e*4+Qt*3,0);const Va=new R(new $(Jt,on,q,fe,de),O);Va.position.set(0,on/2-q/2,-te/2+q/2);const Na=new R(new $(Jt,on,q,fe,de),O);Na.position.set(0,on/2-q/2,te/2-q/2);const ka=new R(new $(Jt,on,Qt,fe,de),O);ka.position.set(0,on/2-q/2,-te/2+q/2+q+_e);zt.add(xf);zt.add(Ca);zt.add(za);zt.add(Ra);zt.add($a);zt.add(Va);zt.add(Na);zt.add(ka);zt.children.forEach(n=>{n.castShadow=!0,n.receiveShadow=!0});z.add(zt);const{floorXLength:bf,floorZLength:Af,ny:Tf}=V,Ni=new Ut;Ni.position.set(-bf/2,-Tf,-Af/2);const Sf=ue({title:"Table"}),Bf=new pr(Sf),fr=new st({wireframe:lt,color:16777215,normalMap:Sn,aoMap:Bn,roughnessMap:Mn,metalnessMap:_n,displacementMap:Ln,displacementScale:.002}),Mf=new st({wireframe:lt,color:16777215,normalMap:vs,aoMap:Es,roughnessMap:Cs,metalnessMap:zs});Bf.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/table/ikea Kvistbro storage.obj",n=>{n.scale.set(12,10,12),n.position.set(22,0,15),n.children[73].material=fr,n.children[72].material=fr,n.children[73].castShadow=!0,n.children[73].receiveShadow=!0,n.children[72].castShadow=!0,n.children[72].receiveShadow=!0;for(let e=0;e<72;e++){const s=n.children[e];s.castShadow=!0,s.receiveShadow=!0,s.material=Mf}Ni.add(n),z.add(Ni)});const Dn=new rc,_f={spotLight:!0,closeBlind1:()=>{kr()},openBlind1:()=>{Ur()},liftBlind1:()=>{Fr()},dropBlind1:()=>{Dr()},closeBlind2:()=>{Or()},openBlind2:()=>{Xr()},liftBlind2:()=>{Wr()},dropBlind2:()=>{qr()},liftScreen:()=>{ta()},dropScreen:()=>{ea()},toggleDropAndLift:()=>{na()}};Dn.add(tt,"visible").name("directionalLight");Dn.add(Ft,"visible").name("pointLight");Dn.add(ra,"visible").name("ambientLight");Dn.add(_f,"spotLight").name("spotLight").onChange(n=>{n?Zu():qu()});Dn.add(Je,"autoRotate");oa();ac(Vt,Ae,vt);

import"./modulepreload-polyfill-B5Qt9EMX.js";import{w as v,aP as Ze,n as Fi,j as Ni,m as Di,a4 as On,_ as ms,aQ as Dt,X as cn,U as gs,Q as be,aR as ki,a0 as ys,a3 as an,M as Jt,S as ji,aS as Hi,q as $i,aT as Oi,aU as ci,p as Gi,aV as Wi,G as Xi,P as qi,W as Zi,aW as Yi,O as Ji,c as Ki,J as Ye,V as Ut,aX as Gn,aY as tt,aZ as G,ar as Qi,v as lt,aq as ct,a_ as tr,Y as Wn,ak as ws,a$ as ai,b0 as Rt,b1 as er,a as Je,b2 as nr,b as xs,d as sr,A as ir,s as rr,l as or}from"./index-DVKogh9z.js";const ie=new v;function X(s,t,e,n,i,r){const a=2*Math.PI*i/4,c=Math.max(r-2*i,0),o=Math.PI/4;ie.copy(t),ie[n]=0,ie.normalize();const u=.5*a/(a+c),l=1-ie.angleTo(s)/o;return Math.sign(ie[e])===1?l*u:c/(a+c)+u+u*(1-l)}class ut extends Ze{constructor(t=1,e=1,n=1,i=2,r=.1){if(i=i*2+1,r=Math.min(t/2,e/2,n/2,r),super(1,1,1,i,i,i),i===1)return;const a=this.toNonIndexed();this.index=null,this.attributes.position=a.attributes.position,this.attributes.normal=a.attributes.normal,this.attributes.uv=a.attributes.uv;const c=new v,o=new v,u=new v(t,e,n).divideScalar(2).subScalar(r),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,h=l.length/6,m=new v,b=.5/i;for(let y=0,p=0;y<l.length;y+=3,p+=2)switch(c.fromArray(l,y),o.copy(c),o.x-=Math.sign(o.x)*b,o.y-=Math.sign(o.y)*b,o.z-=Math.sign(o.z)*b,o.normalize(),l[y+0]=u.x*Math.sign(c.x)+o.x*r,l[y+1]=u.y*Math.sign(c.y)+o.y*r,l[y+2]=u.z*Math.sign(c.z)+o.z*r,d[y+0]=o.x,d[y+1]=o.y,d[y+2]=o.z,Math.floor(y/h)){case 0:m.set(1,0,0),f[p+0]=X(m,o,"z","y",r,n),f[p+1]=1-X(m,o,"y","z",r,e);break;case 1:m.set(-1,0,0),f[p+0]=1-X(m,o,"z","y",r,n),f[p+1]=1-X(m,o,"y","z",r,e);break;case 2:m.set(0,1,0),f[p+0]=1-X(m,o,"x","z",r,t),f[p+1]=X(m,o,"z","x",r,n);break;case 3:m.set(0,-1,0),f[p+0]=1-X(m,o,"x","z",r,t),f[p+1]=1-X(m,o,"z","x",r,n);break;case 4:m.set(0,0,1),f[p+0]=1-X(m,o,"x","y",r,t),f[p+1]=1-X(m,o,"y","x",r,e);break;case 5:m.set(0,0,-1),f[p+0]=X(m,o,"x","y",r,t),f[p+1]=1-X(m,o,"y","x",r,e);break}}}const cr=/^[og]\s*(.+)?/,ar=/^mtllib /,lr=/^usemtl /,ur=/^usemap /,As=/\s+/,bs=new v,ln=new v,Ts=new v,Ss=new v,q=new v,Te=new Fi;function fr(){const s={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const n=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(i,r){const a=this._finalize(!1);a&&(a.inherited||a.groupCount<=0)&&this.materials.splice(a.index,1);const c={index:this.materials.length,name:i||"",mtllib:Array.isArray(r)&&r.length>0?r[r.length-1]:"",smooth:a!==void 0?a.smooth:this.smooth,groupStart:a!==void 0?a.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(o){const u={index:typeof o=="number"?o:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return u.clone=this.clone.bind(u),u}};return this.materials.push(c),c},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(i){const r=this.currentMaterial();if(r&&r.groupEnd===-1&&(r.groupEnd=this.geometry.vertices.length/3,r.groupCount=r.groupEnd-r.groupStart,r.inherited=!1),i&&this.materials.length>1)for(let a=this.materials.length-1;a>=0;a--)this.materials[a].groupCount<=0&&this.materials.splice(a,1);return i&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),r}},n&&n.name&&typeof n.clone=="function"){const i=n.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseNormalIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/3)*3},parseUVIndex:function(t,e){const n=parseInt(t,10);return(n>=0?n-1:n+e/2)*2},addVertex:function(t,e,n){const i=this.vertices,r=this.object.geometry.vertices;r.push(i[t+0],i[t+1],i[t+2]),r.push(i[e+0],i[e+1],i[e+2]),r.push(i[n+0],i[n+1],i[n+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,n){const i=this.normals,r=this.object.geometry.normals;r.push(i[t+0],i[t+1],i[t+2]),r.push(i[e+0],i[e+1],i[e+2]),r.push(i[n+0],i[n+1],i[n+2])},addFaceNormal:function(t,e,n){const i=this.vertices,r=this.object.geometry.normals;bs.fromArray(i,t),ln.fromArray(i,e),Ts.fromArray(i,n),q.subVectors(Ts,ln),Ss.subVectors(bs,ln),q.cross(Ss),q.normalize(),r.push(q.x,q.y,q.z),r.push(q.x,q.y,q.z),r.push(q.x,q.y,q.z)},addColor:function(t,e,n){const i=this.colors,r=this.object.geometry.colors;i[t]!==void 0&&r.push(i[t+0],i[t+1],i[t+2]),i[e]!==void 0&&r.push(i[e+0],i[e+1],i[e+2]),i[n]!==void 0&&r.push(i[n+0],i[n+1],i[n+2])},addUV:function(t,e,n){const i=this.uvs,r=this.object.geometry.uvs;r.push(i[t+0],i[t+1]),r.push(i[e+0],i[e+1]),r.push(i[n+0],i[n+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,n,i,r,a,c,o,u){const l=this.vertices.length;let d=this.parseVertexIndex(t,l),f=this.parseVertexIndex(e,l),h=this.parseVertexIndex(n,l);if(this.addVertex(d,f,h),this.addColor(d,f,h),c!==void 0&&c!==""){const m=this.normals.length;d=this.parseNormalIndex(c,m),f=this.parseNormalIndex(o,m),h=this.parseNormalIndex(u,m),this.addNormal(d,f,h)}else this.addFaceNormal(d,f,h);if(i!==void 0&&i!==""){const m=this.uvs.length;d=this.parseUVIndex(i,m),f=this.parseUVIndex(r,m),h=this.parseUVIndex(a,m),this.addUV(d,f,h),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let n=0,i=t.length;n<i;n++){const r=this.parseVertexIndex(t[n],e);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const n=this.vertices.length,i=this.uvs.length;for(let r=0,a=t.length;r<a;r++)this.addVertexLine(this.parseVertexIndex(t[r],n));for(let r=0,a=e.length;r<a;r++)this.addUVLine(this.parseUVIndex(e[r],i))}};return s.startObject("",!1),s}class dr extends Ni{constructor(t){super(t),this.materials=null}load(t,e,n,i){const r=this,a=new Di(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(c){try{e(r.parse(c))}catch(o){i?i(o):console.error(o),r.manager.itemError(t)}},n,i)}setMaterials(t){return this.materials=t,this}parse(t){const e=new fr;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const n=t.split(`
`);let i=[];for(let c=0,o=n.length;c<o;c++){const u=n[c].trimStart();if(u.length===0)continue;const l=u.charAt(0);if(l!=="#")if(l==="v"){const d=u.split(As);switch(d[0]){case"v":e.vertices.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3])),d.length>=7?(Te.setRGB(parseFloat(d[4]),parseFloat(d[5]),parseFloat(d[6])).convertSRGBToLinear(),e.colors.push(Te.r,Te.g,Te.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(d[1]),parseFloat(d[2]),parseFloat(d[3]));break;case"vt":e.uvs.push(parseFloat(d[1]),parseFloat(d[2]));break}}else if(l==="f"){const f=u.slice(1).trim().split(As),h=[];for(let b=0,y=f.length;b<y;b++){const p=f[b];if(p.length>0){const g=p.split("/");h.push(g)}}const m=h[0];for(let b=1,y=h.length-1;b<y;b++){const p=h[b],g=h[b+1];e.addFace(m[0],p[0],g[0],m[1],p[1],g[1],m[2],p[2],g[2])}}else if(l==="l"){const d=u.substring(1).trim().split(" ");let f=[];const h=[];if(u.indexOf("/")===-1)f=d;else for(let m=0,b=d.length;m<b;m++){const y=d[m].split("/");y[0]!==""&&f.push(y[0]),y[1]!==""&&h.push(y[1])}e.addLineGeometry(f,h)}else if(l==="p"){const f=u.slice(1).trim().split(" ");e.addPointGeometry(f)}else if((i=cr.exec(u))!==null){const d=(" "+i[0].slice(1).trim()).slice(1);e.startObject(d)}else if(lr.test(u))e.object.startMaterial(u.substring(7).trim(),e.materialLibraries);else if(ar.test(u))e.materialLibraries.push(u.substring(7).trim());else if(ur.test(u))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(l==="s"){if(i=u.split(" "),i.length>1){const f=i[1].trim().toLowerCase();e.object.smooth=f!=="0"&&f!=="off"}else e.object.smooth=!0;const d=e.object.currentMaterial();d&&(d.smooth=e.object.smooth)}else{if(u==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+u+'"')}}e.finalize();const r=new On;if(r.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let c=0,o=e.objects.length;c<o;c++){const u=e.objects[c],l=u.geometry,d=u.materials,f=l.type==="Line",h=l.type==="Points";let m=!1;if(l.vertices.length===0)continue;const b=new ms;b.setAttribute("position",new Dt(l.vertices,3)),l.normals.length>0&&b.setAttribute("normal",new Dt(l.normals,3)),l.colors.length>0&&(m=!0,b.setAttribute("color",new Dt(l.colors,3))),l.hasUVIndices===!0&&b.setAttribute("uv",new Dt(l.uvs,2));const y=[];for(let g=0,w=d.length;g<w;g++){const x=d[g],A=x.name+"_"+x.smooth+"_"+m;let S=e.materials[A];if(this.materials!==null){if(S=this.materials.create(x.name),f&&S&&!(S instanceof cn)){const T=new cn;gs.prototype.copy.call(T,S),T.color.copy(S.color),S=T}else if(h&&S&&!(S instanceof be)){const T=new be({size:10,sizeAttenuation:!1});gs.prototype.copy.call(T,S),T.color.copy(S.color),T.map=S.map,S=T}}S===void 0&&(f?S=new cn:h?S=new be({size:1,sizeAttenuation:!1}):S=new ki,S.name=x.name,S.flatShading=!x.smooth,S.vertexColors=m,e.materials[A]=S),y.push(S)}let p;if(y.length>1){for(let g=0,w=d.length;g<w;g++){const x=d[g];b.addGroup(x.groupStart,x.groupCount,g)}f?p=new ys(b,y):h?p=new an(b,y):p=new Jt(b,y)}else f?p=new ys(b,y[0]):h?p=new an(b,y[0]):p=new Jt(b,y[0]);p.name=u.name,r.add(p)}else if(e.vertices.length>0){const c=new be({size:1,sizeAttenuation:!1}),o=new ms;o.setAttribute("position",new Dt(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(o.setAttribute("color",new Dt(e.colors,3)),c.vertexColors=!0);const u=new an(o,c);r.add(u)}return r}}const st=new ji,we=!1,O={floorXLength:40,floorZLength:30,ny:18,wallHeight:26.8,wallThickness:1.6,roundRadius:.2,roundSegments:4},zt={frameThickness:1,frameWidthOuter:33.4,frameHeightOuter:22.8,frameWidthInner:32.6,frameHeightInner:22,slatWidth:.4,x:3.3,y:.4},li=new Hi("#ffffff",.2);st.add(li);const j=new $i("#ffffff",1);j.position.set(20,20,-30);j.castShadow=!0;j.shadow.mapSize.width=1024;j.shadow.mapSize.height=1024;j.shadow.camera.near=1;j.shadow.camera.far=100;j.shadow.camera.top=50;j.shadow.camera.right=50;j.shadow.camera.bottom=-50;j.shadow.camera.left=-50;j.shadow.normalBias=.1;st.add(j);const ui=new Oi(j,10);st.add(ui);ui.visible=!1;const fi=new ci(j.shadow.camera);st.add(fi);fi.visible=!1;const wt=new Gi(16777215,20,40,1);wt.position.set(O.wallThickness,6,O.wallThickness);wt.castShadow=!0;wt.shadow.camera.near=1;wt.shadow.camera.far=30;wt.shadow.normalBias=.7;st.add(wt);const di=new Wi(wt,10);st.add(di);di.visible=!1;const pi=new ci(wt.shadow.camera);st.add(pi);pi.visible=!1;const Ke=new Xi;Ke.add(j,"visible").name("directionalLight");Ke.add(wt,"visible").name("pointLight");Ke.add(li,"visible").name("ambientLight");const ge={width:window.innerWidth,height:window.innerHeight},xe=new qi(20,ge.width/ge.height,.1,1e5);xe.position.set(120,100,120);const hi=document.querySelector("canvas.webgl");if(hi===null)throw new Error("Cannot find the canvas element");const ot=new Zi({canvas:hi,antialias:!0});ot.setSize(ge.width,ge.height);ot.setPixelRatio(Math.min(window.devicePixelRatio,2));ot.autoClear=!1;ot.shadowMap.enabled=!0;ot.shadowMap.type=Yi;const Xn=new Ji(xe,ot.domElement);Xn.enableDamping=!0;const un=Ki(xe,ot.domElement),mi=0,pr=1,hr=2,Bs=2,fn=1.25,_s=1,pe=6*4+4+4,Qe=65535,mr=Math.pow(2,-24),dn=Symbol("SKIP_GENERATION");function gr(s){return s.index?s.index.count:s.attributes.position.count}function te(s){return gr(s)/3}function yr(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function wr(s,t){if(!s.index){const e=s.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=yr(e,n);s.setIndex(new Ye(i,1));for(let r=0;r<e;r++)i[r]=r}}function gi(s){const t=te(s),e=s.drawRange,n=e.start/3,i=(e.start+e.count)/3,r=Math.max(0,n),a=Math.min(t,i)-r;return[{offset:Math.floor(r),count:Math.floor(a)}]}function yi(s){if(!s.groups||!s.groups.length)return gi(s);const t=[],e=new Set,n=s.drawRange,i=n.start/3,r=(n.start+n.count)/3;for(const c of s.groups){const o=c.start/3,u=(c.start+c.count)/3;e.add(Math.max(i,o)),e.add(Math.min(r,u))}const a=Array.from(e.values()).sort((c,o)=>c-o);for(let c=0;c<a.length-1;c++){const o=a[c],u=a[c+1];t.push({offset:Math.floor(o),count:Math.floor(u-o)})}return t}function xr(s){if(s.groups.length===0)return!1;const t=te(s),e=yi(s).sort((r,a)=>r.offset-a.offset),n=e[e.length-1];n.count=Math.min(t-n.offset,n.count);let i=0;return e.forEach(({count:r})=>i+=r),t!==i}function pn(s,t,e,n,i){let r=1/0,a=1/0,c=1/0,o=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,m=-1/0,b=-1/0,y=-1/0;for(let p=t*6,g=(t+e)*6;p<g;p+=6){const w=s[p+0],x=s[p+1],A=w-x,S=w+x;A<r&&(r=A),S>o&&(o=S),w<d&&(d=w),w>m&&(m=w);const T=s[p+2],B=s[p+3],_=T-B,M=T+B;_<a&&(a=_),M>u&&(u=M),T<f&&(f=T),T>b&&(b=T);const L=s[p+4],P=s[p+5],I=L-P,E=L+P;I<c&&(c=I),E>l&&(l=E),L<h&&(h=L),L>y&&(y=L)}n[0]=r,n[1]=a,n[2]=c,n[3]=o,n[4]=u,n[5]=l,i[0]=d,i[1]=f,i[2]=h,i[3]=m,i[4]=b,i[5]=y}function Ar(s,t=null,e=null,n=null){const i=s.attributes.position,r=s.index?s.index.array:null,a=te(s),c=i.normalized;let o;t===null?(o=new Float32Array(a*6*4),e=0,n=a):(o=t,e=e||0,n=n||a);const u=i.array,l=i.offset||0;let d=3;i.isInterleavedBufferAttribute&&(d=i.data.stride);const f=["getX","getY","getZ"];for(let h=e;h<e+n;h++){const m=h*3,b=h*6;let y=m+0,p=m+1,g=m+2;r&&(y=r[y],p=r[p],g=r[g]),c||(y=y*d+l,p=p*d+l,g=g*d+l);for(let w=0;w<3;w++){let x,A,S;c?(x=i[f[w]](y),A=i[f[w]](p),S=i[f[w]](g)):(x=u[y+w],A=u[p+w],S=u[g+w]);let T=x;A<T&&(T=A),S<T&&(T=S);let B=x;A>B&&(B=A),S>B&&(B=S);const _=(B-T)/2,M=w*2;o[b+M+0]=T+_,o[b+M+1]=_+(Math.abs(T)+_)*mr}}return o}function R(s,t,e){return e.min.x=t[s],e.min.y=t[s+1],e.min.z=t[s+2],e.max.x=t[s+3],e.max.y=t[s+4],e.max.z=t[s+5],e}function Ps(s){let t=-1,e=-1/0;for(let n=0;n<3;n++){const i=s[n+3]-s[n];i>e&&(e=i,t=n)}return t}function Ms(s,t){t.set(s)}function Is(s,t,e){let n,i;for(let r=0;r<3;r++){const a=r+3;n=s[r],i=t[r],e[r]=n<i?n:i,n=s[a],i=t[a],e[a]=n>i?n:i}}function Se(s,t,e){for(let n=0;n<3;n++){const i=t[s+2*n],r=t[s+2*n+1],a=i-r,c=i+r;a<e[n]&&(e[n]=a),c>e[n+3]&&(e[n+3]=c)}}function re(s){const t=s[3]-s[0],e=s[4]-s[1],n=s[5]-s[2];return 2*(t*e+e*n+n*t)}const gt=32,br=(s,t)=>s.candidate-t.candidate,At=new Array(gt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Be=new Float32Array(6);function Tr(s,t,e,n,i,r){let a=-1,c=0;if(r===mi)a=Ps(t),a!==-1&&(c=(t[a]+t[a+3])/2);else if(r===pr)a=Ps(s),a!==-1&&(c=Sr(e,n,i,a));else if(r===hr){const o=re(s);let u=fn*i;const l=n*6,d=(n+i)*6;for(let f=0;f<3;f++){const h=t[f],y=(t[f+3]-h)/gt;if(i<gt/4){const p=[...At];p.length=i;let g=0;for(let x=l;x<d;x+=6,g++){const A=p[g];A.candidate=e[x+2*f],A.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:B}=A;for(let _=0;_<3;_++)B[_]=1/0,B[_+3]=-1/0,T[_]=1/0,T[_+3]=-1/0,S[_]=1/0,S[_+3]=-1/0;Se(x,e,S)}p.sort(br);let w=i;for(let x=0;x<w;x++){const A=p[x];for(;x+1<w&&p[x+1].candidate===A.candidate;)p.splice(x+1,1),w--}for(let x=l;x<d;x+=6){const A=e[x+2*f];for(let S=0;S<w;S++){const T=p[S];A>=T.candidate?Se(x,e,T.rightCacheBounds):(Se(x,e,T.leftCacheBounds),T.count++)}}for(let x=0;x<w;x++){const A=p[x],S=A.count,T=i-A.count,B=A.leftCacheBounds,_=A.rightCacheBounds;let M=0;S!==0&&(M=re(B)/o);let L=0;T!==0&&(L=re(_)/o);const P=_s+fn*(M*S+L*T);P<u&&(a=f,u=P,c=A.candidate)}}else{for(let w=0;w<gt;w++){const x=At[w];x.count=0,x.candidate=h+y+w*y;const A=x.bounds;for(let S=0;S<3;S++)A[S]=1/0,A[S+3]=-1/0}for(let w=l;w<d;w+=6){let S=~~((e[w+2*f]-h)/y);S>=gt&&(S=gt-1);const T=At[S];T.count++,Se(w,e,T.bounds)}const p=At[gt-1];Ms(p.bounds,p.rightCacheBounds);for(let w=gt-2;w>=0;w--){const x=At[w],A=At[w+1];Is(x.bounds,A.rightCacheBounds,x.rightCacheBounds)}let g=0;for(let w=0;w<gt-1;w++){const x=At[w],A=x.count,S=x.bounds,B=At[w+1].rightCacheBounds;A!==0&&(g===0?Ms(S,Be):Is(S,Be,Be)),g+=A;let _=0,M=0;g!==0&&(_=re(Be)/o);const L=i-g;L!==0&&(M=re(B)/o);const P=_s+fn*(_*g+M*L);P<u&&(a=f,u=P,c=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:a,pos:c}}function Sr(s,t,e,n){let i=0;for(let r=t,a=t+e;r<a;r++)i+=s[r*6+n*2];return i/e}class hn{constructor(){this.boundingData=new Float32Array(6)}}function Br(s,t,e,n,i,r){let a=n,c=n+i-1;const o=r.pos,u=r.axis*2;for(;;){for(;a<=c&&e[a*6+u]<o;)a++;for(;a<=c&&e[c*6+u]>=o;)c--;if(a<c){for(let l=0;l<3;l++){let d=t[a*3+l];t[a*3+l]=t[c*3+l],t[c*3+l]=d}for(let l=0;l<6;l++){let d=e[a*6+l];e[a*6+l]=e[c*6+l],e[c*6+l]=d}a++,c--}else return a}}function _r(s,t,e,n,i,r){let a=n,c=n+i-1;const o=r.pos,u=r.axis*2;for(;;){for(;a<=c&&e[a*6+u]<o;)a++;for(;a<=c&&e[c*6+u]>=o;)c--;if(a<c){let l=s[a];s[a]=s[c],s[c]=l;for(let d=0;d<6;d++){let f=e[a*6+d];e[a*6+d]=e[c*6+d],e[c*6+d]=f}a++,c--}else return a}}function $(s,t){return t[s+15]===65535}function W(s,t){return t[s+6]}function Y(s,t){return t[s+14]}function J(s){return s+8}function K(s,t){return t[s+6]}function wi(s,t){return t[s+7]}let xi,de,$e,Ai;const Pr=Math.pow(2,32);function Un(s){return"count"in s?1:1+Un(s.left)+Un(s.right)}function Mr(s,t,e){return xi=new Float32Array(e),de=new Uint32Array(e),$e=new Uint16Array(e),Ai=new Uint8Array(e),Rn(s,t)}function Rn(s,t){const e=s/4,n=s/2,i="count"in t,r=t.boundingData;for(let a=0;a<6;a++)xi[e+a]=r[a];if(i)if(t.buffer){const a=t.buffer;Ai.set(new Uint8Array(a),s);for(let c=s,o=s+a.byteLength;c<o;c+=pe){const u=c/2;$(u,$e)||(de[c/4+6]+=e)}return s+a.byteLength}else{const a=t.offset,c=t.count;return de[e+6]=a,$e[n+14]=c,$e[n+15]=Qe,s+pe}else{const a=t.left,c=t.right,o=t.splitAxis;let u;if(u=Rn(s+pe,a),u/4>Pr)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return de[e+6]=u/4,u=Rn(u,c),de[e+7]=o,u}}function Ir(s,t){const e=(s.index?s.index.count:s.attributes.position.count)/3,n=e>2**16,i=n?4:2,r=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),a=n?new Uint32Array(r):new Uint16Array(r);for(let c=0,o=a.length;c<o;c++)a[c]=c;return a}function Lr(s,t,e,n,i){const{maxDepth:r,verbose:a,maxLeafTris:c,strategy:o,onProgress:u,indirect:l}=i,d=s._indirectBuffer,f=s.geometry,h=f.index?f.index.array:null,m=l?_r:Br,b=te(f),y=new Float32Array(6);let p=!1;const g=new hn;return pn(t,e,n,g.boundingData,y),x(g,e,n,y),g;function w(A){u&&u(A/b)}function x(A,S,T,B=null,_=0){if(!p&&_>=r&&(p=!0,a&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(f))),T<=c||_>=r)return w(S+T),A.offset=S,A.count=T,A;const M=Tr(A.boundingData,B,t,S,T,o);if(M.axis===-1)return w(S+T),A.offset=S,A.count=T,A;const L=m(d,h,t,S,T,M);if(L===S||L===S+T)w(S+T),A.offset=S,A.count=T;else{A.splitAxis=M.axis;const P=new hn,I=S,E=L-S;A.left=P,pn(t,I,E,P.boundingData,y),x(P,I,E,y,_+1);const C=new hn,z=L,D=T-E;A.right=C,pn(t,z,D,C.boundingData,y),x(C,z,D,y,_+1)}return A}}function vr(s,t){const e=s.geometry;t.indirect&&(s._indirectBuffer=Ir(e,t.useSharedArrayBuffer),xr(e)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||wr(e,t);const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ar(e),r=t.indirect?gi(e):yi(e);s._roots=r.map(a=>{const c=Lr(s,i,a.offset,a.count,t),o=Un(c),u=new n(pe*o);return Mr(0,c,u),u})}class yt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,i=-1/0;for(let r=0,a=t.length;r<a;r++){const o=t[r][e];n=o<n?o:n,i=o>i?o:i}this.min=n,this.max=i}setFromPoints(t,e){let n=1/0,i=-1/0;for(let r=0,a=e.length;r<a;r++){const c=e[r],o=t.dot(c);n=o<n?o:n,i=o>i?o:i}this.min=n,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}yt.prototype.setFromBox=function(){const s=new v;return function(e,n){const i=n.min,r=n.max;let a=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){s.x=i.x*o+r.x*(1-o),s.y=i.y*u+r.y*(1-u),s.z=i.z*l+r.z*(1-l);const d=e.dot(s);a=Math.min(d,a),c=Math.max(d,c)}this.min=a,this.max=c}}();const Er=function(){const s=new v,t=new v,e=new v;return function(i,r,a){const c=i.start,o=s,u=r.start,l=t;e.subVectors(c,u),s.subVectors(i.end,i.start),t.subVectors(r.end,r.start);const d=e.dot(l),f=l.dot(o),h=l.dot(l),m=e.dot(o),y=o.dot(o)*h-f*f;let p,g;y!==0?p=(d*f-m*h)/y:p=0,g=(d+p*f)/h,a.x=p,a.y=g}}(),qn=function(){const s=new Ut,t=new v,e=new v;return function(i,r,a,c){Er(i,r,s);let o=s.x,u=s.y;if(o>=0&&o<=1&&u>=0&&u<=1){i.at(o,a),r.at(u,c);return}else if(o>=0&&o<=1){u<0?r.at(0,c):r.at(1,c),i.closestPointToPoint(c,!0,a);return}else if(u>=0&&u<=1){o<0?i.at(0,a):i.at(1,a),r.closestPointToPoint(a,!0,c);return}else{let l;o<0?l=i.start:l=i.end;let d;u<0?d=r.start:d=r.end;const f=t,h=e;if(i.closestPointToPoint(d,!0,t),r.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=h.distanceToSquared(l)){a.copy(f),c.copy(d);return}else{a.copy(l),c.copy(h);return}}}}(),Cr=function(){const s=new v,t=new v,e=new Gn,n=new tt;return function(r,a){const{radius:c,center:o}=r,{a:u,b:l,c:d}=a;if(n.start=u,n.end=l,n.closestPointToPoint(o,!0,s).distanceTo(o)<=c||(n.start=u,n.end=d,n.closestPointToPoint(o,!0,s).distanceTo(o)<=c)||(n.start=l,n.end=d,n.closestPointToPoint(o,!0,s).distanceTo(o)<=c))return!0;const b=a.getPlane(e);if(Math.abs(b.distanceToPoint(o))<=c){const p=b.projectPoint(o,t);if(a.containsPoint(p))return!0}return!1}}(),zr=1e-15;function mn(s){return Math.abs(s)<zr}class et extends G{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new v),this.satBounds=new Array(4).fill().map(()=>new yt),this.points=[this.a,this.b,this.c],this.sphere=new Qi,this.plane=new Gn,this.needsUpdate=!0}intersectsSphere(t){return Cr(t,this)}update(){const t=this.a,e=this.b,n=this.c,i=this.points,r=this.satAxes,a=this.satBounds,c=r[0],o=a[0];this.getNormal(c),o.setFromPoints(c,i);const u=r[1],l=a[1];u.subVectors(t,e),l.setFromPoints(u,i);const d=r[2],f=a[2];d.subVectors(e,n),f.setFromPoints(d,i);const h=r[3],m=a[3];h.subVectors(n,t),m.setFromPoints(h,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}et.prototype.closestPointToSegment=function(){const s=new v,t=new v,e=new tt;return function(i,r=null,a=null){const{start:c,end:o}=i,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const h=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[h]),qn(e,i,s,t),l=s.distanceToSquared(t),l<d&&(d=l,r&&r.copy(s),a&&a.copy(t))}return this.closestPointToPoint(c,s),l=c.distanceToSquared(s),l<d&&(d=l,r&&r.copy(s),a&&a.copy(c)),this.closestPointToPoint(o,s),l=o.distanceToSquared(s),l<d&&(d=l,r&&r.copy(s),a&&a.copy(o)),Math.sqrt(d)}}();et.prototype.intersectsTriangle=function(){const s=new et,t=new Array(3),e=new Array(3),n=new yt,i=new yt,r=new v,a=new v,c=new v,o=new v,u=new v,l=new tt,d=new tt,f=new tt,h=new v;function m(b,y,p){const g=b.points;let w=0,x=-1;for(let A=0;A<3;A++){const{start:S,end:T}=l;S.copy(g[A]),T.copy(g[(A+1)%3]),l.delta(a);const B=mn(y.distanceToPoint(S));if(mn(y.normal.dot(a))&&B){p.copy(l),w=2;break}const _=y.intersectLine(l,h);if(!_&&B&&h.copy(S),(_||B)&&!mn(h.distanceTo(T))){if(w<=1)(w===1?p.start:p.end).copy(h),B&&(x=w);else if(w>=2){(x===1?p.start:p.end).copy(h),w=2;break}if(w++,w===2&&x===-1)break}}return w}return function(y,p=null,g=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(s.copy(y),s.update(),y=s);const w=this.plane,x=y.plane;if(Math.abs(w.normal.dot(x.normal))>1-1e-10){const A=this.satBounds,S=this.satAxes;e[0]=y.a,e[1]=y.b,e[2]=y.c;for(let _=0;_<4;_++){const M=A[_],L=S[_];if(n.setFromPoints(L,e),M.isSeparated(n))return!1}const T=y.satBounds,B=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let _=0;_<4;_++){const M=T[_],L=B[_];if(n.setFromPoints(L,t),M.isSeparated(n))return!1}for(let _=0;_<4;_++){const M=S[_];for(let L=0;L<4;L++){const P=B[L];if(r.crossVectors(M,P),n.setFromPoints(r,t),i.setFromPoints(r,e),n.isSeparated(i))return!1}}return p&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const A=m(this,x,d);if(A===1&&y.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(A!==2)return!1;const S=m(y,w,f);if(S===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(S!==2)return!1;if(d.delta(c),f.delta(o),c.dot(o)<0){let I=f.start;f.start=f.end,f.end=I}const T=d.start.dot(c),B=d.end.dot(c),_=f.start.dot(c),M=f.end.dot(c),L=B<_,P=T<M;return T!==M&&_!==B&&L===P?!1:(p&&(u.subVectors(d.start,f.start),u.dot(c)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(c)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();et.prototype.distanceToPoint=function(){const s=new v;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}}();et.prototype.distanceToTriangle=function(){const s=new v,t=new v,e=["a","b","c"],n=new tt,i=new tt;return function(a,c=null,o=null){const u=c||o?n:null;if(this.intersectsTriangle(a,u))return(c||o)&&(c&&u.getCenter(c),o&&u.getCenter(o)),0;let l=1/0;for(let d=0;d<3;d++){let f;const h=e[d],m=a[h];this.closestPointToPoint(m,s),f=m.distanceToSquared(s),f<l&&(l=f,c&&c.copy(s),o&&o.copy(m));const b=this[h];a.closestPointToPoint(b,s),f=b.distanceToSquared(s),f<l&&(l=f,c&&c.copy(b),o&&o.copy(s))}for(let d=0;d<3;d++){const f=e[d],h=e[(d+1)%3];n.set(this[f],this[h]);for(let m=0;m<3;m++){const b=e[m],y=e[(m+1)%3];i.set(a[b],a[y]),qn(n,i,s,t);const p=s.distanceToSquared(t);p<l&&(l=p,c&&c.copy(s),o&&o.copy(t))}}return Math.sqrt(l)}}();class H{constructor(t,e,n){this.isOrientedBox=!0,this.min=new v,this.max=new v,this.matrix=new lt,this.invMatrix=new lt,this.points=new Array(8).fill().map(()=>new v),this.satAxes=new Array(3).fill().map(()=>new v),this.satBounds=new Array(3).fill().map(()=>new yt),this.alignedSatBounds=new Array(3).fill().map(()=>new yt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}H.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,i=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,h=i[f];h.x=u?n.x:e.x,h.y=l?n.y:e.y,h.z=d?n.z:e.z,h.applyMatrix4(t)}const r=this.satBounds,a=this.satAxes,c=i[0];for(let u=0;u<3;u++){const l=a[u],d=r[u],f=1<<u,h=i[f];l.subVectors(c,h),d.setFromPoints(l,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();H.prototype.intersectsBox=function(){const s=new yt;return function(e){this.needsUpdate&&this.update();const n=e.min,i=e.max,r=this.satBounds,a=this.satAxes,c=this.alignedSatBounds;if(s.min=n.x,s.max=i.x,c[0].isSeparated(s)||(s.min=n.y,s.max=i.y,c[1].isSeparated(s))||(s.min=n.z,s.max=i.z,c[2].isSeparated(s)))return!1;for(let o=0;o<3;o++){const u=a[o],l=r[o];if(s.setFromBox(u,e),l.isSeparated(s))return!1}return!0}}();H.prototype.intersectsTriangle=function(){const s=new et,t=new Array(3),e=new yt,n=new yt,i=new v;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(s.copy(a),s.update(),a=s);const c=this.satBounds,o=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let f=0;f<3;f++){const h=c[f],m=o[f];if(e.setFromPoints(m,t),h.isSeparated(e))return!1}const u=a.satBounds,l=a.satAxes,d=this.points;for(let f=0;f<3;f++){const h=u[f],m=l[f];if(e.setFromPoints(m,d),h.isSeparated(e))return!1}for(let f=0;f<3;f++){const h=o[f];for(let m=0;m<4;m++){const b=l[m];if(i.crossVectors(h,b),e.setFromPoints(i,t),n.setFromPoints(i,d),e.isSeparated(n))return!1}}return!0}}();H.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();H.prototype.distanceToPoint=function(){const s=new v;return function(e){return this.closestPointToPoint(e,s),e.distanceTo(s)}}();H.prototype.distanceToBox=function(){const s=["x","y","z"],t=new Array(12).fill().map(()=>new tt),e=new Array(12).fill().map(()=>new tt),n=new v,i=new v;return function(a,c=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(o||u)&&(a.getCenter(i),this.closestPointToPoint(i,n),a.closestPointToPoint(n,i),o&&o.copy(n),u&&u.copy(i)),0;const l=c*c,d=a.min,f=a.max,h=this.points;let m=1/0;for(let y=0;y<8;y++){const p=h[y];i.copy(p).clamp(d,f);const g=p.distanceToSquared(i);if(g<m&&(m=g,o&&o.copy(p),u&&u.copy(i),g<l))return Math.sqrt(g)}let b=0;for(let y=0;y<3;y++)for(let p=0;p<=1;p++)for(let g=0;g<=1;g++){const w=(y+1)%3,x=(y+2)%3,A=p<<w|g<<x,S=1<<y|p<<w|g<<x,T=h[A],B=h[S];t[b].set(T,B);const M=s[y],L=s[w],P=s[x],I=e[b],E=I.start,C=I.end;E[M]=d[M],E[L]=p?d[L]:f[L],E[P]=g?d[P]:f[L],C[M]=f[M],C[L]=p?d[L]:f[L],C[P]=g?d[P]:f[L],b++}for(let y=0;y<=1;y++)for(let p=0;p<=1;p++)for(let g=0;g<=1;g++){i.x=y?f.x:d.x,i.y=p?f.y:d.y,i.z=g?f.z:d.z,this.closestPointToPoint(i,n);const w=i.distanceToSquared(n);if(w<m&&(m=w,o&&o.copy(n),u&&u.copy(i),w<l))return Math.sqrt(w)}for(let y=0;y<12;y++){const p=t[y];for(let g=0;g<12;g++){const w=e[g];qn(p,w,n,i);const x=n.distanceToSquared(i);if(x<m&&(m=x,o&&o.copy(n),u&&u.copy(i),x<l))return Math.sqrt(x)}}return Math.sqrt(m)}}();class Zn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Vr extends Zn{constructor(){super(()=>new et)}}const Q=new Vr;class Ur{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const U=new Ur;let Bt,Yt;const kt=[],_e=new Zn(()=>new ct);function Rr(s,t,e,n,i,r){Bt=_e.getPrimitive(),Yt=_e.getPrimitive(),kt.push(Bt,Yt),U.setBuffer(s._roots[t]);const a=Fn(0,s.geometry,e,n,i,r);U.clearBuffer(),_e.releasePrimitive(Bt),_e.releasePrimitive(Yt),kt.pop(),kt.pop();const c=kt.length;return c>0&&(Yt=kt[c-1],Bt=kt[c-2]),a}function Fn(s,t,e,n,i=null,r=0,a=0){const{float32Array:c,uint16Array:o,uint32Array:u}=U;let l=s*2;if($(l,o)){const f=W(s,u),h=Y(l,o);return R(s,c,Bt),n(f,h,!1,a,r+s,Bt)}else{let M=function(P){const{uint16Array:I,uint32Array:E}=U;let C=P*2;for(;!$(C,I);)P=J(P),C=P*2;return W(P,E)},L=function(P){const{uint16Array:I,uint32Array:E}=U;let C=P*2;for(;!$(C,I);)P=K(P,E),C=P*2;return W(P,E)+Y(C,I)};const f=J(s),h=K(s,u);let m=f,b=h,y,p,g,w;if(i&&(g=Bt,w=Yt,R(m,c,g),R(b,c,w),y=i(g),p=i(w),p<y)){m=h,b=f;const P=y;y=p,p=P,g=w}g||(g=Bt,R(m,c,g));const x=$(m*2,o),A=e(g,x,y,a+1,r+m);let S;if(A===Bs){const P=M(m),E=L(m)-P;S=n(P,E,!0,a+1,r+m,g)}else S=A&&Fn(m,t,e,n,i,r,a+1);if(S)return!0;w=Yt,R(b,c,w);const T=$(b*2,o),B=e(w,T,p,a+1,r+b);let _;if(B===Bs){const P=M(b),E=L(b)-P;_=n(P,E,!0,a+1,r+b,w)}else _=B&&Fn(b,t,e,n,i,r,a+1);return!!_}}const oe=new v,gn=new v;function Fr(s,t,e={},n=0,i=1/0){const r=n*n,a=i*i;let c=1/0,o=null;if(s.shapecast({boundsTraverseOrder:l=>(oe.copy(t).clamp(l.min,l.max),oe.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<c&&f<a,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,oe);const f=t.distanceToSquared(oe);return f<c&&(gn.copy(oe),c=f,o=d),f<r}}),c===1/0)return null;const u=Math.sqrt(c);return e.point?e.point.copy(gn):e.point=gn.clone(),e.distance=u,e.faceIndex=o,e}const jt=new v,Ht=new v,$t=new v,Pe=new Ut,Me=new Ut,Ie=new Ut,Ls=new v,vs=new v,Es=new v,Le=new v;function Nr(s,t,e,n,i,r){let a;return r===tr?a=s.intersectTriangle(n,e,t,!0,i):a=s.intersectTriangle(t,e,n,r!==Wn,i),a===null?null:{distance:s.origin.distanceTo(i),point:i.clone()}}function Dr(s,t,e,n,i,r,a,c,o){jt.fromBufferAttribute(t,r),Ht.fromBufferAttribute(t,a),$t.fromBufferAttribute(t,c);const u=Nr(s,jt,Ht,$t,Le,o);if(u){n&&(Pe.fromBufferAttribute(n,r),Me.fromBufferAttribute(n,a),Ie.fromBufferAttribute(n,c),u.uv=G.getInterpolation(Le,jt,Ht,$t,Pe,Me,Ie,new Ut)),i&&(Pe.fromBufferAttribute(i,r),Me.fromBufferAttribute(i,a),Ie.fromBufferAttribute(i,c),u.uv1=G.getInterpolation(Le,jt,Ht,$t,Pe,Me,Ie,new Ut)),e&&(Ls.fromBufferAttribute(e,r),vs.fromBufferAttribute(e,a),Es.fromBufferAttribute(e,c),u.normal=G.getInterpolation(Le,jt,Ht,$t,Ls,vs,Es,new v),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const l={a:r,b:a,c,normal:new v,materialIndex:0};G.getNormal(jt,Ht,$t,l.normal),u.face=l,u.faceIndex=r}return u}function tn(s,t,e,n,i){const r=n*3;let a=r+0,c=r+1,o=r+2;const u=s.index;s.index&&(a=u.getX(a),c=u.getX(c),o=u.getX(o));const{position:l,normal:d,uv:f,uv1:h}=s.attributes,m=Dr(e,l,d,f,h,a,c,o,t);return m?(m.faceIndex=n,i&&i.push(m),m):null}function N(s,t,e,n){const i=s.a,r=s.b,a=s.c;let c=t,o=t+1,u=t+2;e&&(c=e.getX(c),o=e.getX(o),u=e.getX(u)),i.x=n.getX(c),i.y=n.getY(c),i.z=n.getZ(c),r.x=n.getX(o),r.y=n.getY(o),r.z=n.getZ(o),a.x=n.getX(u),a.y=n.getY(u),a.z=n.getZ(u)}function kr(s,t,e,n,i,r){const{geometry:a,_indirectBuffer:c}=s;for(let o=n,u=n+i;o<u;o++)tn(a,t,e,o,r)}function jr(s,t,e,n,i){const{geometry:r,_indirectBuffer:a}=s;let c=1/0,o=null;for(let u=n,l=n+i;u<l;u++){let d;d=tn(r,t,e,u),d&&d.distance<c&&(o=d,c=d.distance)}return o}function Hr(s,t,e,n,i,r,a){const{geometry:c}=e,{index:o}=c,u=c.attributes.position;for(let l=s,d=t+s;l<d;l++){let f;if(f=l,N(a,f*3,o,u),a.needsUpdate=!0,n(a,f,i,r))return!0}return!1}function $r(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let r,a,c,o,u=0;const l=s._roots;for(let f=0,h=l.length;f<h;f++)r=l[f],a=new Uint32Array(r),c=new Uint16Array(r),o=new Float32Array(r),d(0,u),u+=r.byteLength;function d(f,h,m=!1){const b=f*2;if(c[b+15]===Qe){const p=a[f+6],g=c[b+14];let w=1/0,x=1/0,A=1/0,S=-1/0,T=-1/0,B=-1/0;for(let _=3*p,M=3*(p+g);_<M;_++){let L=n[_];const P=i.getX(L),I=i.getY(L),E=i.getZ(L);P<w&&(w=P),P>S&&(S=P),I<x&&(x=I),I>T&&(T=I),E<A&&(A=E),E>B&&(B=E)}return o[f+0]!==w||o[f+1]!==x||o[f+2]!==A||o[f+3]!==S||o[f+4]!==T||o[f+5]!==B?(o[f+0]=w,o[f+1]=x,o[f+2]=A,o[f+3]=S,o[f+4]=T,o[f+5]=B,!0):!1}else{const p=f+8,g=a[f+6],w=p+h,x=g+h;let A=m,S=!1,T=!1;t?A||(S=t.has(w),T=t.has(x),A=!S&&!T):(S=!0,T=!0);const B=A||S,_=A||T;let M=!1;B&&(M=d(p,h,A));let L=!1;_&&(L=d(g,h,A));const P=M||L;if(P)for(let I=0;I<3;I++){const E=p+I,C=g+I,z=o[E],D=o[E+3],Nt=o[C],It=o[C+3];o[f+I]=z<Nt?z:Nt,o[f+I+3]=D>It?D:It}return P}}}const Cs=new ct;function Pt(s,t,e,n){return R(s,t,Cs),e.intersectBox(Cs,n)}function Or(s,t,e,n,i,r){const{geometry:a,_indirectBuffer:c}=s;for(let o=n,u=n+i;o<u;o++){let l=c?c[o]:o;tn(a,t,e,l,r)}}function Gr(s,t,e,n,i){const{geometry:r,_indirectBuffer:a}=s;let c=1/0,o=null;for(let u=n,l=n+i;u<l;u++){let d;d=tn(r,t,e,a?a[u]:u),d&&d.distance<c&&(o=d,c=d.distance)}return o}function Wr(s,t,e,n,i,r,a){const{geometry:c}=e,{index:o}=c,u=c.attributes.position;for(let l=s,d=t+s;l<d;l++){let f;if(f=e.resolveTriangleIndex(l),N(a,f*3,o,u),a.needsUpdate=!0,n(a,f,i,r))return!0}return!1}const zs=new v;function Xr(s,t,e,n,i){U.setBuffer(s._roots[t]),Nn(0,s,e,n,i),U.clearBuffer()}function Nn(s,t,e,n,i){const{float32Array:r,uint16Array:a,uint32Array:c}=U,o=s*2;if($(o,a)){const l=W(s,c),d=Y(o,a);kr(t,e,n,l,d,i)}else{const l=J(s);Pt(l,r,n,zs)&&Nn(l,t,e,n,i);const d=K(s,c);Pt(d,r,n,zs)&&Nn(d,t,e,n,i)}}const Vs=new v,qr=["x","y","z"];function Zr(s,t,e,n){U.setBuffer(s._roots[t]);const i=Dn(0,s,e,n);return U.clearBuffer(),i}function Dn(s,t,e,n){const{float32Array:i,uint16Array:r,uint32Array:a}=U;let c=s*2;if($(c,r)){const u=W(s,a),l=Y(c,r);return jr(t,e,n,u,l)}else{const u=wi(s,a),l=qr[u],f=n.direction[l]>=0;let h,m;f?(h=J(s),m=K(s,a)):(h=K(s,a),m=J(s));const y=Pt(h,i,n,Vs)?Dn(h,t,e,n):null;if(y){const w=y.point[l];if(f?w<=i[m+u]:w>=i[m+u+3])return y}const g=Pt(m,i,n,Vs)?Dn(m,t,e,n):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const ve=new ct,Ot=new et,Gt=new et,ce=new lt,Us=new H,Ee=new H;function Yr(s,t,e,n){U.setBuffer(s._roots[t]);const i=kn(0,s,e,n);return U.clearBuffer(),i}function kn(s,t,e,n,i=null){const{float32Array:r,uint16Array:a,uint32Array:c}=U;let o=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Us.set(e.boundingBox.min,e.boundingBox.max,n),i=Us),$(o,a)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,m=e.attributes.position,b=W(s,c),y=Y(o,a);if(ce.copy(n).invert(),e.boundsTree)return R(s,r,Ee),Ee.matrix.copy(ce),Ee.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>Ee.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(n),g.b.applyMatrix4(n),g.c.applyMatrix4(n),g.needsUpdate=!0;for(let w=b*3,x=(y+b)*3;w<x;w+=3)if(N(Gt,w,d,f),Gt.needsUpdate=!0,g.intersectsTriangle(Gt))return!0;return!1}});for(let p=b*3,g=(y+b)*3;p<g;p+=3){N(Ot,p,d,f),Ot.a.applyMatrix4(ce),Ot.b.applyMatrix4(ce),Ot.c.applyMatrix4(ce),Ot.needsUpdate=!0;for(let w=0,x=h.count;w<x;w+=3)if(N(Gt,w,h,m),Gt.needsUpdate=!0,Ot.intersectsTriangle(Gt))return!0}}else{const l=s+8,d=c[s+6];return R(l,r,ve),!!(i.intersectsBox(ve)&&kn(l,t,e,n,i)||(R(d,r,ve),i.intersectsBox(ve)&&kn(d,t,e,n,i)))}}const Ce=new lt,yn=new H,ae=new H,Jr=new v,Kr=new v,Qr=new v,to=new v;function eo(s,t,e,n={},i={},r=0,a=1/0){t.boundingBox||t.computeBoundingBox(),yn.set(t.boundingBox.min,t.boundingBox.max,e),yn.needsUpdate=!0;const c=s.geometry,o=c.attributes.position,u=c.index,l=t.attributes.position,d=t.index,f=Q.getPrimitive(),h=Q.getPrimitive();let m=Jr,b=Kr,y=null,p=null;i&&(y=Qr,p=to);let g=1/0,w=null,x=null;return Ce.copy(e).invert(),ae.matrix.copy(Ce),s.shapecast({boundsTraverseOrder:A=>yn.distanceToBox(A),intersectsBounds:(A,S,T)=>T<g&&T<a?(S&&(ae.min.copy(A.min),ae.max.copy(A.max),ae.needsUpdate=!0),!0):!1,intersectsRange:(A,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>ae.distanceToBox(B),intersectsBounds:(B,_,M)=>M<g&&M<a,intersectsRange:(B,_)=>{for(let M=B,L=B+_;M<L;M++){N(h,3*M,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let P=A,I=A+S;P<I;P++){N(f,3*P,u,o),f.needsUpdate=!0;const E=f.distanceToTriangle(h,m,y);if(E<g&&(b.copy(m),p&&p.copy(y),g=E,w=P,x=M),E<r)return!0}}}});{const T=te(t);for(let B=0,_=T;B<_;B++){N(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=A,L=A+S;M<L;M++){N(f,3*M,u,o),f.needsUpdate=!0;const P=f.distanceToTriangle(h,m,y);if(P<g&&(b.copy(m),p&&p.copy(y),g=P,w=M,x=B),P<r)return!0}}}}}),Q.releasePrimitive(f),Q.releasePrimitive(h),g===1/0?null:(n.point?n.point.copy(b):n.point=b.clone(),n.distance=g,n.faceIndex=w,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Ce),b.applyMatrix4(Ce),i.distance=b.sub(i.point).length(),i.faceIndex=x),n)}function no(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=s.geometry,n=e.index?e.index.array:null,i=e.attributes.position;let r,a,c,o,u=0;const l=s._roots;for(let f=0,h=l.length;f<h;f++)r=l[f],a=new Uint32Array(r),c=new Uint16Array(r),o=new Float32Array(r),d(0,u),u+=r.byteLength;function d(f,h,m=!1){const b=f*2;if(c[b+15]===Qe){const p=a[f+6],g=c[b+14];let w=1/0,x=1/0,A=1/0,S=-1/0,T=-1/0,B=-1/0;for(let _=p,M=p+g;_<M;_++){const L=3*s.resolveTriangleIndex(_);for(let P=0;P<3;P++){let I=L+P;I=n?n[I]:I;const E=i.getX(I),C=i.getY(I),z=i.getZ(I);E<w&&(w=E),E>S&&(S=E),C<x&&(x=C),C>T&&(T=C),z<A&&(A=z),z>B&&(B=z)}}return o[f+0]!==w||o[f+1]!==x||o[f+2]!==A||o[f+3]!==S||o[f+4]!==T||o[f+5]!==B?(o[f+0]=w,o[f+1]=x,o[f+2]=A,o[f+3]=S,o[f+4]=T,o[f+5]=B,!0):!1}else{const p=f+8,g=a[f+6],w=p+h,x=g+h;let A=m,S=!1,T=!1;t?A||(S=t.has(w),T=t.has(x),A=!S&&!T):(S=!0,T=!0);const B=A||S,_=A||T;let M=!1;B&&(M=d(p,h,A));let L=!1;_&&(L=d(g,h,A));const P=M||L;if(P)for(let I=0;I<3;I++){const E=p+I,C=g+I,z=o[E],D=o[E+3],Nt=o[C],It=o[C+3];o[f+I]=z<Nt?z:Nt,o[f+I+3]=D>It?D:It}return P}}}const Rs=new v;function so(s,t,e,n,i){U.setBuffer(s._roots[t]),jn(0,s,e,n,i),U.clearBuffer()}function jn(s,t,e,n,i){const{float32Array:r,uint16Array:a,uint32Array:c}=U,o=s*2;if($(o,a)){const l=W(s,c),d=Y(o,a);Or(t,e,n,l,d,i)}else{const l=J(s);Pt(l,r,n,Rs)&&jn(l,t,e,n,i);const d=K(s,c);Pt(d,r,n,Rs)&&jn(d,t,e,n,i)}}const Fs=new v,io=["x","y","z"];function ro(s,t,e,n){U.setBuffer(s._roots[t]);const i=Hn(0,s,e,n);return U.clearBuffer(),i}function Hn(s,t,e,n){const{float32Array:i,uint16Array:r,uint32Array:a}=U;let c=s*2;if($(c,r)){const u=W(s,a),l=Y(c,r);return Gr(t,e,n,u,l)}else{const u=wi(s,a),l=io[u],f=n.direction[l]>=0;let h,m;f?(h=J(s),m=K(s,a)):(h=K(s,a),m=J(s));const y=Pt(h,i,n,Fs)?Hn(h,t,e,n):null;if(y){const w=y.point[l];if(f?w<=i[m+u]:w>=i[m+u+3])return y}const g=Pt(m,i,n,Fs)?Hn(m,t,e,n):null;return y&&g?y.distance<=g.distance?y:g:y||g||null}}const ze=new ct,Wt=new et,Xt=new et,le=new lt,Ns=new H,Ve=new H;function oo(s,t,e,n){U.setBuffer(s._roots[t]);const i=$n(0,s,e,n);return U.clearBuffer(),i}function $n(s,t,e,n,i=null){const{float32Array:r,uint16Array:a,uint32Array:c}=U;let o=s*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Ns.set(e.boundingBox.min,e.boundingBox.max,n),i=Ns),$(o,a)){const l=t.geometry,d=l.index,f=l.attributes.position,h=e.index,m=e.attributes.position,b=W(s,c),y=Y(o,a);if(le.copy(n).invert(),e.boundsTree)return R(s,r,Ve),Ve.matrix.copy(le),Ve.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>Ve.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(n),g.b.applyMatrix4(n),g.c.applyMatrix4(n),g.needsUpdate=!0;for(let w=b,x=y+b;w<x;w++)if(N(Xt,3*t.resolveTriangleIndex(w),d,f),Xt.needsUpdate=!0,g.intersectsTriangle(Xt))return!0;return!1}});for(let p=b,g=y+b;p<g;p++){const w=t.resolveTriangleIndex(p);N(Wt,3*w,d,f),Wt.a.applyMatrix4(le),Wt.b.applyMatrix4(le),Wt.c.applyMatrix4(le),Wt.needsUpdate=!0;for(let x=0,A=h.count;x<A;x+=3)if(N(Xt,x,h,m),Xt.needsUpdate=!0,Wt.intersectsTriangle(Xt))return!0}}else{const l=s+8,d=c[s+6];return R(l,r,ze),!!(i.intersectsBox(ze)&&$n(l,t,e,n,i)||(R(d,r,ze),i.intersectsBox(ze)&&$n(d,t,e,n,i)))}}const Ue=new lt,wn=new H,ue=new H,co=new v,ao=new v,lo=new v,uo=new v;function fo(s,t,e,n={},i={},r=0,a=1/0){t.boundingBox||t.computeBoundingBox(),wn.set(t.boundingBox.min,t.boundingBox.max,e),wn.needsUpdate=!0;const c=s.geometry,o=c.attributes.position,u=c.index,l=t.attributes.position,d=t.index,f=Q.getPrimitive(),h=Q.getPrimitive();let m=co,b=ao,y=null,p=null;i&&(y=lo,p=uo);let g=1/0,w=null,x=null;return Ue.copy(e).invert(),ue.matrix.copy(Ue),s.shapecast({boundsTraverseOrder:A=>wn.distanceToBox(A),intersectsBounds:(A,S,T)=>T<g&&T<a?(S&&(ue.min.copy(A.min),ue.max.copy(A.max),ue.needsUpdate=!0),!0):!1,intersectsRange:(A,S)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:B=>ue.distanceToBox(B),intersectsBounds:(B,_,M)=>M<g&&M<a,intersectsRange:(B,_)=>{for(let M=B,L=B+_;M<L;M++){const P=T.resolveTriangleIndex(M);N(h,3*P,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let I=A,E=A+S;I<E;I++){const C=s.resolveTriangleIndex(I);N(f,3*C,u,o),f.needsUpdate=!0;const z=f.distanceToTriangle(h,m,y);if(z<g&&(b.copy(m),p&&p.copy(y),g=z,w=I,x=M),z<r)return!0}}}})}else{const T=te(t);for(let B=0,_=T;B<_;B++){N(h,3*B,d,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let M=A,L=A+S;M<L;M++){const P=s.resolveTriangleIndex(M);N(f,3*P,u,o),f.needsUpdate=!0;const I=f.distanceToTriangle(h,m,y);if(I<g&&(b.copy(m),p&&p.copy(y),g=I,w=M,x=B),I<r)return!0}}}}}),Q.releasePrimitive(f),Q.releasePrimitive(h),g===1/0?null:(n.point?n.point.copy(b):n.point=b.clone(),n.distance=g,n.faceIndex=w,i&&(i.point?i.point.copy(p):i.point=p.clone(),i.point.applyMatrix4(Ue),b.applyMatrix4(Ue),i.distance=b.sub(i.point).length(),i.faceIndex=x),n)}function po(){return typeof SharedArrayBuffer<"u"}const he=new U.constructor,Xe=new U.constructor,Tt=new Zn(()=>new ct),qt=new ct,Zt=new ct,xn=new ct,An=new ct;let bn=!1;function ho(s,t,e,n){if(bn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");bn=!0;const i=s._roots,r=t._roots;let a,c=0,o=0;const u=new lt().copy(e).invert();for(let l=0,d=i.length;l<d;l++){he.setBuffer(i[l]),o=0;const f=Tt.getPrimitive();R(0,he.float32Array,f),f.applyMatrix4(u);for(let h=0,m=r.length;h<m&&(Xe.setBuffer(r[l]),a=it(0,0,e,u,n,c,o,0,0,f),Xe.clearBuffer(),o+=r[h].length,!a);h++);if(Tt.releasePrimitive(f),he.clearBuffer(),c+=i[l].length,a)break}return bn=!1,a}function it(s,t,e,n,i,r=0,a=0,c=0,o=0,u=null,l=!1){let d,f;l?(d=Xe,f=he):(d=he,f=Xe);const h=d.float32Array,m=d.uint32Array,b=d.uint16Array,y=f.float32Array,p=f.uint32Array,g=f.uint16Array,w=s*2,x=t*2,A=$(w,b),S=$(x,g);let T=!1;if(S&&A)l?T=i(W(t,p),Y(t*2,g),W(s,m),Y(s*2,b),o,a+t,c,r+s):T=i(W(s,m),Y(s*2,b),W(t,p),Y(t*2,g),c,r+s,o,a+t);else if(S){const B=Tt.getPrimitive();R(t,y,B),B.applyMatrix4(e);const _=J(s),M=K(s,m);R(_,h,qt),R(M,h,Zt);const L=B.intersectsBox(qt),P=B.intersectsBox(Zt);T=L&&it(t,_,n,e,i,a,r,o,c+1,B,!l)||P&&it(t,M,n,e,i,a,r,o,c+1,B,!l),Tt.releasePrimitive(B)}else{const B=J(t),_=K(t,p);R(B,y,xn),R(_,y,An);const M=u.intersectsBox(xn),L=u.intersectsBox(An);if(M&&L)T=it(s,B,e,n,i,r,a,c,o+1,u,l)||it(s,_,e,n,i,r,a,c,o+1,u,l);else if(M)if(A)T=it(s,B,e,n,i,r,a,c,o+1,u,l);else{const P=Tt.getPrimitive();P.copy(xn).applyMatrix4(e);const I=J(s),E=K(s,m);R(I,h,qt),R(E,h,Zt);const C=P.intersectsBox(qt),z=P.intersectsBox(Zt);T=C&&it(B,I,n,e,i,a,r,o,c+1,P,!l)||z&&it(B,E,n,e,i,a,r,o,c+1,P,!l),Tt.releasePrimitive(P)}else if(L)if(A)T=it(s,_,e,n,i,r,a,c,o+1,u,l);else{const P=Tt.getPrimitive();P.copy(An).applyMatrix4(e);const I=J(s),E=K(s,m);R(I,h,qt),R(E,h,Zt);const C=P.intersectsBox(qt),z=P.intersectsBox(Zt);T=C&&it(_,I,n,e,i,a,r,o,c+1,P,!l)||z&&it(_,E,n,e,i,a,r,o,c+1,P,!l),Tt.releasePrimitive(P)}}return T}const Re=new H,Ds=new ct,mo={strategy:mi,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0};class Yn{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,i=t._roots,r=t._indirectBuffer,a=n.getIndex();let c;return e.cloneBuffers?c={roots:i.map(o=>o.slice()),index:a.array.slice(),indirectBuffer:r?r.slice():null}:c={roots:i,index:a.array,indirectBuffer:r},c}static deserialize(t,e,n={}){n={setIndex:!0,indirect:!!t.indirectBuffer,...n};const{index:i,roots:r,indirectBuffer:a}=t,c=new Yn(e,{...n,[dn]:!0});if(c._roots=r,c._indirectBuffer=a||null,n.setIndex){const o=e.getIndex();if(o===null){const u=new Ye(t.index,1,!1);e.setIndex(u)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...mo,[dn]:!1},e),e.useSharedArrayBuffer&&!po())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[dn]||(vr(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new ct)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=e.indirect?i=>n[i]:i=>i}refit(t=null){return(this.indirect?no:$r)(this,t)}traverse(t,e=0){const n=this._roots[e],i=new Uint32Array(n),r=new Uint16Array(n);a(0);function a(c,o=0){const u=c*2,l=r[u+15]===Qe;if(l){const d=i[c+6],f=r[u+14];t(o,l,new Float32Array(n,c*4,6),d,f)}else{const d=c+pe/4,f=i[c+6],h=i[c+7];t(o,l,new Float32Array(n,c*4,6),h)||(a(d,o+1),a(f,o+1))}}}raycast(t,e=ws){const n=this._roots,i=this.geometry,r=[],a=e.isMaterial,c=Array.isArray(e),o=i.groups,u=a?e.side:e,l=this.indirect?so:Xr;for(let d=0,f=n.length;d<f;d++){const h=c?e[o[d].materialIndex].side:u,m=r.length;if(l(this,d,h,t,r),c){const b=o[d].materialIndex;for(let y=m,p=r.length;y<p;y++)r[y].face.materialIndex=b}}return r}raycastFirst(t,e=ws){const n=this._roots,i=this.geometry,r=e.isMaterial,a=Array.isArray(e);let c=null;const o=i.groups,u=r?e.side:e,l=this.indirect?ro:Zr;for(let d=0,f=n.length;d<f;d++){const h=a?e[o[d].materialIndex].side:u,m=l(this,d,h,t);m!=null&&(c==null||m.distance<c.distance)&&(c=m,a&&(m.face.materialIndex=o[d].materialIndex))}return c}intersectsGeometry(t,e){let n=!1;const i=this._roots,r=this.indirect?oo:Yr;for(let a=0,c=i.length;a<c&&(n=r(this,a,t,e),!n);a++);return n}shapecast(t){const e=Q.getPrimitive(),n=this.indirect?Wr:Hr;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const d=a;a=(f,h,m,b,y)=>d(f,h,m,b,y)?!0:n(f,h,this,c,m,b,e)}else a||(c?a=(d,f,h,m)=>n(d,f,this,c,h,m,e):a=(d,f,h)=>h);let o=!1,u=0;const l=this._roots;for(let d=0,f=l.length;d<f;d++){const h=l[d];if(o=Rr(this,d,r,a,i,u),o)break;u+=h.byteLength}return Q.releasePrimitive(e),o}bvhcast(t,e,n){let{intersectsRanges:i,intersectsTriangles:r}=n;const a=Q.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,u=this.indirect?m=>{const b=this.resolveTriangleIndex(m);N(a,b*3,c,o)}:m=>{N(a,m*3,c,o)},l=Q.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?m=>{const b=t.resolveTriangleIndex(m);N(l,b*3,d,f)}:m=>{N(l,m*3,d,f)};if(r){const m=(b,y,p,g,w,x,A,S)=>{for(let T=p,B=p+g;T<B;T++){h(T),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let _=b,M=b+y;_<M;_++)if(u(_),a.needsUpdate=!0,r(a,l,_,T,w,x,A,S))return!0}return!1};if(i){const b=i;i=function(y,p,g,w,x,A,S,T){return b(y,p,g,w,x,A,S,T)?!0:m(y,p,g,w,x,A,S,T)}}else i=m}return ho(this,t,e,i)}intersectsBox(t,e){return Re.set(t.min,t.max,e),Re.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Re.intersectsBox(n),intersectsTriangle:n=>Re.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},i={},r=0,a=1/0){return(this.indirect?fo:eo)(this,t,e,n,i,r,a)}closestPointToPoint(t,e={},n=0,i=1/0){return Fr(this,t,e,n,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{R(0,new Float32Array(n),Ds),t.union(Ds)}),t}}const bi=1e-6,go=bi*.5,Ti=Math.pow(10,-Math.log10(bi)),yo=go*Ti;function at(s){return~~(s*Ti+yo)}function wo(s){return`${at(s.x)},${at(s.y)}`}function ks(s){return`${at(s.x)},${at(s.y)},${at(s.z)}`}function xo(s){return`${at(s.x)},${at(s.y)},${at(s.z)},${at(s.w)}`}function Ao(s,t,e){e.direction.subVectors(t,s).normalize();const n=s.dot(e.direction);return e.origin.copy(s).addScaledVector(e.direction,-n),e}function Si(){return typeof SharedArrayBuffer<"u"}function bo(s){if(s.buffer instanceof SharedArrayBuffer)return s;const t=s.constructor,e=s.buffer,n=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(n).set(i,0),new t(n)}function To(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function So(s,t){if(!s.index){const e=s.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=To(e,n);s.setIndex(new Ye(i,1));for(let r=0;r<e;r++)i[r]=r}}function Bo(s){return s.index?s.index.count:s.attributes.position.count}function Jn(s){return Bo(s)/3}const _o=1e-8,Po=new v;function Mo(s){return~~(s/3)}function Io(s){return s%3}function js(s,t){return s.start-t.start}function Hs(s,t){return Po.subVectors(t,s.origin).dot(s.direction)}function Lo(s,t,e,n=_o){s.sort(js),t.sort(js);for(let c=0;c<s.length;c++){const o=s[c];for(let u=0;u<t.length;u++){const l=t[u];if(!(l.start>o.end)){if(o.end<l.start||l.end<o.start)continue;if(o.start<=l.start&&o.end>=l.end)r(l.end,o.end)||s.splice(c+1,0,{start:l.end,end:o.end,index:o.index}),o.end=l.start,l.start=0,l.end=0;else if(o.start>=l.start&&o.end<=l.end)r(o.end,l.end)||t.splice(u+1,0,{start:o.end,end:l.end,index:l.index}),l.end=o.start,o.start=0,o.end=0;else if(o.start<=l.start&&o.end<=l.end){const d=o.end;o.end=l.start,l.start=d}else if(o.start>=l.start&&o.end>=l.end){const d=l.end;l.end=o.start,o.start=d}else throw new Error}if(e.has(o.index)||e.set(o.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(o.index).push(l.index),e.get(l.index).push(o.index),a(l)&&(t.splice(u,1),u--),a(o)){s.splice(c,1),c--;break}}}i(s),i(t);function i(c){for(let o=0;o<c.length;o++)a(c[o])&&(c.splice(o,1),o--)}function r(c,o){return Math.abs(o-c)<n}function a(c){return Math.abs(c.end-c.start)<n}}const $s=1e-5,Os=1e-4;class vo{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let i=1/0,r=null;for(let o=0,u=e.length;o<u;o++){const l=e[o];if(a(l,t)&&a(l,n))continue;const d=c(l,t),f=c(l,n),h=Math.min(d,f);h<i&&(i=h,r=l)}return r;function a(o,u){const l=o.origin.distanceTo(u.origin)>$s;return o.direction.angleTo(u.direction)>Os||l}function c(o,u){const l=o.origin.distanceTo(u.origin),d=o.direction.angleTo(u.direction);return l/$s+d/Os}}}const Tn=new v,Sn=new v,Fe=new ai;function Eo(s,t,e){const n=s.attributes,i=s.index,r=n.position,a=new Map,c=new Map,o=Array.from(t),u=new vo;for(let l=0,d=o.length;l<d;l++){const f=o[l],h=Mo(f),m=Io(f);let b=3*h+m,y=3*h+(m+1)%3;i&&(b=i.getX(b),y=i.getX(y)),Tn.fromBufferAttribute(r,b),Sn.fromBufferAttribute(r,y),Ao(Tn,Sn,Fe);let p,g=u.findClosestRay(Fe);g===null&&(g=Fe.clone(),u.addRay(g)),c.has(g)||c.set(g,{forward:[],reverse:[],ray:g}),p=c.get(g);let w=Hs(g,Tn),x=Hs(g,Sn);w>x&&([w,x]=[x,w]),Fe.direction.dot(g.direction)<0?p.reverse.push({start:w,end:x,index:f}):p.forward.push({start:w,end:x,index:f})}return c.forEach(({forward:l,reverse:d},f)=>{Lo(l,d,a,e),l.length===0&&d.length===0&&c.delete(f)}),{disjointConnectivityMap:a,fragmentMap:c}}const Co=new Ut,Bn=new v,zo=new Rt,_n=["","",""];class Vo{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[t*3+e];return n===-1?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=t*3+e,i=this.disjointConnections.get(n);return i?i.map(r=>~~(r/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=t*3+e,i=this.disjointConnections.get(n);return i?i.map(r=>r%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:i,degenerateEpsilon:r}=this,a=e?w:g,c=new Map,{attributes:o}=t,u=e?Object.keys(o):null,l=t.index,d=o.position;let f=Jn(t);const h=f;let m=0;n&&(m=t.drawRange.start,t.drawRange.count!==1/0&&(f=~~(t.drawRange.count/3)));let b=this.data;(!b||b.length<3*h)&&(b=new Int32Array(3*h)),b.fill(-1);let y=0,p=new Set;for(let x=m,A=f*3+m;x<A;x+=3){const S=x;for(let T=0;T<3;T++){let B=S+T;l&&(B=l.getX(B)),_n[T]=a(B)}for(let T=0;T<3;T++){const B=(T+1)%3,_=_n[T],M=_n[B],L=`${M}_${_}`;if(c.has(L)){const P=S+T,I=c.get(L);b[P]=I,b[I]=P,c.delete(L),y+=2,p.delete(I)}else{const P=`${_}_${M}`,I=S+T;c.set(P,I),p.add(I)}}}if(i){const{fragmentMap:x,disjointConnectivityMap:A}=Eo(t,p,r);p.clear(),x.forEach(({forward:S,reverse:T})=>{S.forEach(({index:B})=>p.add(B)),T.forEach(({index:B})=>p.add(B))}),this.unmatchedDisjointEdges=x,this.disjointConnections=A,y=f*3-p.size}this.matchedEdges=y,this.unmatchedEdges=p.size,this.data=b;function g(x){return Bn.fromBufferAttribute(d,x),ks(Bn)}function w(x){let A="";for(let S=0,T=u.length;S<T;S++){const B=o[u[S]];let _;switch(B.itemSize){case 1:_=at(B.getX(x));break;case 2:_=wo(Co.fromBufferAttribute(B,x));break;case 3:_=ks(Bn.fromBufferAttribute(B,x));break;case 4:_=xo(zo.fromBufferAttribute(B,x));break}A!==""&&(A+="|"),A+=_}return A}}}class nt extends Jt{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new lt,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,i=e.elements;for(let r=0;r<16;r++)if(n[r]!==i[r])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=Si();if(n)for(const i in e){const r=e[i];if(r.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");r.array=bo(r.array)}if(t.boundsTree||(So(t,{useSharedArrayBuffer:n}),t.boundsTree=new Yn(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Vo(t)),!t.groupIndices){const i=Jn(t),r=new Uint16Array(i),a=t.groups;for(let c=0,o=a.length;c<o;c++){const{start:u,count:l}=a[c];for(let d=u/3,f=(u+l)/3;d<f;d++)r[d]=c}t.groupIndices=r}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Uo=1e-14,Pn=new v,Gs=new v,Ws=new v;function St(s,t=Uo){Pn.subVectors(s.b,s.a),Gs.subVectors(s.c,s.a),Ws.subVectors(s.b,s.c);const e=Pn.angleTo(Gs),n=Pn.angleTo(Ws),i=Math.PI-e-n;return Math.abs(e)<t||Math.abs(n)<t||Math.abs(i)<t||s.a.distanceToSquared(s.b)<t||s.a.distanceToSquared(s.c)<t||s.b.distanceToSquared(s.c)<t}const Mn=1e-10,fe=1e-10,Ro=1e-10,pt=new tt,F=new tt,ht=new v,In=new v,Xs=new v,Ne=new Gn,Ln=new et;class Fo{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new G),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class No{constructor(){this.trianglePool=new Fo,this.triangles=[],this.normal=new v,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:i}=this;if(Array.isArray(t))for(let r=0,a=t.length;r<a;r++){const c=t[r];if(r===0)c.getNormal(i);else if(Math.abs(1-c.getNormal(ht).dot(i))>Mn)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const o=n.getTriangle();o.copy(c),e.push(o)}else{t.getNormal(i);const r=n.getTriangle();r.copy(t),e.push(r)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(In).normalize(),Math.abs(1-Math.abs(In.dot(e)))<Ro){this.coplanarTriangleUsed=!0;for(let r=0,a=n.length;r<a;r++){const c=n[r];c.coplanarCount=0}const i=[t.a,t.b,t.c];for(let r=0;r<3;r++){const a=(r+1)%3,c=i[r],o=i[a];ht.subVectors(o,c).normalize(),Xs.crossVectors(In,ht),Ne.setFromNormalAndCoplanarPoint(Xs,c),this.splitByPlane(Ne,t)}}else t.getPlane(Ne),this.splitByPlane(Ne,t)}splitByPlane(t,e){const{triangles:n,trianglePool:i}=this;Ln.copy(e),Ln.needsUpdate=!0;for(let r=0,a=n.length;r<a;r++){const c=n[r];if(!Ln.intersectsTriangle(c,pt,!0))continue;const{a:o,b:u,c:l}=c;let d=0,f=-1,h=!1,m=[],b=[];const y=[o,u,l];for(let p=0;p<3;p++){const g=(p+1)%3;pt.start.copy(y[p]),pt.end.copy(y[g]);const w=t.distanceToPoint(pt.start),x=t.distanceToPoint(pt.end);if(Math.abs(w)<fe&&Math.abs(x)<fe){h=!0;break}if(w>0?m.push(p):b.push(p),Math.abs(w)<fe)continue;let A=!!t.intersectLine(pt,ht);!A&&Math.abs(x)<fe&&(ht.copy(pt.end),A=!0),A&&!(ht.distanceTo(pt.start)<Mn)&&(ht.distanceTo(pt.end)<Mn&&(f=p),d===0?F.start.copy(ht):F.end.copy(ht),d++)}if(!h&&d===2&&F.distance()>fe)if(f!==-1){f=(f+1)%3;let p=0;p===f&&(p=(p+1)%3);let g=p+1;g===f&&(g=(g+1)%3);const w=i.getTriangle();w.a.copy(y[g]),w.b.copy(F.end),w.c.copy(F.start),St(w)||n.push(w),c.a.copy(y[p]),c.b.copy(F.start),c.c.copy(F.end),St(c)&&(n.splice(r,1),r--,a--)}else{const p=m.length>=2?b[0]:m[0];if(p===0){let S=F.start;F.start=F.end,F.end=S}const g=(p+1)%3,w=(p+2)%3,x=i.getTriangle(),A=i.getTriangle();y[g].distanceToSquared(F.start)<y[w].distanceToSquared(F.end)?(x.a.copy(y[g]),x.b.copy(F.start),x.c.copy(F.end),A.a.copy(y[g]),A.b.copy(y[w]),A.c.copy(F.start)):(x.a.copy(y[w]),x.b.copy(F.start),x.c.copy(F.end),A.a.copy(y[g]),A.b.copy(y[w]),A.c.copy(F.end)),c.a.copy(y[p]),c.b.copy(F.end),c.c.copy(F.start),St(x)||n.push(x),St(A)||n.push(A),St(c)&&(n.splice(r,1),r--,a--)}else d===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function Do(s){return s=~~s,s+4-s%4}class qs{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=Si()?SharedArrayBuffer:ArrayBuffer,i=new e(new n(Do(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,r=t.length;i<r;i++)e[n+i]=t[i];this.length+=t.length}clear(){this.length=0}}class ko{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let i=0;for(let r=0;r<e;r++){const a=n[r];i+=a[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const r in n){const a=n[r],c=new qs(a.type);c.itemSize=a.itemSize,c.normalized=a.normalized,i[r]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,i){const{groupAttributes:r}=this,c=r[0][t];if(c){if(c.type!==e)for(let o=0,u=r.length;o<u;o++){const l=r[o][t];l.setType(e),l.itemSize=n,l.normalized=i}}else for(let o=0,u=r.length;o<u;o++){const l=new qs(e);l.itemSize=n,l.normalized=i,r[o][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const n in e)e[n].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Zs{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:i}=this;n[t]||(n[t]=[],i.push(t)),n[t].push(e)}}const Mt=0,Kn=1,jo=2,Ho=3,$o=4,Bi=5,_i=6,Z=new ai,Ys=new lt,k=new G,mt=new v,Js=new Rt,Ks=new Rt,Qs=new Rt,vn=new Rt,De=new Rt,ke=new Rt,ti=new tt,En=new v,Cn=1e-8,Oo=1e-15,Et=-1,Ct=1,Oe=-2,Ge=2,me=0,Lt=1,Qn=2,Go=1e-14;let We=null;function ei(s){We=s}function Pi(s,t){s.getMidpoint(Z.origin),s.getNormal(Z.direction);const e=t.raycastFirst(Z,Wn);return!!(e&&Z.direction.dot(e.face.normal)>0)?Et:Ct}function Wo(s,t){function e(){return Math.random()-.5}s.getNormal(En),Z.direction.copy(En),s.getMidpoint(Z.origin);const n=3;let i=0,r=1/0;for(let a=0;a<n;a++){Z.direction.x+=e()*Cn,Z.direction.y+=e()*Cn,Z.direction.z+=e()*Cn,Z.direction.multiplyScalar(-1);const c=t.raycastFirst(Z,Wn);if(!!(c&&Z.direction.dot(c.face.normal)>0)&&i++,c!==null&&(r=Math.min(r,c.distance)),r<=Oo)return c.face.normal.dot(En)>0?Ge:Oe;if(i/n>.5||(a-i+1)/n>.5)break}return i/n>.5?Et:Ct}function Xo(s,t){const e=new Zs,n=new Zs;return Ys.copy(s.matrixWorld).invert().multiply(t.matrixWorld),s.geometry.boundsTree.bvhcast(t.geometry.boundsTree,Ys,{intersectsTriangles(i,r,a,c){if(!St(i)&&!St(r)){let o=i.intersectsTriangle(r,ti,!0);if(!o){const u=i.plane,l=r.plane,d=u.normal,f=l.normal;d.dot(f)===1&&Math.abs(u.constant-l.constant)<Go&&(o=!0)}if(o){let u=s.geometry.boundsTree.resolveTriangleIndex(a),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(u,l),n.add(l,u),We&&(We.addEdge(ti),We.addIntersectingTriangles(a,i,c,r))}}return!1}}),{aIntersections:e,bIntersections:n}}function qo(s,t,e,n,i,r,a=!1){const c=e.attributes,o=e.index,u=s*3,l=o.getX(u+0),d=o.getX(u+1),f=o.getX(u+2);for(const h in r){const m=c[h],b=r[h];if(!(h in c))throw new Error(`CSG Operations: Attribute ${h} not available on geometry.`);const y=m.itemSize;h==="position"?(k.a.fromBufferAttribute(m,l).applyMatrix4(n),k.b.fromBufferAttribute(m,d).applyMatrix4(n),k.c.fromBufferAttribute(m,f).applyMatrix4(n),zn(k.a,k.b,k.c,t,3,b,a)):h==="normal"?(k.a.fromBufferAttribute(m,l).applyNormalMatrix(i),k.b.fromBufferAttribute(m,d).applyNormalMatrix(i),k.c.fromBufferAttribute(m,f).applyNormalMatrix(i),a&&(k.a.multiplyScalar(-1),k.b.multiplyScalar(-1),k.c.multiplyScalar(-1)),zn(k.a,k.b,k.c,t,3,b,a,!0)):(Js.fromBufferAttribute(m,l),Ks.fromBufferAttribute(m,d),Qs.fromBufferAttribute(m,f),zn(Js,Ks,Qs,t,y,b,a))}}function Zo(s,t,e,n,i,r,a,c=!1){Vn(s,n,i,r,a,c),Vn(c?e:t,n,i,r,a,c),Vn(c?t:e,n,i,r,a,c)}function Mi(s,t,e=!1){switch(s){case Mt:if(t===Ct||t===Ge&&!e)return Lt;break;case Kn:if(e){if(t===Et)return me}else if(t===Ct||t===Oe)return Lt;break;case jo:if(e){if(t===Ct||t===Oe)return Lt}else if(t===Et)return me;break;case $o:if(t===Et)return me;if(t===Ct)return Lt;break;case Ho:if(t===Et||t===Ge&&!e)return Lt;break;case Bi:if(!e&&(t===Ct||t===Oe))return Lt;break;case _i:if(!e&&(t===Et||t===Ge))return Lt;break;default:throw new Error(`Unrecognized CSG operation enum "${s}".`)}return Qn}function zn(s,t,e,n,i,r,a=!1,c=!1){const o=u=>{r.push(u.x),i>1&&r.push(u.y),i>2&&r.push(u.z),i>3&&r.push(u.w)};vn.set(0,0,0,0).addScaledVector(s,n.a.x).addScaledVector(t,n.a.y).addScaledVector(e,n.a.z),De.set(0,0,0,0).addScaledVector(s,n.b.x).addScaledVector(t,n.b.y).addScaledVector(e,n.b.z),ke.set(0,0,0,0).addScaledVector(s,n.c.x).addScaledVector(t,n.c.y).addScaledVector(e,n.c.z),c&&(vn.normalize(),De.normalize(),ke.normalize()),o(vn),a?(o(ke),o(De)):(o(De),o(ke))}function Vn(s,t,e,n,i,r=!1){for(const a in i){const c=t[a],o=i[a];if(!(a in t))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const u=c.itemSize;a==="position"?(mt.fromBufferAttribute(c,s).applyMatrix4(e),o.push(mt.x,mt.y,mt.z)):a==="normal"?(mt.fromBufferAttribute(c,s).applyNormalMatrix(n),r&&mt.multiplyScalar(-1),o.push(mt.x,mt.y,mt.z)):(o.push(c.getX(s)),u>1&&o.push(c.getY(s)),u>2&&o.push(c.getZ(s)),u>3&&o.push(c.getW(s)))}}class Yo{constructor(t){this.triangle=new G().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new G().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class ni{constructor(){this.data={}}addTriangleIntersection(t,e,n,i){const{data:r}=this;r[t]||(r[t]=new Yo(e)),r[t].addTriangle(n,i)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(t!==null)t in e&&n.push(e[t].triangle);else for(const i in e)n.push(e[i].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(n=>parseInt(n)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,i=new Set,r=[],a=c=>{if(n[c])if(e!==null)n[c].intersects[e]&&r.push(n[c].intersects[e]);else{const o=n[c].intersects;for(const u in o)i.has(u)||(i.add(u),r.push(o[u]))}};if(t!==null)a(t);else for(const c in n)a(c);return r}reset(){this.data={}}}class Jo{constructor(){this.enabled=!1,this.triangleIntersectsA=new ni,this.triangleIntersectsB=new ni,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,i){const{triangleIntersectsA:r,triangleIntersectsB:a}=this;r.addTriangleIntersection(t,e,n,i),a.addTriangleIntersection(n,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),ei(this))}complete(){this.enabled&&ei(null)}}const _t=new lt,qe=new er,vt=new G,je=new G,bt=new G,He=new G,rt=[],Vt=[];function Ko(s){for(const t of s)return t}function Qo(s,t,e,n,i,r={}){const{useGroups:a=!0}=r,{aIntersections:c,bIntersections:o}=Xo(s,t),u=[];let l=null,d;return d=a?0:-1,si(s,t,c,e,!1,n,i,d),ii(s,t,c,e,!1,i,d),e.findIndex(h=>h!==_i&&h!==Bi)!==-1&&(d=a?s.geometry.groups.length||1:-1,si(t,s,o,e,!0,n,i,d),ii(t,s,o,e,!0,i,d)),rt.length=0,Vt.length=0,{groups:u,materials:l}}function si(s,t,e,n,i,r,a,c=0){const o=s.matrixWorld.determinant()<0;_t.copy(t.matrixWorld).invert().multiply(s.matrixWorld),qe.getNormalMatrix(s.matrixWorld).multiplyScalar(o?-1:1);const u=s.geometry.groupIndices,l=s.geometry.index,d=s.geometry.attributes.position,f=t.geometry.boundsTree,h=t.geometry.index,m=t.geometry.attributes.position,b=e.ids,y=e.intersectionSet;for(let p=0,g=b.length;p<g;p++){const w=b[p],x=c===-1?0:u[w]+c,A=3*w,S=l.getX(A+0),T=l.getX(A+1),B=l.getX(A+2);vt.a.fromBufferAttribute(d,S).applyMatrix4(_t),vt.b.fromBufferAttribute(d,T).applyMatrix4(_t),vt.c.fromBufferAttribute(d,B).applyMatrix4(_t),r.reset(),r.initialize(vt);const _=y[w];for(let L=0,P=_.length;L<P;L++){const I=3*_[L],E=h.getX(I+0),C=h.getX(I+1),z=h.getX(I+2);je.a.fromBufferAttribute(m,E),je.b.fromBufferAttribute(m,C),je.c.fromBufferAttribute(m,z),r.splitByTriangle(je)}const M=r.triangles;for(let L=0,P=M.length;L<P;L++){const I=M[L],E=r.coplanarTriangleUsed?Wo(I,f):Pi(I,f);rt.length=0,Vt.length=0;for(let C=0,z=n.length;C<z;C++){const D=Mi(n[C],E,i);D!==Qn&&(Vt.push(D),rt.push(a[C].getGroupAttrSet(x)))}if(rt.length!==0){vt.getBarycoord(I.a,He.a),vt.getBarycoord(I.b,He.b),vt.getBarycoord(I.c,He.c);for(let C=0,z=rt.length;C<z;C++){const D=rt[C],It=Vt[C]===me;qo(w,He,s.geometry,s.matrixWorld,qe,D,o!==It)}}}}return b.length}function ii(s,t,e,n,i,r,a=0){const c=s.matrixWorld.determinant()<0;_t.copy(t.matrixWorld).invert().multiply(s.matrixWorld),qe.getNormalMatrix(s.matrixWorld).multiplyScalar(c?-1:1);const o=t.geometry.boundsTree,u=s.geometry.groupIndices,l=s.geometry.index,d=s.geometry.attributes,f=d.position,h=[],m=s.geometry.halfEdges,b=new Set,y=Jn(s.geometry);for(let p=0,g=y;p<g;p++)p in e.intersectionSet||b.add(p);for(;b.size>0;){const p=Ko(b);b.delete(p),h.push(p);const g=3*p,w=l.getX(g+0),x=l.getX(g+1),A=l.getX(g+2);bt.a.fromBufferAttribute(f,w).applyMatrix4(_t),bt.b.fromBufferAttribute(f,x).applyMatrix4(_t),bt.c.fromBufferAttribute(f,A).applyMatrix4(_t);const S=Pi(bt,o);Vt.length=0,rt.length=0;for(let T=0,B=n.length;T<B;T++){const _=Mi(n[T],S,i);_!==Qn&&(Vt.push(_),rt.push(r[T]))}for(;h.length>0;){const T=h.pop();for(let B=0;B<3;B++){const _=m.getSiblingTriangleIndex(T,B);_!==-1&&b.has(_)&&(h.push(_),b.delete(_))}if(rt.length!==0){const B=3*T,_=l.getX(B+0),M=l.getX(B+1),L=l.getX(B+2),P=a===-1?0:u[T]+a;if(bt.a.fromBufferAttribute(f,_),bt.b.fromBufferAttribute(f,M),bt.c.fromBufferAttribute(f,L),!St(bt))for(let I=0,E=rt.length;I<E;I++){const C=Vt[I],z=rt[I].getGroupAttrSet(P),D=C===me;Zo(_,M,L,d,s.matrixWorld,qe,z,D!==c)}}}}}function tc(s){for(let t=0;t<s.length-1;t++){const e=s[t],n=s[t+1];if(e.materialIndex===n.materialIndex){const i=e.start,r=n.start+n.count;n.start=i,n.count=r-i,s.splice(t,1),t--}}}function ec(s,t,e,n){e.clear();const i=s.attributes;for(let r=0,a=n.length;r<a;r++){const c=n[r],o=i[c];e.initializeArray(c,o.array.constructor,o.itemSize,o.normalized)}for(const r in e.attributes)n.includes(r)||e.delete(r);for(const r in t.attributes)n.includes(r)||(t.deleteAttribute(r),t.dispose())}function nc(s,t,e){let n=!1,i=-1;const r=s.attributes,a=t.groupAttributes[0];for(const o in a){const u=t.getTotalLength(o),l=t.getType(o),d=t.getItemSize(o),f=t.getNormalized(o);let h=r[o];(!h||h.array.length<u)&&(h=new Ye(new l(u),d,f),s.setAttribute(o,h),n=!0);let m=0;for(let b=0,y=Math.min(e.length,t.groupCount);b<y;b++){const p=e[b].index,{array:g,type:w,length:x}=t.groupAttributes[p][o],A=new w(g.buffer,0,x);h.array.set(A,m),m+=A.length}h.needsUpdate=!0,i=u/h.itemSize}if(s.index){const o=s.index.array;if(o.length<i)s.index=null,n=!0;else for(let u=0,l=o.length;u<l;u++)o[u]=u}let c=0;s.clearGroups();for(let o=0,u=Math.min(e.length,t.groupCount);o<u;o++){const{index:l,materialIndex:d}=e[o],f=t.getCount(l);f!==0&&(s.addGroup(c,f,d),c+=f)}s.setDrawRange(0,i),s.boundsTree=null,n&&s.dispose()}function ri(s,t){let e=t;return Array.isArray(t)||(e=[],s.forEach(n=>{e[n.materialIndex]=t})),e}class Ii{constructor(){this.triangleSplitter=new No,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Jo}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,n,i=new nt){let r=!0;if(Array.isArray(n)||(n=[n]),Array.isArray(i)||(i=[i],r=!1),i.length!==n.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:a,attributeData:c,attributes:o,useGroups:u,consolidateGroups:l,debug:d}=this;for(;c.length<i.length;)c.push(new ko);i.forEach((p,g)=>{ec(t.geometry,p.geometry,c[g],o)}),d.init(),Qo(t,e,n,a,c,{useGroups:u}),d.complete();const f=this.getGroupRanges(t.geometry),h=ri(f,t.material),m=this.getGroupRanges(e.geometry),b=ri(m,e.material);m.forEach(p=>p.materialIndex+=h.length);let y=[...f,...m].map((p,g)=>({...p,index:g}));if(u){const p=[...h,...b];l&&(y=y.map(w=>{const x=p[w.materialIndex];return w.materialIndex=p.indexOf(x),w}).sort((w,x)=>w.materialIndex-x.materialIndex));const g=[];for(let w=0,x=p.length;w<x;w++){let A=!1;for(let S=0,T=y.length;S<T;S++){const B=y[S];B.materialIndex===w&&(A=!0,B.materialIndex=g.length)}A&&g.push(p[w])}i.forEach(w=>{w.material=g})}else y=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(p=>{p.material=h[0]});return i.forEach((p,g)=>{const w=p.geometry;nc(w,c[g],y),l&&tc(w.groups)}),r?i:i[0]}evaluateHierarchy(t,e=new nt){t.updateMatrixWorld(!0);const n=(r,a)=>{const c=r.children;for(let o=0,u=c.length;o<u;o++){const l=c[o];l.isOperationGroup?n(l,a):a(l)}},i=r=>{const a=r.children;let c=!1;for(let u=0,l=a.length;u<l;u++){const d=a[u];c=i(d)||c}const o=r.isDirty();if(o&&r.markUpdated(),c&&!r.isOperationGroup){let u;return n(r,l=>{u?u=this.evaluate(u,l,l.operation):u=this.evaluate(r,l,l.operation)}),r._cachedGeometry=u.geometry,r._cachedMaterials=u.material,!0}else return c||o};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}const{frameThickness:ts,frameWidthOuter:Li,frameHeightOuter:vi,slatWidth:Kt,x:sc,y:ic,frameWidthInner:Ei,frameHeightInner:Ci}=zt,ee=new Je({roughness:.5,metalness:.7,wireframe:we,color:34918}),zi=new nt(new Ze(Li,vi,ts),ee);zi.updateMatrixWorld();const Vi=new nt(new Ze(Ei,Ci,ts),ee);Vi.updateMatrixWorld();const Ae=new Ii,rc=Ae.evaluate(zi,Vi,Kn),es=new nt(new ut(Ei+1,Kt*2,Kt*2,O.roundSegments,O.roundRadius),ee);es.position.set(0,-2.2,0);es.updateMatrixWorld();const ns=new nt(new ut(.6,Ci+1,.6,O.roundSegments,O.roundRadius),ee);ns.position.set(0,0,0);ns.updateMatrixWorld();let ye=Ae.evaluate(es,ns,Mt);const ss=new nt(new ut(Kt,13.4,Kt,O.roundSegments,O.roundRadius),ee);ss.position.set(-8.2,4.6,0);ss.updateMatrixWorld();ye=Ae.evaluate(ye,ss,Mt);const is=new nt(new ut(Kt,13.4,Kt,O.roundSegments,O.roundRadius),ee);is.position.set(8.2,4.6,0);is.updateMatrixWorld();ye=Ae.evaluate(ye,is,Mt);const rs=Ae.evaluate(rc,ye,Mt);rs.position.set(Li/2+sc,vi/2+ic,-(O.wallThickness-ts/2));rs.updateMatrixWorld();const{floorXLength:ft,floorZLength:dt,wallHeight:xt,wallThickness:V,roundRadius:ne,roundSegments:se,ny:oc}=O,en=new Ii,os=new Je({roughness:1,metalness:0,wireframe:we,transparent:!0,opacity:0}),cc=new ut(ft+1,V,dt+1,se,ne),ac=new Je({roughness:1,metalness:0,wireframe:we}),cs=new nt(cc,ac);cs.position.set(ft/2-1/2,-V/2,dt/2-1/2);cs.updateMatrixWorld();const as=new Je({roughness:1,metalness:0,wireframe:we}),lc=new ut(V,xt,dt+1,se,ne),ls=new nt(lc,as);ls.position.set(-V/2,xt/2-V,dt/2-1/2);ls.updateMatrixWorld();const uc=new ut(ft+V,xt,V,se,ne),us=new nt(uc,as);us.position.set(ft/2-V/2,xt/2-V,-V/2);us.updateMatrixWorld();const fc=new Ze(zt.frameWidthOuter,zt.frameHeightOuter,V),fs=new nt(fc,as);fs.position.set(zt.frameWidthOuter/2+zt.x,zt.frameHeightOuter/2+zt.y,-V/2);fs.updateMatrixWorld();const Ui=en.evaluate(us,fs,Kn);Ui.updateMatrixWorld();const nn=en.evaluate(Ui,rs,Mt);nn.receiveShadow=!0;nn.castShadow=!0;nn.updateMatrixWorld();const dc=new ut(ft+V+V,xt,V,se,ne),sn=new Jt(dc,os);sn.position.set(ft/2,xt/2-V,dt+V/2);sn.receiveShadow=!0;sn.castShadow=!0;const pc=new ut(V,xt,dt+V,se,ne),rn=new Jt(pc,os);rn.position.set(ft+V/2,xt/2-V,dt/2-V/2);rn.receiveShadow=!0;rn.castShadow=!0;const hc=new ut(ft+V+V,V,dt+V+V,se,ne),on=new Jt(hc,os);on.position.set(ft/2,xt-V/2,dt/2);on.receiveShadow=!0;on.castShadow=!0;const Ft=new On;Ft.position.set(-ft/2,-oc,-dt/2);let Qt=en.evaluate(ls,nn,Mt);Qt.updateMatrixWorld();Qt=en.evaluate(Qt,cs,Mt);Qt.castShadow=!0;Qt.receiveShadow=!0;Ft.add(Qt);Ft.add(sn);Ft.add(rn);Ft.add(on);st.add(Ft);const ds=new nr(Ft);ds.visible=!1;st.add(ds);const mc=new sr,Ri=()=>{xs.begin(),ot.clear(),ds.update(),Xn.update();const s=mc.getDelta();un.animating&&un.update(s),ot.render(st,xe),un.render(ot),xs.end(),requestAnimationFrame(Ri)},{floorXLength:gc,floorZLength:yc,ny:wc}=O,ps=new ir(42);ps.position.set(-gc/2,-wc,-yc/2);ps.visible=!1;st.add(ps);const{floorXLength:xc,floorZLength:Ac,ny:bc}=O,hs=new On;hs.position.set(-xc/2,-bc,-Ac/2);const Tc=rr({title:"Sofa"}),Sc=new dr(Tc);Sc.load("https://cdn.jsdelivr.net/gh/Gaohaoyang/pics/models/sofa/ikeaSofa.obj",s=>{s.scale.set(10,10,10),s.rotation.y=-Math.PI/2,s.position.set(33,0,15);const e=s.children[0],n=s.children[1];oi(e),oi(n),hs.add(s)});const oi=s=>{s.castShadow=!0,s.receiveShadow=!0,s.material.wireframe=we};st.add(hs);Ri();or(ge,xe,ot);Ke.add(Xn,"autoRotate");

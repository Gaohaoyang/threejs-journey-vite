import"./modulepreload-polyfill-B5Qt9EMX.js";import{v as k,aP as ht,G as pt,P as ut,W as wt,O as ft,S as yt,c as dt,s as $,b as mt,aQ as gt,p as bt,aR as vt,aS as xt,A as zt,Z as Mt,B as j,u as Pt,aT as kt,M as P,a as Y,a3 as At,l as Nt}from"./OrbitControls-B8svhPLs.js";const L=new k;function v(T,t,e,s,n,o){const c=2*Math.PI*n/4,w=Math.max(o-2*n,0),i=Math.PI/4;L.copy(t),L[s]=0,L.normalize();const l=.5*c/(c+w),p=1-L.angleTo(T)/i;return Math.sign(L[e])===1?p*l:w/(c+w)+l+l*(1-p)}class N extends ht{constructor(t=1,e=1,s=1,n=2,o=.1){if(n=n*2+1,o=Math.min(t/2,e/2,s/2,o),super(1,1,1,n,n,n),n===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const w=new k,i=new k,l=new k(t,e,s).divideScalar(2).subScalar(o),p=this.attributes.position.array,d=this.attributes.normal.array,u=this.attributes.uv.array,a=p.length/6,r=new k,f=.5/n;for(let h=0,y=0;h<p.length;h+=3,y+=2)switch(w.fromArray(p,h),i.copy(w),i.x-=Math.sign(i.x)*f,i.y-=Math.sign(i.y)*f,i.z-=Math.sign(i.z)*f,i.normalize(),p[h+0]=l.x*Math.sign(w.x)+i.x*o,p[h+1]=l.y*Math.sign(w.y)+i.y*o,p[h+2]=l.z*Math.sign(w.z)+i.z*o,d[h+0]=i.x,d[h+1]=i.y,d[h+2]=i.z,Math.floor(h/a)){case 0:r.set(1,0,0),u[y+0]=v(r,i,"z","y",o,s),u[y+1]=1-v(r,i,"y","z",o,e);break;case 1:r.set(-1,0,0),u[y+0]=1-v(r,i,"z","y",o,s),u[y+1]=1-v(r,i,"y","z",o,e);break;case 2:r.set(0,1,0),u[y+0]=1-v(r,i,"x","z",o,t),u[y+1]=v(r,i,"z","x",o,s);break;case 3:r.set(0,-1,0),u[y+0]=1-v(r,i,"x","z",o,t),u[y+1]=1-v(r,i,"z","x",o,s);break;case 4:r.set(0,0,1),u[y+0]=1-v(r,i,"x","y",o,t),u[y+1]=1-v(r,i,"y","x",o,e);break;case 5:r.set(0,0,-1),u[y+0]=v(r,i,"x","y",o,t),u[y+1]=1-v(r,i,"y","x",o,e);break}}}const Bt=new pt,O={width:window.innerWidth,height:window.innerHeight},W=new ut(20,O.width/O.height,.1,1e5);W.position.set(120,60,120);const _=document.querySelector("canvas.webgl");if(_===null)throw new Error("Cannot find the canvas element");const M=new wt({canvas:_,antialias:!0});M.setSize(O.width,O.height);M.setPixelRatio(Math.min(window.devicePixelRatio,2));M.autoClear=!1;M.shadowMap.enabled=!0;const q=new ft(W,M.domElement);q.enableDamping=!0;q.target.set(0,18,0);const B=new yt,J=dt(W,M.domElement),St=new mt,tt=()=>{$.begin(),M.clear(),q.update();const T=St.getDelta();J.animating&&J.update(T),M.render(B,W),J.render(M),$.end(),requestAnimationFrame(tt)},Tt=new gt("#ffffff",.3);B.add(Tt);const b=new bt("#ffffff",1);b.position.set(10,20,-30);b.castShadow=!0;b.shadow.mapSize.width=1024;b.shadow.mapSize.height=1024;b.shadow.camera.near=1;b.shadow.camera.far=60;b.shadow.camera.top=33;b.shadow.camera.right=33;b.shadow.camera.bottom=-33;b.shadow.camera.left=-33;b.shadow.normalBias=.12;B.add(b);const et=new vt(b,10);B.add(et);et.visible=!1;const st=new xt(b.shadow.camera);B.add(st);st.visible=!1;const ot=new zt(20);ot.position.set(0,0,0);B.add(ot);class X{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y,this.array[this.top++]=t.z}}class Rt{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y}}class z{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygons=[],t&&this.build(t)}clone(){const t=new z;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map(e=>e.clone()),t}invert(){for(let e=0;e<this.polygons.length;e++)this.polygons[e].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const t=this.front;this.front=this.back,this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let e=new Array,s=new Array;for(let n=0;n<t.length;n++)this.plane.splitPolygon(t[n],e,s,e,s);return this.front&&(e=this.front.clipPolygons(e)),this.back?s=this.back.clipPolygons(s):s=[],e.concat(s)}clipTo(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const e=[],s=[];for(let n=0;n<t.length;n++)this.plane.splitPolygon(t[n],this.polygons,this.polygons,e,s);e.length&&(this.front||(this.front=new z),this.front.build(e)),s.length&&(this.back||(this.back=new z),this.back.build(s))}}class g{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new g(this.x,this.y,this.z)}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}times(t){return this.x*=t,this.y*=t,this.z*=t,this}dividedBy(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,e){return this.add(new g().copy(t).sub(this).times(e))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2))}normalize(){return this.unit()}cross(t){const e=this.clone(),s=e.x,n=e.y,o=e.z,c=t.x,w=t.y,i=t.z;return this.x=n*i-o*w,this.y=o*c-s*i,this.z=s*w-n*c,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toVector3(){return new k(this.x,this.y,this.z)}}class A{constructor(t,e){this.normal=t,this.w=e,this.normal=t,this.w=e}clone(){return new A(this.normal.clone(),this.w)}flip(){this.normal.negate(),this.w=-this.w}splitPolygon(t,e,s,n,o){let p=0;const d=[];for(let u=0;u<t.vertices.length;u++){const a=this.normal.dot(t.vertices[u].pos)-this.w,r=a<-A.EPSILON?2:a>A.EPSILON?1:0;p|=r,d.push(r)}switch(p){case 0:(this.normal.dot(t.plane.normal)>0?e:s).push(t);break;case 1:n.push(t);break;case 2:o.push(t);break;case 3:{const u=[],a=[];for(let r=0;r<t.vertices.length;r++){const f=(r+1)%t.vertices.length,h=d[r],y=d[f],x=t.vertices[r],H=t.vertices[f];if(h!=2&&u.push(x),h!=1&&a.push(h!=2?x.clone():x),(h|y)==3){const Z=(this.w-this.normal.dot(x.pos))/this.normal.dot(new g().copy(H.pos).sub(x.pos)),G=x.interpolate(H,Z);u.push(G),a.push(G.clone())}}u.length>=3&&n.push(new R(u,t.shared)),a.length>=3&&o.push(new R(a,t.shared));break}}}static fromPoints(t,e,s){const n=new g().copy(e).sub(t).cross(new g().copy(s).sub(t)).normalize();return new A(n.clone(),n.dot(t))}}A.EPSILON=1e-5;class R{constructor(t,e){this.vertices=t,this.shared=e,this.plane=A.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new R(this.vertices.map(t=>t.clone()),this.shared)}flip(){this.vertices.reverse().map(t=>t.flip()),this.plane.flip()}}class E{constructor(t,e,s,n){this.pos=new g().copy(t),this.normal=new g().copy(e),this.uv=new g().copy(s),this.uv.z=0,n&&(this.color=new g().copy(n))}clone(){return new E(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,e){return new E(this.pos.clone().lerp(t.pos,e),this.normal.clone().lerp(t.normal,e),this.uv.clone().lerp(t.uv,e),this.color&&t.color&&this.color.clone().lerp(t.color,e))}}class m{constructor(){this.polygons=[]}static fromPolygons(t){const e=new m;return e.polygons=t,e}static fromGeometry(t,e){let s=[];const n=t.attributes.position,o=t.attributes.normal,c=t.attributes.uv,w=t.attributes.color,i=t.groups;let l;if(t.index)l=t.index.array;else{l=new Array(n.array.length/n.itemSize|0);for(let d=0;d<l.length;d++)l[d]=d}const p=l.length/3|0;s=new Array(p);for(let d=0,u=0,a=l.length;d<a;d+=3,u++){const r=new Array(3);for(let f=0;f<3;f++){const h=l[d+f],y=h*3,x=h*2,H=n.array[y],Z=n.array[y+1],G=n.array[y+2],rt=o.array[y],it=o.array[y+1],at=o.array[y+2],ct=c==null?void 0:c.array[x],lt=c==null?void 0:c.array[x+1];r[f]=new E(new g(H,Z,G),new g(rt,it,at),new g(ct,lt,0),w&&new g(w.array[y],w.array[y+1],w.array[y+2]))}if(e===void 0&&i&&i.length>0)for(const f of i)d>=f.start&&d<f.start+f.count&&(s[u]=new R(r,f.materialIndex));else s[u]=new R(r,e)}return m.fromPolygons(s.filter(d=>!Number.isNaN(d.plane.normal.x)))}static toGeometry(t,e){let s=0;const n=t.polygons;for(const a of n)s+=a.vertices.length-2;const o=new Mt,c=new X(s*3*3),w=new X(s*3*3),i=new Rt(s*2*3);let l;const p=[],d=[];for(const a of n){const r=a.vertices,f=r.length;a.shared!==void 0&&(p[a.shared]||(p[a.shared]=[])),f&&r[0].color!==void 0&&(l||(l=new X(s*3*3)));for(let h=3;h<=f;h++)(a.shared===void 0?d:p[a.shared]).push(c.top/3,c.top/3+1,c.top/3+2),c.write(r[0].pos),c.write(r[h-2].pos),c.write(r[h-1].pos),w.write(r[0].normal),w.write(r[h-2].normal),w.write(r[h-1].normal),i&&(i.write(r[0].uv),i.write(r[h-2].uv),i.write(r[h-1].uv)),l&&(l.write(r[0].color),l.write(r[h-2].color),l.write(r[h-1].color))}o.setAttribute("position",new j(c.array,3)),o.setAttribute("normal",new j(w.array,3)),i&&o.setAttribute("uv",new j(i.array,2)),l&&o.setAttribute("color",new j(l.array,3));for(let a=0;a<p.length;a++)p[a]===void 0&&(p[a]=[]);if(p.length){let a=[],r=0;for(let f=0;f<p.length;f++)o.addGroup(r,p[f].length,f),r+=p[f].length,a=a.concat(p[f]);o.addGroup(r,d.length,p.length),a=a.concat(d),o.setIndex(a)}const u=new Pt().copy(e).invert();return o.applyMatrix4(u),o.computeBoundingSphere(),o.computeBoundingBox(),o}static fromMesh(t,e){const s=m.fromGeometry(t.geometry,e),n=new k,o=new kt;o.getNormalMatrix(t.matrix);for(let c=0;c<s.polygons.length;c++){const w=s.polygons[c];for(let i=0;i<w.vertices.length;i++){const l=w.vertices[i];l.pos.copy(n.copy(l.pos.toVector3()).applyMatrix4(t.matrix)),l.normal.copy(n.copy(l.normal.toVector3()).applyMatrix3(o))}}return s}static toMesh(t,e,s){const n=m.toGeometry(t,e),o=new P(n,s);return o.matrix.copy(e),o.matrix.decompose(o.position,o.quaternion,o.scale),o.rotation.setFromQuaternion(o.quaternion),o.updateMatrixWorld(),o.castShadow=o.receiveShadow=!0,o}static union(t,e){const s=m.fromMesh(t),n=m.fromMesh(e);return m.toMesh(s.union(n),t.matrix,t.material)}static subtract(t,e){const s=m.fromMesh(t),n=m.fromMesh(e);return m.toMesh(s.subtract(n),t.matrix,t.material)}static intersect(t,e){const s=m.fromMesh(t),n=m.fromMesh(e);return m.toMesh(s.intersect(n),t.matrix,t.material)}clone(){const t=new m;return t.polygons=this.polygons.map(e=>e.clone()).filter(e=>Number.isFinite(e.plane.w)),t}toPolygons(){return this.polygons}union(t){const e=new z(this.clone().polygons),s=new z(t.clone().polygons);return e.clipTo(s),s.clipTo(e),s.invert(),s.clipTo(e),s.invert(),e.build(s.allPolygons()),m.fromPolygons(e.allPolygons())}subtract(t){const e=new z(this.clone().polygons),s=new z(t.clone().polygons);return e.invert(),e.clipTo(s),s.clipTo(e),s.invert(),s.clipTo(e),s.invert(),e.build(s.allPolygons()),e.invert(),m.fromPolygons(e.allPolygons())}intersect(t){const e=new z(this.clone().polygons),s=new z(t.clone().polygons);return e.invert(),s.clipTo(e),s.invert(),e.clipTo(s),s.clipTo(e),e.build(s.allPolygons()),e.invert(),m.fromPolygons(e.allPolygons())}inverse(){const t=this.clone();for(const e of t.polygons)e.flip();return t}toMesh(t,e){return m.toMesh(this,t,e)}toGeometry(t){return m.toGeometry(this,t)}}const D=new Y({roughness:1,metalness:0,wireframe:!1,transparent:!0,opacity:0}),Lt=new N(40,.8,30,8,.2),Ot=new Y({roughness:1,metalness:0,wireframe:!1}),K=new P(Lt,Ot);K.position.set(0,-.4,0);K.receiveShadow=!0;K.castShadow=!0;const nt=new Y({roughness:1,metalness:0,wireframe:!1}),Wt=new N(.8,26.8,30,8,.2),U=new P(Wt,nt);U.position.set(-20.4,12.6,0);U.receiveShadow=!0;U.castShadow=!0;const It=new N(40+.8,26.8,.8,8,.2),I=new P(It,nt);I.position.set(-.4,13.4-.8,-15-.4);I.receiveShadow=!0;I.castShadow=!0;I.updateMatrix();const Ft=new N(40+.8-10,26.8-10,.8,8,.2),F=new P(Ft,D);F.position.set(-.4,13.4-.8,-15-.4);F.receiveShadow=!0;F.castShadow=!0;F.updateMatrix();const Ht=m.subtract(I,F),Gt=new N(40+.8,26.8,.8,8,.2),V=new P(Gt,D);V.position.set(-.4,13.4-.8,15+.4);V.receiveShadow=!0;V.castShadow=!0;const jt=new N(.8,26.8,30+.8,8,.2),Q=new P(jt,D);Q.position.set(20.4,12.6,-.4);Q.receiveShadow=!0;Q.castShadow=!0;const Et=new N(40+.8,.8,30+.8,8,.2),C=new P(Et,D);C.position.set(-.4,26.8-.4,-.4);C.receiveShadow=!0;C.castShadow=!0;const S=new At;S.add(K);S.add(U);S.add(Ht);S.add(V);S.add(Q);S.add(C);B.add(S);tt();Nt(O,W,M);Bt.add(q,"autoRotate");
